// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0 effective-5.10 (swiftlang-6.0.0.9.10 clang-1600.0.26.2)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -O -module-name SKC
import Foundation
@_exported import SKC
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum Skie {
  public enum KotlinxCoroutinesCore {
    public enum Runnable {
      public typealias __Kotlin = SKC.Kotlinx_coroutines_coreRunnable
    }
    public enum Flow {
      public typealias __Kotlin = SKC.Kotlinx_coroutines_coreFlow
    }
    public enum StateFlow {
      public typealias __Kotlin = SKC.Kotlinx_coroutines_coreStateFlow
    }
    public enum SharedFlow {
      public typealias __Kotlin = SKC.Kotlinx_coroutines_coreSharedFlow
    }
    public enum MutableSharedFlow {
      public typealias __Kotlin = SKC.Kotlinx_coroutines_coreMutableSharedFlow
    }
    public enum MutableStateFlow {
      public typealias __Kotlin = SKC.Kotlinx_coroutines_coreMutableStateFlow
    }
    public enum SelectClause0 {
    }
    public enum SelectClause {
    }
    public enum SelectInstance {
    }
    public enum SelectClause1 {
    }
    public enum SelectClause2 {
    }
  }
  public typealias org_jetbrains_kotlinx__kotlinx_coroutines_core = SKC.Skie.KotlinxCoroutinesCore
  public enum RuntimeKotlin {
    public enum SkieColdFlowIterator {
      public typealias __Kotlin = SKC.SkieColdFlowIterator
    }
    public enum SkieKotlinFlow {
      public typealias __Kotlin = SKC.SkieKotlinFlow
    }
    public enum SkieKotlinMutableSharedFlow {
      public typealias __Kotlin = SKC.SkieKotlinMutableSharedFlow
    }
    public enum SkieKotlinMutableStateFlow {
      public typealias __Kotlin = SKC.SkieKotlinMutableStateFlow
    }
    public enum SkieKotlinOptionalFlow {
      public typealias __Kotlin = SKC.SkieKotlinOptionalFlow
    }
    public enum SkieKotlinOptionalMutableSharedFlow {
      public typealias __Kotlin = SKC.SkieKotlinOptionalMutableSharedFlow
    }
    public enum SkieKotlinOptionalMutableStateFlow {
      public typealias __Kotlin = SKC.SkieKotlinOptionalMutableStateFlow
    }
    public enum SkieKotlinOptionalSharedFlow {
      public typealias __Kotlin = SKC.SkieKotlinOptionalSharedFlow
    }
    public enum SkieKotlinOptionalStateFlow {
      public typealias __Kotlin = SKC.SkieKotlinOptionalStateFlow
    }
    public enum SkieKotlinSharedFlow {
      public typealias __Kotlin = SKC.SkieKotlinSharedFlow
    }
    public enum SkieKotlinStateFlow {
      public typealias __Kotlin = SKC.SkieKotlinStateFlow
    }
    public enum Skie_CancellationHandler {
      public typealias __Kotlin = SKC.Skie_CancellationHandler
    }
    public enum Skie_DispatcherDelegate {
      public typealias __Kotlin = SKC.Skie_DispatcherDelegate
    }
    public enum Skie_SuspendHandler {
      public typealias __Kotlin = SKC.Skie_SuspendHandler
    }
    public enum Skie_SuspendResult {
      public typealias __Kotlin = SKC.Skie_SuspendResult
      public enum Canceled {
        public typealias __Kotlin = SKC.Skie_SuspendResult.Canceled
      }
      public enum Error {
        public typealias __Kotlin = SKC.Skie_SuspendResult.Error
      }
      public enum Success {
        public typealias __Kotlin = SKC.Skie_SuspendResult.Success
      }
    }
  }
  public typealias co_touchlab_skie__runtime_kotlin = SKC.Skie.RuntimeKotlin
  public enum KtorUtils {
    public enum Pipeline {
    }
  }
  public typealias io_ktor__ktor_utils = SKC.Skie.KtorUtils
  public enum Jackrabbitclient {
    public enum CollectDataResultInternal {
      public enum Failure {
      }
    }
    public enum CollectInputsResultInternal {
      public enum Failure {
      }
    }
    public enum CrpcResponse {
    }
  }
  public typealias android_kmpcore_modules__jackrabbitclient = SKC.Skie.Jackrabbitclient
  public enum Okio {
    public enum BufferedSource {
    }
    public enum BufferedSink {
    }
  }
  public typealias com_squareup_okio__okio = SKC.Skie.Okio
  public enum android_kmpcore_jackrabbitclient_models__public {
    public enum KmpCollectInputsResult {
    }
    public enum Input {
    }
    public enum CollectInputsSingleResult {
    }
  }
  public enum KtorHttp {
    public enum OutgoingContent {
    }
  }
  public typealias io_ktor__ktor_http = SKC.Skie.KtorHttp
  public enum android_kmpcore_sdk_terminal_external_models__public {
    public enum SetupAttemptUnion {
    }
    public enum PaymentMethodUnion {
    }
    public enum CollectInputsResult {
    }
    public enum ExpandableLocation {
    }
    public enum ReaderListenable {
    }
    public enum ReaderAccessibility {
    }
    public enum Input {
    }
    public enum ConnectionConfiguration {
    }
    public enum DiscoveryConfiguration {
    }
    public enum ReaderSettingsParameters {
    }
    public enum ReaderSupportResult {
    }
    public enum RefundParameters {
      public enum Id {
      }
    }
  }
  public enum android_kmpcore_paymentcollection__public {
    public enum DynamicCurrencyConversionSelectionStatus {
    }
    public enum ManualEntryCollectionResult {
    }
    public enum TippingState {
      public enum EndState {
      }
      public enum IntermediateState {
      }
    }
    public enum AccountSelectionStatus {
    }
    public enum MagStripePinStatus {
    }
    public enum AutomationEvent {
    }
    public enum PaymentCollectionEvent {
    }
    public enum UserInteractionEvent {
    }
    public enum HardwareListenerEvent {
    }
    public enum HardwareEvent {
    }
    public enum OnlineAuthState {
      public enum ConfirmationResponseReceived {
      }
      public enum SecondGenAcResponseReceived {
      }
    }
    public enum PaymentCollectionResult {
    }
    public enum SecondGenACResponse {
    }
    public enum NetworkEvent {
    }
  }
  public enum android_kmpcore_transaction__public {
    public enum ChargeAttempt {
      public enum CompletedAttempt {
      }
    }
    public enum PaymentMethodCollectionType {
    }
  }
  public enum KotlinxSerializationCore {
    public enum SerialKind {
    }
    public enum SerializersModule {
    }
    public enum PolymorphicKind {
    }
    public enum PrimitiveKind {
    }
    public enum StructureKind {
    }
  }
  public typealias org_jetbrains_kotlinx__kotlinx_serialization_core = SKC.Skie.KotlinxSerializationCore
  public enum android_kmpcore_hardware__public {
    public enum TipConfigValidationResult {
    }
    public enum ManualEntryResult {
    }
    public enum TipSelectionResult {
    }
    public enum ManualEntryModel {
    }
    public enum Disposition {
    }
    public enum PaymentMethodCollectionResult {
    }
    public enum Confirmation {
    }
    public enum BbposSdkTipSelectionType {
    }
  }
  public enum android_kmpcore_hardware_magstripe__public {
    public enum MagStripeReadResult {
    }
  }
  public enum android_kmpcore_logging_models__public {
    public enum Outcome {
    }
  }
  public enum android_kmpcore_sdk_terminal_internal_models__public {
    public enum LocationRegistration {
    }
  }
}
@_hasMissingDesignatedInitializers public class SkieSwiftFlowIterator<T> : _Concurrency.AsyncIteratorProtocol {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func next() async -> T?
  @objc deinit
  public typealias Element = T
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncIteratorProtocol_Failure = Swift.Never
  #endif
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol SkieSwiftFlowProtocol<Element> : _Concurrency.AsyncSequence {
  associatedtype Element
  associatedtype Delegate : SKC.Kotlinx_coroutines_coreFlow
  @_spi(SKIE) var delegate: Self.Delegate { get }
}
#else
public protocol SkieSwiftFlowProtocol : _Concurrency.AsyncSequence {
  associatedtype Element
  associatedtype Delegate : SKC.Kotlinx_coroutines_coreFlow
  @_spi(SKIE) var delegate: Self.Delegate { get }
}
#endif
@_hasMissingDesignatedInitializers final public class SkieSwiftFlow<T> : SKC.SkieSwiftFlowProtocol, Swift._ObjectiveCBridgeable {
  @_spi(SKIE) final public let delegate: any SKC.Kotlinx_coroutines_coreFlow
  public static func _forceBridgeFromObjectiveC(_ source: SKC.SkieKotlinFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftFlow<T>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftFlow<T>?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinFlow<Swift.AnyObject>?) -> Self
  final public func _bridgeToObjectiveC() -> SKC.SkieKotlinFlow<Swift.AnyObject>
  final public func makeAsyncIterator() -> SKC.SkieSwiftFlowIterator<T>
  public typealias AsyncIterator = SKC.SkieSwiftFlowIterator<T>
  public typealias Element = T
  public typealias _ObjectiveCType = SKC.SkieKotlinFlow<Swift.AnyObject>
  public typealias Delegate = any SKC.Kotlinx_coroutines_coreFlow
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SkieSwiftOptionalFlow<T> : SKC.SkieSwiftFlowProtocol, Swift._ObjectiveCBridgeable {
  @_spi(SKIE) final public let delegate: any SKC.Kotlinx_coroutines_coreFlow
  public static func _forceBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftOptionalFlow<T>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftOptionalFlow<T>?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalFlow<Swift.AnyObject>?) -> Self
  final public func _bridgeToObjectiveC() -> SKC.SkieKotlinOptionalFlow<Swift.AnyObject>
  final public func makeAsyncIterator() -> SKC.SkieSwiftFlowIterator<T?>
  public typealias AsyncIterator = SKC.SkieSwiftFlowIterator<T?>
  public typealias Element = T?
  public typealias _ObjectiveCType = SKC.SkieKotlinOptionalFlow<Swift.AnyObject>
  public typealias Delegate = any SKC.Kotlinx_coroutines_coreFlow
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SkieSwiftSharedFlow<T> : SKC.SkieSwiftFlowProtocol, Swift._ObjectiveCBridgeable {
  @_spi(SKIE) final public let delegate: any SKC.Kotlinx_coroutines_coreSharedFlow
  final public var replayCache: [T] {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.SkieKotlinSharedFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftSharedFlow<T>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinSharedFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftSharedFlow<T>?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinSharedFlow<Swift.AnyObject>?) -> Self
  final public func _bridgeToObjectiveC() -> SKC.SkieKotlinSharedFlow<Swift.AnyObject>
  final public func makeAsyncIterator() -> SKC.SkieSwiftFlowIterator<T>
  public typealias AsyncIterator = SKC.SkieSwiftFlowIterator<T>
  public typealias Element = T
  public typealias _ObjectiveCType = SKC.SkieKotlinSharedFlow<Swift.AnyObject>
  public typealias Delegate = any SKC.Kotlinx_coroutines_coreSharedFlow
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SkieSwiftOptionalSharedFlow<T> : SKC.SkieSwiftFlowProtocol, Swift._ObjectiveCBridgeable {
  @_spi(SKIE) final public let delegate: any SKC.Kotlinx_coroutines_coreSharedFlow
  final public var replayCache: [T?] {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalSharedFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftOptionalSharedFlow<T>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalSharedFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftOptionalSharedFlow<T>?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalSharedFlow<Swift.AnyObject>?) -> Self
  final public func _bridgeToObjectiveC() -> SKC.SkieKotlinOptionalSharedFlow<Swift.AnyObject>
  final public func makeAsyncIterator() -> SKC.SkieSwiftFlowIterator<T?>
  public typealias AsyncIterator = SKC.SkieSwiftFlowIterator<T?>
  public typealias Element = T?
  public typealias _ObjectiveCType = SKC.SkieKotlinOptionalSharedFlow<Swift.AnyObject>
  public typealias Delegate = any SKC.Kotlinx_coroutines_coreSharedFlow
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SkieSwiftMutableSharedFlow<T> : SKC.SkieSwiftFlowProtocol, Swift._ObjectiveCBridgeable {
  @_spi(SKIE) final public let delegate: any SKC.Kotlinx_coroutines_coreMutableSharedFlow
  final public var subscriptionCount: SKC.SkieSwiftStateFlow<SKC.KotlinInt> {
    get
  }
  final public var replayCache: [T] {
    get
  }
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  final public func emit(value: T) async throws
  final public func tryEmit(value: T) -> Swift.Bool
  final public func resetReplayCache()
  public static func _forceBridgeFromObjectiveC(_ source: SKC.SkieKotlinMutableSharedFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftMutableSharedFlow<T>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinMutableSharedFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftMutableSharedFlow<T>?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinMutableSharedFlow<Swift.AnyObject>?) -> Self
  final public func _bridgeToObjectiveC() -> SKC.SkieKotlinMutableSharedFlow<Swift.AnyObject>
  final public func makeAsyncIterator() -> SKC.SkieSwiftFlowIterator<T>
  public typealias AsyncIterator = SKC.SkieSwiftFlowIterator<T>
  public typealias Element = T
  public typealias _ObjectiveCType = SKC.SkieKotlinMutableSharedFlow<Swift.AnyObject>
  public typealias Delegate = any SKC.Kotlinx_coroutines_coreMutableSharedFlow
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SkieSwiftOptionalMutableSharedFlow<T> : SKC.SkieSwiftFlowProtocol, Swift._ObjectiveCBridgeable {
  @_spi(SKIE) final public let delegate: any SKC.Kotlinx_coroutines_coreMutableSharedFlow
  final public var subscriptionCount: SKC.SkieSwiftStateFlow<SKC.KotlinInt> {
    get
  }
  final public var replayCache: [T?] {
    get
  }
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  final public func emit(value: T?) async throws
  final public func tryEmit(value: T?) -> Swift.Bool
  final public func resetReplayCache()
  public static func _forceBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalMutableSharedFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftOptionalMutableSharedFlow<T>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalMutableSharedFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftOptionalMutableSharedFlow<T>?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalMutableSharedFlow<Swift.AnyObject>?) -> Self
  final public func _bridgeToObjectiveC() -> SKC.SkieKotlinOptionalMutableSharedFlow<Swift.AnyObject>
  final public func makeAsyncIterator() -> SKC.SkieSwiftFlowIterator<T?>
  public typealias AsyncIterator = SKC.SkieSwiftFlowIterator<T?>
  public typealias Element = T?
  public typealias _ObjectiveCType = SKC.SkieKotlinOptionalMutableSharedFlow<Swift.AnyObject>
  public typealias Delegate = any SKC.Kotlinx_coroutines_coreMutableSharedFlow
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SkieSwiftStateFlow<T> : SKC.SkieSwiftFlowProtocol, Swift._ObjectiveCBridgeable {
  @_spi(SKIE) final public let delegate: any SKC.Kotlinx_coroutines_coreStateFlow
  final public var value: T {
    get
  }
  final public var replayCache: [T] {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.SkieKotlinStateFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftStateFlow<T>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinStateFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftStateFlow<T>?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinStateFlow<Swift.AnyObject>?) -> Self
  final public func _bridgeToObjectiveC() -> SKC.SkieKotlinStateFlow<Swift.AnyObject>
  final public func makeAsyncIterator() -> SKC.SkieSwiftFlowIterator<T>
  public typealias AsyncIterator = SKC.SkieSwiftFlowIterator<T>
  public typealias Element = T
  public typealias _ObjectiveCType = SKC.SkieKotlinStateFlow<Swift.AnyObject>
  public typealias Delegate = any SKC.Kotlinx_coroutines_coreStateFlow
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SkieSwiftOptionalStateFlow<T> : SKC.SkieSwiftFlowProtocol, Swift._ObjectiveCBridgeable {
  @_spi(SKIE) final public let delegate: any SKC.Kotlinx_coroutines_coreStateFlow
  final public var value: T? {
    get
  }
  final public var replayCache: [T?] {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalStateFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftOptionalStateFlow<T>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalStateFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftOptionalStateFlow<T>?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalStateFlow<Swift.AnyObject>?) -> Self
  final public func _bridgeToObjectiveC() -> SKC.SkieKotlinOptionalStateFlow<Swift.AnyObject>
  final public func makeAsyncIterator() -> SKC.SkieSwiftFlowIterator<T?>
  public typealias AsyncIterator = SKC.SkieSwiftFlowIterator<T?>
  public typealias Element = T?
  public typealias _ObjectiveCType = SKC.SkieKotlinOptionalStateFlow<Swift.AnyObject>
  public typealias Delegate = any SKC.Kotlinx_coroutines_coreStateFlow
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SkieSwiftMutableStateFlow<T> : SKC.SkieSwiftFlowProtocol, Swift._ObjectiveCBridgeable {
  @_spi(SKIE) final public let delegate: any SKC.Kotlinx_coroutines_coreMutableStateFlow
  final public var value: T {
    get
    set(value)
  }
  final public var replayCache: [T] {
    get
  }
  final public var subscriptionCount: SKC.SkieSwiftStateFlow<SKC.KotlinInt> {
    get
  }
  final public func compareAndSet(expect: T, update: T) -> Swift.Bool
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  final public func emit(value: T) async throws
  final public func tryEmit(value: T) -> Swift.Bool
  final public func resetReplayCache()
  public static func _forceBridgeFromObjectiveC(_ source: SKC.SkieKotlinMutableStateFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftMutableStateFlow<T>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinMutableStateFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftMutableStateFlow<T>?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinMutableStateFlow<Swift.AnyObject>?) -> Self
  final public func _bridgeToObjectiveC() -> SKC.SkieKotlinMutableStateFlow<Swift.AnyObject>
  final public func makeAsyncIterator() -> SKC.SkieSwiftFlowIterator<T>
  public typealias AsyncIterator = SKC.SkieSwiftFlowIterator<T>
  public typealias Element = T
  public typealias _ObjectiveCType = SKC.SkieKotlinMutableStateFlow<Swift.AnyObject>
  public typealias Delegate = any SKC.Kotlinx_coroutines_coreMutableStateFlow
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SkieSwiftOptionalMutableStateFlow<T> : SKC.SkieSwiftFlowProtocol, Swift._ObjectiveCBridgeable {
  @_spi(SKIE) final public let delegate: any SKC.Kotlinx_coroutines_coreMutableStateFlow
  final public var value: T? {
    get
    set(value)
  }
  final public var replayCache: [T?] {
    get
  }
  final public var subscriptionCount: SKC.SkieSwiftStateFlow<SKC.KotlinInt> {
    get
  }
  final public func compareAndSet(expect: T?, update: T?) -> Swift.Bool
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  final public func emit(value: T?) async throws
  final public func tryEmit(value: T?) -> Swift.Bool
  final public func resetReplayCache()
  public static func _forceBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalMutableStateFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftOptionalMutableStateFlow<T>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalMutableStateFlow<Swift.AnyObject>, result: inout SKC.SkieSwiftOptionalMutableStateFlow<T>?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.SkieKotlinOptionalMutableStateFlow<Swift.AnyObject>?) -> Self
  final public func _bridgeToObjectiveC() -> SKC.SkieKotlinOptionalMutableStateFlow<Swift.AnyObject>
  final public func makeAsyncIterator() -> SKC.SkieSwiftFlowIterator<T?>
  public typealias AsyncIterator = SKC.SkieSwiftFlowIterator<T?>
  public typealias Element = T?
  public typealias _ObjectiveCType = SKC.SkieKotlinOptionalMutableStateFlow<Swift.AnyObject>
  public typealias Delegate = any SKC.Kotlinx_coroutines_coreMutableStateFlow
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
  @objc deinit
}
extension SKC.JackrabbitClient {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func collectDataPollForResult(httpClient: SKC.Ktor_client_coreHttpClient, sessionToken: Swift.String, localIpAddress: Swift.String, baseUrl: Swift.String, urlPort: Swift.Int32, onUnexpectedDisconnect: (() -> Swift.Void)?, versionInfo: SKC.CommonVersionInfoPb, deviceInfo: SKC.CommonDeviceInfo, collectDataRequest: SKC.InternalCollectDataRequest, urlProtocol: SKC.Ktor_httpURLProtocol) async throws -> any SKC.CollectDataResultInternal
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func collectInputsPollForResult(httpClient: SKC.Ktor_client_coreHttpClient, sessionToken: Swift.String, localIpAddress: Swift.String, baseUrl: Swift.String, urlPort: Swift.Int32, onUnexpectedDisconnect: (() -> Swift.Void)?, versionInfo: SKC.CommonVersionInfoPb, deviceInfo: SKC.CommonDeviceInfo, kmpCollectInputsParameters: SKC.SKCKmpCollectInputsParameters, urlProtocol: SKC.Ktor_httpURLProtocol) async throws -> SKC.SKCKmpCollectInputsResult
}
extension SKC.Kotlinx_coroutines_coreJob {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func join() async throws
}
extension SKC.Skie.KtorUtils.Pipeline {
  public struct __Suspend<TSubject, TContext> where TSubject : AnyObject, TContext : AnyObject {
    public let __kotlinObject: SKC.Ktor_utilsPipeline<TSubject, TContext>
    public init(_ __kotlinObject: SKC.Ktor_utilsPipeline<TSubject, TContext>)
  }
}
public func skie<TSubject, TContext>(_ kotlinObject: SKC.Ktor_utilsPipeline<TSubject, TContext>) -> SKC.Skie.KtorUtils.Pipeline.__Suspend<TSubject, TContext> where TSubject : AnyObject, TContext : AnyObject
extension SKC.Skie.KtorUtils.Pipeline.__Suspend {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func execute(context: TContext, subject: TSubject) async throws -> TSubject
}
extension SKC.KotlinSuspendFunction2 {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func invoke(p1: Any?, p2: Any?) async throws -> Any?
}
extension SKC.Ktor_client_coreHttpClientCall {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func body(info: SKC.Ktor_utilsTypeInfo) async throws -> Any
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func bodyNullable(info: SKC.Ktor_utilsTypeInfo) async throws -> Any?
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func getResponseContent() async throws -> any SKC.Ktor_ioByteReadChannel
}
extension SKC.Ktor_ioByteReadChannel {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func awaitContent() async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func discard(max: Swift.Int64) async throws -> SKC.KotlinLong
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func peekTo(destination: SKC.Ktor_ioMemory, destinationOffset: Swift.Int64, offset: Swift.Int64, min: Swift.Int64, max: Swift.Int64) async throws -> SKC.KotlinLong
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readAvailable(dst: SKC.Ktor_ioChunkBuffer) async throws -> SKC.KotlinInt
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readAvailable(dst: SKC.KotlinByteArray, offset: Swift.Int32, length: Swift.Int32) async throws -> SKC.KotlinInt
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readAvailable(dst: Swift.UnsafeMutableRawPointer, offset: Swift.Int32, length: Swift.Int32) async throws -> SKC.KotlinInt
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readAvailable(dst: Swift.UnsafeMutableRawPointer, offset: Swift.Int64, length: Swift.Int64) async throws -> SKC.KotlinInt
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readBoolean() async throws -> SKC.KotlinBoolean
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readByte() async throws -> SKC.KotlinByte
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readDouble() async throws -> SKC.KotlinDouble
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readFloat() async throws -> SKC.KotlinFloat
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readFully(dst: SKC.Ktor_ioChunkBuffer, n: Swift.Int32) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readFully(dst: SKC.KotlinByteArray, offset: Swift.Int32, length: Swift.Int32) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readFully(dst: Swift.UnsafeMutableRawPointer, offset: Swift.Int32, length: Swift.Int32) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readFully(dst: Swift.UnsafeMutableRawPointer, offset: Swift.Int64, length: Swift.Int64) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readInt() async throws -> SKC.KotlinInt
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readLong() async throws -> SKC.KotlinLong
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readPacket(size: Swift.Int32) async throws -> SKC.Ktor_ioByteReadPacket
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readRemaining(limit: Swift.Int64) async throws -> SKC.Ktor_ioByteReadPacket
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readShort() async throws -> SKC.KotlinShort
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Use read { } instead.")
  public func readSuspendableSession(consumer: any SKC.KotlinSuspendFunction1) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readUTF8Line(limit: Swift.Int32) async throws -> Swift.String?
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func readUTF8LineTo(out: any SKC.KotlinAppendable, limit: Swift.Int32) async throws -> SKC.KotlinBoolean
}
extension SKC.KotlinSuspendFunction1 {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func invoke(p1: Any?) async throws -> Any?
}
extension SKC.Ktor_client_coreHttpClientEngine {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func execute(data: SKC.Ktor_client_coreHttpRequestData) async throws -> SKC.Ktor_client_coreHttpResponseData
}
extension SKC.KmpCrpcClient {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func post(httpClient: SKC.Ktor_client_coreHttpClient, service: Swift.String, method: Swift.String, message: SKC.Wire_runtimeMessage<Swift.AnyObject, Swift.AnyObject>, requestProtoAdapter: SKC.Wire_runtimeProtoAdapter<SKC.Wire_runtimeMessage<Swift.AnyObject, Swift.AnyObject>>, responseProtoAdapter: SKC.Wire_runtimeProtoAdapter<SKC.Wire_runtimeMessage<Swift.AnyObject, Swift.AnyObject>>, sessionToken: Swift.String, localIpAddress: Swift.String, deviceInfo: SKC.CommonDeviceInfo, versionInfo: SKC.CommonVersionInfoPb, baseUrl: Swift.String, urlPort: Swift.Int32, urlProtocol: SKC.Ktor_httpURLProtocol) async throws -> SKC.CrpcResponse<SKC.Wire_runtimeMessage<Swift.AnyObject, Swift.AnyObject>>
}
extension SKC.JackrabbitClientWrapper {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func collectDataPollForResult(httpClient: SKC.Ktor_client_coreHttpClient, sessionToken: Swift.String, localIpAddress: Swift.String, baseUrl: Swift.String, urlPort: Swift.Int32, onUnexpectedDisconnect: (() -> Swift.Void)?, versionInfo: SKC.CommonVersionInfoPb, deviceInfo: SKC.CommonDeviceInfo, collectDataRequest: SKC.InternalCollectDataRequest) async throws -> any SKC.CollectDataResultInternal
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func collectInputsPollForResult(httpClient: SKC.Ktor_client_coreHttpClient, sessionToken: Swift.String, localIpAddress: Swift.String, baseUrl: Swift.String, urlPort: Swift.Int32, onUnexpectedDisconnect: (() -> Swift.Void)?, versionInfo: SKC.CommonVersionInfoPb, deviceInfo: SKC.CommonDeviceInfo, kmpCollectInputsParameters: SKC.SKCKmpCollectInputsParameters) async throws -> SKC.SKCKmpCollectInputsResult
}
extension SKC.PaymentCollectionCoordinator {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func collectPaymentMethod(amount: SKC.Amount, transactionType: SKC.TransactionType, paymentCollectionListener: any SKC.PaymentCollectionListener, scaRequirement: SKC.SCARequirement?, tippingAmount: SKC.Amount?, skipTipping: Swift.Bool, manualEntry: Swift.Bool, isOffline: Swift.Bool, tipEligibleAmount: SKC.Amount?, isDeferredAuthorizationCountry: Swift.Bool, domesticDebitPriority: SKC.ReaderConfiguration.DomesticDebitPriority?, enableCustomerCancellation: Swift.Bool, surchargeNotice: Swift.String?, nonCardPaymentMethodTypes: [SKC.PaymentMethodType], requestIncrementalAuthorizationSupport: Swift.Bool, forcePinEntry: Swift.Bool) async throws -> any SKC.Kotlinx_coroutines_coreDeferred
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func selectDynamicCurrencyConversion(dynamicCurrencyConversionData: SKC.DynamicCurrencyConversionData) async throws -> (any SKC.Kotlinx_coroutines_coreDeferred)?
}
extension SKC.Kotlinx_coroutines_coreDeferred {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func await() async throws -> Any?
}
extension SKC.TransactionListener {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func onTransactionLog(intentId: Swift.String?, amount: SKC.KotlinLong?, tip: SKC.KotlinLong?, currency: Swift.String?, result: Swift.String?, tlv: Swift.String?) async throws
}
extension SKC.PaymentCollector {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func startReader(configuration: SKC.ReaderConfiguration) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func stopReader(phase: SKC.CancellationPhase) async throws
}
extension SKC.Skie.RuntimeKotlin.SkieColdFlowIterator {
  public struct __Suspend<E> where E : AnyObject {
    public let __kotlinObject: SKC.SkieColdFlowIterator<E>
    public init(_ __kotlinObject: SKC.SkieColdFlowIterator<E>)
  }
}
public func skie<E>(_ kotlinObject: SKC.SkieColdFlowIterator<E>) -> SKC.Skie.RuntimeKotlin.SkieColdFlowIterator.__Suspend<E> where E : AnyObject
extension SKC.Skie.RuntimeKotlin.SkieColdFlowIterator.__Suspend {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func hasNext() async throws -> SKC.KotlinBoolean
}
extension SKC.Kotlinx_coroutines_coreFlow {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func collect(collector: any SKC.Kotlinx_coroutines_coreFlowCollector) async throws
}
extension SKC.Kotlinx_coroutines_coreFlowCollector {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func emit(value: Any?) async throws
}
extension SKC.Ktor_httpOutgoingContent.ProtocolUpgrade {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func upgrade(input: any SKC.Ktor_ioByteReadChannel, output: any SKC.Ktor_ioByteWriteChannel, engineContext: any SKC.KotlinCoroutineContext, userContext: any SKC.KotlinCoroutineContext) async throws -> any SKC.Kotlinx_coroutines_coreJob
}
extension SKC.Ktor_ioByteWriteChannel {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func awaitFreeSpace() async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeAvailable(src: SKC.Ktor_ioChunkBuffer) async throws -> SKC.KotlinInt
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeAvailable(src: SKC.KotlinByteArray, offset: Swift.Int32, length: Swift.Int32) async throws -> SKC.KotlinInt
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeAvailable(src: Swift.UnsafeMutableRawPointer, offset: Swift.Int32, length: Swift.Int32) async throws -> SKC.KotlinInt
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeAvailable(src: Swift.UnsafeMutableRawPointer, offset: Swift.Int64, length: Swift.Int64) async throws -> SKC.KotlinInt
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeByte(b: Swift.Int8) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeDouble(d: Swift.Double) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeFloat(f: Swift.Float) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeFully(memory: SKC.Ktor_ioMemory, startIndex: Swift.Int32, endIndex: Swift.Int32) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeFully(src: SKC.Ktor_ioBuffer) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeFully(src: SKC.KotlinByteArray, offset: Swift.Int32, length: Swift.Int32) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeFully(src: Swift.UnsafeMutableRawPointer, offset: Swift.Int32, length: Swift.Int32) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeFully(src: Swift.UnsafeMutableRawPointer, offset: Swift.Int64, length: Swift.Int64) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeInt(i: Swift.Int32) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeLong(l: Swift.Int64) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writePacket(packet: SKC.Ktor_ioByteReadPacket) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeShort(s: Swift.Int16) async throws
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Use write { } instead.")
  public func writeSuspendSession(visitor: any SKC.KotlinSuspendFunction1) async throws
}
extension SKC.Ktor_httpOutgoingContent.WriteChannelContent {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func writeTo(channel: any SKC.Ktor_ioByteWriteChannel) async throws
}
extension SKC.Ktor_client_coreHttpResponse {
  @available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
  public func toCrpcResponse(requestId: Swift.Int64, protoAdapter: SKC.Wire_runtimeProtoAdapter<SKC.Wire_runtimeMessage<Swift.AnyObject, Swift.AnyObject>>) async throws -> SKC.CrpcResponse<SKC.Wire_runtimeMessage<Swift.AnyObject, Swift.AnyObject>>
}
public func SkieKotlinFlow<T>(_ flow: SKC.SkieSwiftFlow<T>) -> SKC.SkieKotlinFlow<T> where T : AnyObject
public func SkieKotlinFlow<T>(_ flow: SKC.SkieSwiftSharedFlow<T>) -> SKC.SkieKotlinFlow<T> where T : AnyObject
public func SkieKotlinFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinFlow<T> where T : AnyObject
public func SkieKotlinFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinFlow<T> where T : AnyObject
public func SkieKotlinFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinFlow<T> where T : AnyObject
public func SkieKotlinFlow<T>(_ flow: SKC.SkieSwiftFlow<T>) -> SKC.SkieKotlinFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinFlow<T>(_ flow: SKC.SkieSwiftSharedFlow<T>) -> SKC.SkieKotlinFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
extension SKC.SkieSwiftFlow where T : AnyObject {
  convenience public init(_ flow: SKC.SkieKotlinFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
}
extension SKC.SkieSwiftFlow where T : Swift._ObjectiveCBridgeable {
  convenience public init(_ flow: SKC.SkieKotlinFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
}
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftFlow<T>) -> SKC.SkieKotlinOptionalFlow<T> where T : AnyObject
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftOptionalFlow<T>) -> SKC.SkieKotlinOptionalFlow<T> where T : AnyObject
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftSharedFlow<T>) -> SKC.SkieKotlinOptionalFlow<T> where T : AnyObject
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftOptionalSharedFlow<T>) -> SKC.SkieKotlinOptionalFlow<T> where T : AnyObject
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalFlow<T> where T : AnyObject
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalFlow<T> where T : AnyObject
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinOptionalFlow<T> where T : AnyObject
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftOptionalStateFlow<T>) -> SKC.SkieKotlinOptionalFlow<T> where T : AnyObject
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinOptionalFlow<T> where T : AnyObject
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>) -> SKC.SkieKotlinOptionalFlow<T> where T : AnyObject
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftFlow<T>) -> SKC.SkieKotlinOptionalFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftOptionalFlow<T>) -> SKC.SkieKotlinOptionalFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftSharedFlow<T>) -> SKC.SkieKotlinOptionalFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftOptionalSharedFlow<T>) -> SKC.SkieKotlinOptionalFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinOptionalFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftOptionalStateFlow<T>) -> SKC.SkieKotlinOptionalFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinOptionalFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>) -> SKC.SkieKotlinOptionalFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
extension SKC.SkieSwiftOptionalFlow where T : AnyObject {
  convenience public init(_ flow: SKC.SkieKotlinFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>)
}
extension SKC.SkieSwiftOptionalFlow where T : Swift._ObjectiveCBridgeable {
  convenience public init(_ flow: SKC.SkieKotlinFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>)
}
public func SkieKotlinSharedFlow<T>(_ flow: SKC.SkieSwiftSharedFlow<T>) -> SKC.SkieKotlinSharedFlow<T> where T : AnyObject
public func SkieKotlinSharedFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinSharedFlow<T> where T : AnyObject
public func SkieKotlinSharedFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinSharedFlow<T> where T : AnyObject
public func SkieKotlinSharedFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinSharedFlow<T> where T : AnyObject
public func SkieKotlinSharedFlow<T>(_ flow: SKC.SkieSwiftSharedFlow<T>) -> SKC.SkieKotlinSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinSharedFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinSharedFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinSharedFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
extension SKC.SkieSwiftSharedFlow where T : AnyObject {
  convenience public init(_ flow: SKC.SkieKotlinSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
}
extension SKC.SkieSwiftSharedFlow where T : Swift._ObjectiveCBridgeable {
  convenience public init(_ flow: SKC.SkieKotlinSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
}
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftSharedFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T> where T : AnyObject
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftOptionalSharedFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T> where T : AnyObject
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T> where T : AnyObject
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T> where T : AnyObject
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T> where T : AnyObject
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftOptionalStateFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T> where T : AnyObject
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T> where T : AnyObject
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T> where T : AnyObject
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftSharedFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftOptionalSharedFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftOptionalStateFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalSharedFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>) -> SKC.SkieKotlinOptionalSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
extension SKC.SkieSwiftOptionalSharedFlow where T : AnyObject {
  convenience public init(_ flow: SKC.SkieKotlinSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>)
}
extension SKC.SkieSwiftOptionalSharedFlow where T : Swift._ObjectiveCBridgeable {
  convenience public init(_ flow: SKC.SkieKotlinSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>)
}
public func SkieKotlinMutableSharedFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinMutableSharedFlow<T> where T : AnyObject
public func SkieKotlinMutableSharedFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinMutableSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
extension SKC.SkieSwiftMutableSharedFlow where T : AnyObject {
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
}
extension SKC.SkieSwiftMutableSharedFlow where T : Swift._ObjectiveCBridgeable {
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
}
public func SkieKotlinOptionalMutableSharedFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalMutableSharedFlow<T> where T : AnyObject
public func SkieKotlinOptionalMutableSharedFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalMutableSharedFlow<T> where T : AnyObject
public func SkieKotlinOptionalMutableSharedFlow<T>(_ flow: SKC.SkieSwiftMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalMutableSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalMutableSharedFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>) -> SKC.SkieKotlinOptionalMutableSharedFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
extension SKC.SkieSwiftOptionalMutableSharedFlow where T : AnyObject {
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>)
}
extension SKC.SkieSwiftOptionalMutableSharedFlow where T : Swift._ObjectiveCBridgeable {
  convenience public init(_ flow: SKC.SkieKotlinMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableSharedFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableSharedFlow<T>)
}
public func SkieKotlinStateFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinStateFlow<T> where T : AnyObject
public func SkieKotlinStateFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinStateFlow<T> where T : AnyObject
public func SkieKotlinStateFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinStateFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinStateFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinStateFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
extension SKC.SkieSwiftStateFlow where T : AnyObject {
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
}
extension SKC.SkieSwiftStateFlow where T : Swift._ObjectiveCBridgeable {
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
}
public func SkieKotlinOptionalStateFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinOptionalStateFlow<T> where T : AnyObject
public func SkieKotlinOptionalStateFlow<T>(_ flow: SKC.SkieSwiftOptionalStateFlow<T>) -> SKC.SkieKotlinOptionalStateFlow<T> where T : AnyObject
public func SkieKotlinOptionalStateFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinOptionalStateFlow<T> where T : AnyObject
public func SkieKotlinOptionalStateFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>) -> SKC.SkieKotlinOptionalStateFlow<T> where T : AnyObject
public func SkieKotlinOptionalStateFlow<T>(_ flow: SKC.SkieSwiftStateFlow<T>) -> SKC.SkieKotlinOptionalStateFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalStateFlow<T>(_ flow: SKC.SkieSwiftOptionalStateFlow<T>) -> SKC.SkieKotlinOptionalStateFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalStateFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinOptionalStateFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalStateFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>) -> SKC.SkieKotlinOptionalStateFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
extension SKC.SkieSwiftOptionalStateFlow where T : AnyObject {
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>)
}
extension SKC.SkieSwiftOptionalStateFlow where T : Swift._ObjectiveCBridgeable {
  convenience public init(_ flow: SKC.SkieKotlinStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>)
}
public func SkieKotlinMutableStateFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinMutableStateFlow<T> where T : AnyObject
public func SkieKotlinMutableStateFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinMutableStateFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
extension SKC.SkieSwiftMutableStateFlow where T : AnyObject {
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
}
extension SKC.SkieSwiftMutableStateFlow where T : Swift._ObjectiveCBridgeable {
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
}
public func SkieKotlinOptionalMutableStateFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinOptionalMutableStateFlow<T> where T : AnyObject
public func SkieKotlinOptionalMutableStateFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>) -> SKC.SkieKotlinOptionalMutableStateFlow<T> where T : AnyObject
public func SkieKotlinOptionalMutableStateFlow<T>(_ flow: SKC.SkieSwiftMutableStateFlow<T>) -> SKC.SkieKotlinOptionalMutableStateFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
public func SkieKotlinOptionalMutableStateFlow<T>(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>) -> SKC.SkieKotlinOptionalMutableStateFlow<T._ObjectiveCType> where T : Swift._ObjectiveCBridgeable
extension SKC.SkieSwiftOptionalMutableStateFlow where T : AnyObject {
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>)
}
extension SKC.SkieSwiftOptionalMutableStateFlow where T : Swift._ObjectiveCBridgeable {
  convenience public init(_ flow: SKC.SkieKotlinMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieKotlinOptionalMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T._ObjectiveCType>)
  convenience public init(_ flow: SKC.SkieSwiftMutableStateFlow<T>)
  convenience public init(_ flow: SKC.SkieSwiftOptionalMutableStateFlow<T>)
}
@frozen public enum KotlinKVariance : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case invariant
  case `in`
  case out
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__KotlinKVariance, result: inout SKC.KotlinKVariance?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__KotlinKVariance, result: inout SKC.KotlinKVariance?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__KotlinKVariance?) -> SKC.KotlinKVariance
  public func _bridgeToObjectiveC() -> SKC.__KotlinKVariance
  public typealias _ObjectiveCType = SKC.__KotlinKVariance
  public static func == (a: SKC.KotlinKVariance, b: SKC.KotlinKVariance) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.KotlinKVariance]
  nonisolated public static var allCases: [SKC.KotlinKVariance] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.KotlinKVariance {
  public func toKotlinEnum() -> SKC.__KotlinKVariance
}
extension SKC.__KotlinKVariance {
  public func toSwiftEnum() -> SKC.KotlinKVariance
}
@frozen public enum LogLevel : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case info
  case warn
  case error
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__LogLevel, result: inout SKC.LogLevel?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__LogLevel, result: inout SKC.LogLevel?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__LogLevel?) -> SKC.LogLevel
  public func _bridgeToObjectiveC() -> SKC.__LogLevel
  public typealias _ObjectiveCType = SKC.__LogLevel
  public static func == (a: SKC.LogLevel, b: SKC.LogLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.LogLevel]
  nonisolated public static var allCases: [SKC.LogLevel] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.LogLevel {
  public func toKotlinEnum() -> SKC.__LogLevel
}
extension SKC.__LogLevel {
  public func toSwiftEnum() -> SKC.LogLevel
}
extension SKC.InternalPaymentMethodOptions {
  public typealias RoutingPriority = SKC.__Bridge__InternalPaymentMethodOptions_RoutingPriority
}
extension SKC.__Bridge__InternalPaymentMethodOptions_RoutingPriority {
  public func toKotlinEnum() -> SKC.InternalPaymentMethodOptions.__RoutingPriority
}
extension SKC.InternalPaymentMethodOptions.__RoutingPriority {
  public func toSwiftEnum() -> SKC.InternalPaymentMethodOptions.RoutingPriority
}
@frozen public enum __Bridge__InternalPaymentMethodOptions_RoutingPriority : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case domestic
  case international
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.InternalPaymentMethodOptions.RoutingPriorityCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.InternalPaymentMethodOptions.__RoutingPriority, result: inout SKC.InternalPaymentMethodOptions.RoutingPriority?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.InternalPaymentMethodOptions.__RoutingPriority, result: inout SKC.InternalPaymentMethodOptions.RoutingPriority?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.InternalPaymentMethodOptions.__RoutingPriority?) -> SKC.__Bridge__InternalPaymentMethodOptions_RoutingPriority
  public func _bridgeToObjectiveC() -> SKC.InternalPaymentMethodOptions.__RoutingPriority
  public typealias _ObjectiveCType = SKC.InternalPaymentMethodOptions.__RoutingPriority
  public static func == (a: SKC.__Bridge__InternalPaymentMethodOptions_RoutingPriority, b: SKC.__Bridge__InternalPaymentMethodOptions_RoutingPriority) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__InternalPaymentMethodOptions_RoutingPriority]
  nonisolated public static var allCases: [SKC.__Bridge__InternalPaymentMethodOptions_RoutingPriority] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalPaymentMethodOptions {
  public typealias CardOptionsRequest3dSecureType = SKC.__Bridge__InternalPaymentMethodOptions_CardOptionsRequest3dSecureType
}
extension SKC.__Bridge__InternalPaymentMethodOptions_CardOptionsRequest3dSecureType {
  public func toKotlinEnum() -> SKC.InternalPaymentMethodOptions.__CardOptionsRequest3dSecureType
}
extension SKC.InternalPaymentMethodOptions.__CardOptionsRequest3dSecureType {
  public func toSwiftEnum() -> SKC.InternalPaymentMethodOptions.CardOptionsRequest3dSecureType
}
@frozen public enum __Bridge__InternalPaymentMethodOptions_CardOptionsRequest3dSecureType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case automatic
  case any
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.InternalPaymentMethodOptions.CardOptionsRequest3dSecureTypeCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.InternalPaymentMethodOptions.__CardOptionsRequest3dSecureType, result: inout SKC.InternalPaymentMethodOptions.CardOptionsRequest3dSecureType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.InternalPaymentMethodOptions.__CardOptionsRequest3dSecureType, result: inout SKC.InternalPaymentMethodOptions.CardOptionsRequest3dSecureType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.InternalPaymentMethodOptions.__CardOptionsRequest3dSecureType?) -> SKC.__Bridge__InternalPaymentMethodOptions_CardOptionsRequest3dSecureType
  public func _bridgeToObjectiveC() -> SKC.InternalPaymentMethodOptions.__CardOptionsRequest3dSecureType
  public typealias _ObjectiveCType = SKC.InternalPaymentMethodOptions.__CardOptionsRequest3dSecureType
  public static func == (a: SKC.__Bridge__InternalPaymentMethodOptions_CardOptionsRequest3dSecureType, b: SKC.__Bridge__InternalPaymentMethodOptions_CardOptionsRequest3dSecureType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__InternalPaymentMethodOptions_CardOptionsRequest3dSecureType]
  nonisolated public static var allCases: [SKC.__Bridge__InternalPaymentMethodOptions_CardOptionsRequest3dSecureType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum InternalMethod : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case automatic
  case manual
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__InternalMethod.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__InternalMethod, result: inout SKC.InternalMethod?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__InternalMethod, result: inout SKC.InternalMethod?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__InternalMethod?) -> SKC.InternalMethod
  public func _bridgeToObjectiveC() -> SKC.__InternalMethod
  public typealias _ObjectiveCType = SKC.__InternalMethod
  public typealias Companion = SKC.__InternalMethod.Companion
  public static func == (a: SKC.InternalMethod, b: SKC.InternalMethod) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.InternalMethod]
  nonisolated public static var allCases: [SKC.InternalMethod] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalMethod {
  public func toKotlinEnum() -> SKC.__InternalMethod
}
extension SKC.__InternalMethod {
  public func toSwiftEnum() -> SKC.InternalMethod
}
@frozen public enum InternalReaderErrorCode : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case readerErrorCodeUnspecified
  case cancelFailed
  case notConnectedToReader
  case alreadyConnectedToReader
  case confirmInvalidPaymentIntent
  case confirmInvalidSetupIntent
  case invalidClientSecret
  case unsupportedOperation
  case unexpectedOperation
  case unsupportedSdk
  case missingRequiredParameter
  case invalidRequiredParameter
  case invalidTipParameter
  case canceled
  case locationServicesDisabled
  case cardInsertNotRead
  case cardSwipeNotRead
  case cardReadTimedOut
  case cardRemoved
  case customerConsentRequired
  case cardLeftInReader
  case featureNotEnabledOnAccount
  case readerBusy
  case readerCommunicationError
  case unsupportedReaderVersion
  case unexpectedSdkError
  case declinedByStripeApi
  case declinedByReader
  case requestTimedOut
  case stripeApiConnectionError
  case stripeApiError
  case stripeApiResponseDecodingError
  case connectionTokenProviderError
  case sessionExpired
  case amountExceedsMaxOfflineAmount
  case offlinePaymentsDatabaseTooLarge
  case readerConnectionNotAvailableOffline
  case locationConnectionNotAvailableOffline
  case noLastSeenAccount
  case invalidOfflineCurrency
  case cardSwipeNotAvailable
  case interacNotSupportedOffline
  case onlinePinNotSupportedOffline
  case mobileWalletNotSupportedOnSetupIntents
  case offlineAndCardExpired
  case offlineTransactionDeclined
  case offlineCollectAndConfirmMismatch
  case offlineTestmodePaymentInLivemode
  case offlineLivemodePaymentInTestmode
  case offlinePaymentIntentNotFound
  case missingEmvData
  case connectionTokenProviderErrorWhileForwarding
  case accountIdMismatchWhileForwarding
  case forceOfflineWithFeatureDisabled
  case notConnectedToInternetAndRequireOnlineSet
  case testCardInLivemode
  case collectInputsApplicationError
  case collectInputsTimedOut
  case collectInputsInvalidParameter
  case collectInputsUnsupported
  case readerSettingsError
  case readerMissingEncryptionKeys
  case readerCommunicationSslError
  case invalidSurchargeParameter
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__InternalReaderErrorCode.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__InternalReaderErrorCode, result: inout SKC.InternalReaderErrorCode?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__InternalReaderErrorCode, result: inout SKC.InternalReaderErrorCode?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__InternalReaderErrorCode?) -> SKC.InternalReaderErrorCode
  public func _bridgeToObjectiveC() -> SKC.__InternalReaderErrorCode
  public typealias _ObjectiveCType = SKC.__InternalReaderErrorCode
  public typealias Companion = SKC.__InternalReaderErrorCode.Companion
  public static func == (a: SKC.InternalReaderErrorCode, b: SKC.InternalReaderErrorCode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.InternalReaderErrorCode]
  nonisolated public static var allCases: [SKC.InternalReaderErrorCode] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalReaderErrorCode {
  public func toKotlinEnum() -> SKC.__InternalReaderErrorCode
}
extension SKC.__InternalReaderErrorCode {
  public func toSwiftEnum() -> SKC.InternalReaderErrorCode
}
@frozen public enum InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case inputTypeInvalid
  case signature
  case selection
  case email
  case text
  case numeric
  case phone
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputTypeCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType, result: inout SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType, result: inout SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType?) -> SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType
  public func _bridgeToObjectiveC() -> SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType
  public typealias _ObjectiveCType = SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType
  public static func == (a: SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType, b: SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType]
  nonisolated public static var allCases: [SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType {
  public func toKotlinEnum() -> SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType
}
extension SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType {
  public func toSwiftEnum() -> SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType
}
@frozen public enum InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case valueInvalid
  case enabled
  case disabled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValueCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue, result: inout SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue, result: inout SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue?) -> SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue
  public func _bridgeToObjectiveC() -> SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue
  public typealias _ObjectiveCType = SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue
  public static func == (a: SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue, b: SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue]
  nonisolated public static var allCases: [SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue {
  public func toKotlinEnum() -> SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue
}
extension SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue {
  public func toSwiftEnum() -> SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue
}
@frozen public enum InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case styleInvalid
  case primary
  case secondary
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyleCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle, result: inout SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle, result: inout SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle?) -> SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle
  public func _bridgeToObjectiveC() -> SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle
  public typealias _ObjectiveCType = SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle
  public static func == (a: SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle, b: SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle]
  nonisolated public static var allCases: [SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle {
  public func toKotlinEnum() -> SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle
}
extension SKC.__InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle {
  public func toSwiftEnum() -> SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle
}
extension SKC.InternalCollectDataRequest {
  public typealias CollectDataType = SKC.__Bridge__InternalCollectDataRequest_CollectDataType
}
extension SKC.__Bridge__InternalCollectDataRequest_CollectDataType {
  public func toKotlinEnum() -> SKC.InternalCollectDataRequest.__CollectDataType
}
extension SKC.InternalCollectDataRequest.__CollectDataType {
  public func toSwiftEnum() -> SKC.InternalCollectDataRequest.CollectDataType
}
@frozen public enum __Bridge__InternalCollectDataRequest_CollectDataType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case dataTypeInvalid
  case magstripe
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.InternalCollectDataRequest.CollectDataTypeCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.InternalCollectDataRequest.__CollectDataType, result: inout SKC.InternalCollectDataRequest.CollectDataType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.InternalCollectDataRequest.__CollectDataType, result: inout SKC.InternalCollectDataRequest.CollectDataType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.InternalCollectDataRequest.__CollectDataType?) -> SKC.__Bridge__InternalCollectDataRequest_CollectDataType
  public func _bridgeToObjectiveC() -> SKC.InternalCollectDataRequest.__CollectDataType
  public typealias _ObjectiveCType = SKC.InternalCollectDataRequest.__CollectDataType
  public static func == (a: SKC.__Bridge__InternalCollectDataRequest_CollectDataType, b: SKC.__Bridge__InternalCollectDataRequest_CollectDataType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__InternalCollectDataRequest_CollectDataType]
  nonisolated public static var allCases: [SKC.__Bridge__InternalCollectDataRequest_CollectDataType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalCollectInputsRequest {
  public typealias InputInputType = SKC.__Bridge__InternalCollectInputsRequest_InputInputType
}
extension SKC.__Bridge__InternalCollectInputsRequest_InputInputType {
  public func toKotlinEnum() -> SKC.InternalCollectInputsRequest.__InputInputType
}
extension SKC.InternalCollectInputsRequest.__InputInputType {
  public func toSwiftEnum() -> SKC.InternalCollectInputsRequest.InputInputType
}
@frozen public enum __Bridge__InternalCollectInputsRequest_InputInputType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case inputTypeInvalid
  case signature
  case selection
  case phone
  case email
  case text
  case numeric
  case address
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.InternalCollectInputsRequest.InputInputTypeCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.InternalCollectInputsRequest.__InputInputType, result: inout SKC.InternalCollectInputsRequest.InputInputType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.InternalCollectInputsRequest.__InputInputType, result: inout SKC.InternalCollectInputsRequest.InputInputType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.InternalCollectInputsRequest.__InputInputType?) -> SKC.__Bridge__InternalCollectInputsRequest_InputInputType
  public func _bridgeToObjectiveC() -> SKC.InternalCollectInputsRequest.__InputInputType
  public typealias _ObjectiveCType = SKC.InternalCollectInputsRequest.__InputInputType
  public static func == (a: SKC.__Bridge__InternalCollectInputsRequest_InputInputType, b: SKC.__Bridge__InternalCollectInputsRequest_InputInputType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__InternalCollectInputsRequest_InputInputType]
  nonisolated public static var allCases: [SKC.__Bridge__InternalCollectInputsRequest_InputInputType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalCollectInputsRequest {
  public typealias ToggleValue = SKC.__Bridge__InternalCollectInputsRequest_ToggleValue
}
extension SKC.__Bridge__InternalCollectInputsRequest_ToggleValue {
  public func toKotlinEnum() -> SKC.InternalCollectInputsRequest.__ToggleValue
}
extension SKC.InternalCollectInputsRequest.__ToggleValue {
  public func toSwiftEnum() -> SKC.InternalCollectInputsRequest.ToggleValue
}
@frozen public enum __Bridge__InternalCollectInputsRequest_ToggleValue : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case valueInvalid
  case enabled
  case disabled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.InternalCollectInputsRequest.ToggleValueCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.InternalCollectInputsRequest.__ToggleValue, result: inout SKC.InternalCollectInputsRequest.ToggleValue?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.InternalCollectInputsRequest.__ToggleValue, result: inout SKC.InternalCollectInputsRequest.ToggleValue?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.InternalCollectInputsRequest.__ToggleValue?) -> SKC.__Bridge__InternalCollectInputsRequest_ToggleValue
  public func _bridgeToObjectiveC() -> SKC.InternalCollectInputsRequest.__ToggleValue
  public typealias _ObjectiveCType = SKC.InternalCollectInputsRequest.__ToggleValue
  public static func == (a: SKC.__Bridge__InternalCollectInputsRequest_ToggleValue, b: SKC.__Bridge__InternalCollectInputsRequest_ToggleValue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__InternalCollectInputsRequest_ToggleValue]
  nonisolated public static var allCases: [SKC.__Bridge__InternalCollectInputsRequest_ToggleValue] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalCollectInputsRequest {
  public typealias ChoiceStyle = SKC.__Bridge__InternalCollectInputsRequest_ChoiceStyle
}
extension SKC.__Bridge__InternalCollectInputsRequest_ChoiceStyle {
  public func toKotlinEnum() -> SKC.InternalCollectInputsRequest.__ChoiceStyle
}
extension SKC.InternalCollectInputsRequest.__ChoiceStyle {
  public func toSwiftEnum() -> SKC.InternalCollectInputsRequest.ChoiceStyle
}
@frozen public enum __Bridge__InternalCollectInputsRequest_ChoiceStyle : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case styleInvalid
  case primary
  case secondary
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.InternalCollectInputsRequest.ChoiceStyleCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.InternalCollectInputsRequest.__ChoiceStyle, result: inout SKC.InternalCollectInputsRequest.ChoiceStyle?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.InternalCollectInputsRequest.__ChoiceStyle, result: inout SKC.InternalCollectInputsRequest.ChoiceStyle?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.InternalCollectInputsRequest.__ChoiceStyle?) -> SKC.__Bridge__InternalCollectInputsRequest_ChoiceStyle
  public func _bridgeToObjectiveC() -> SKC.InternalCollectInputsRequest.__ChoiceStyle
  public typealias _ObjectiveCType = SKC.InternalCollectInputsRequest.__ChoiceStyle
  public static func == (a: SKC.__Bridge__InternalCollectInputsRequest_ChoiceStyle, b: SKC.__Bridge__InternalCollectInputsRequest_ChoiceStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__InternalCollectInputsRequest_ChoiceStyle]
  nonisolated public static var allCases: [SKC.__Bridge__InternalCollectInputsRequest_ChoiceStyle] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalRequestedPaymentMethod {
  public typealias RequestedCardPresentSchemeType = SKC.__Bridge__InternalRequestedPaymentMethod_RequestedCardPresentSchemeType
}
extension SKC.__Bridge__InternalRequestedPaymentMethod_RequestedCardPresentSchemeType {
  public func toKotlinEnum() -> SKC.InternalRequestedPaymentMethod.__RequestedCardPresentSchemeType
}
extension SKC.InternalRequestedPaymentMethod.__RequestedCardPresentSchemeType {
  public func toSwiftEnum() -> SKC.InternalRequestedPaymentMethod.RequestedCardPresentSchemeType
}
@frozen public enum __Bridge__InternalRequestedPaymentMethod_RequestedCardPresentSchemeType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case schemeTypeInvalid
  case dynamicTr31
  case dukpt
  case eckaTtpa
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.InternalRequestedPaymentMethod.RequestedCardPresentSchemeTypeCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.InternalRequestedPaymentMethod.__RequestedCardPresentSchemeType, result: inout SKC.InternalRequestedPaymentMethod.RequestedCardPresentSchemeType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.InternalRequestedPaymentMethod.__RequestedCardPresentSchemeType, result: inout SKC.InternalRequestedPaymentMethod.RequestedCardPresentSchemeType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.InternalRequestedPaymentMethod.__RequestedCardPresentSchemeType?) -> SKC.__Bridge__InternalRequestedPaymentMethod_RequestedCardPresentSchemeType
  public func _bridgeToObjectiveC() -> SKC.InternalRequestedPaymentMethod.__RequestedCardPresentSchemeType
  public typealias _ObjectiveCType = SKC.InternalRequestedPaymentMethod.__RequestedCardPresentSchemeType
  public static func == (a: SKC.__Bridge__InternalRequestedPaymentMethod_RequestedCardPresentSchemeType, b: SKC.__Bridge__InternalRequestedPaymentMethod_RequestedCardPresentSchemeType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__InternalRequestedPaymentMethod_RequestedCardPresentSchemeType]
  nonisolated public static var allCases: [SKC.__Bridge__InternalRequestedPaymentMethod_RequestedCardPresentSchemeType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum InternalCardEntryMethod : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case invalidEntryMethod
  case chipRead
  case contactless
  case fswipe
  case keyed
  case swiped
  case barcodeRead
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__InternalCardEntryMethod.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__InternalCardEntryMethod, result: inout SKC.InternalCardEntryMethod?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__InternalCardEntryMethod, result: inout SKC.InternalCardEntryMethod?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__InternalCardEntryMethod?) -> SKC.InternalCardEntryMethod
  public func _bridgeToObjectiveC() -> SKC.__InternalCardEntryMethod
  public typealias _ObjectiveCType = SKC.__InternalCardEntryMethod
  public typealias Companion = SKC.__InternalCardEntryMethod.Companion
  public static func == (a: SKC.InternalCardEntryMethod, b: SKC.InternalCardEntryMethod) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.InternalCardEntryMethod]
  nonisolated public static var allCases: [SKC.InternalCardEntryMethod] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalCardEntryMethod {
  public func toKotlinEnum() -> SKC.__InternalCardEntryMethod
}
extension SKC.__InternalCardEntryMethod {
  public func toSwiftEnum() -> SKC.InternalCardEntryMethod
}
@frozen public enum InternalCreditCardBrand : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case invalidCreditCardBrand
  case unknownCredit
  case americanExpress
  case diners
  case discover
  case jcb
  case mastercard
  case visa
  case cup
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__InternalCreditCardBrand.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__InternalCreditCardBrand, result: inout SKC.InternalCreditCardBrand?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__InternalCreditCardBrand, result: inout SKC.InternalCreditCardBrand?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__InternalCreditCardBrand?) -> SKC.InternalCreditCardBrand
  public func _bridgeToObjectiveC() -> SKC.__InternalCreditCardBrand
  public typealias _ObjectiveCType = SKC.__InternalCreditCardBrand
  public typealias Companion = SKC.__InternalCreditCardBrand.Companion
  public static func == (a: SKC.InternalCreditCardBrand, b: SKC.InternalCreditCardBrand) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.InternalCreditCardBrand]
  nonisolated public static var allCases: [SKC.InternalCreditCardBrand] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InternalCreditCardBrand {
  public func toKotlinEnum() -> SKC.__InternalCreditCardBrand
}
extension SKC.__InternalCreditCardBrand {
  public func toSwiftEnum() -> SKC.InternalCreditCardBrand
}
@frozen public enum Wire_runtimeFieldEncoding : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case varint
  case fixed64
  case lengthDelimited
  case fixed32
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__Wire_runtimeFieldEncoding.Companion {
    get
  }
  public func rawProtoAdapter() -> SKC.Wire_runtimeProtoAdapter<Swift.AnyObject>
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__Wire_runtimeFieldEncoding, result: inout SKC.Wire_runtimeFieldEncoding?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__Wire_runtimeFieldEncoding, result: inout SKC.Wire_runtimeFieldEncoding?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__Wire_runtimeFieldEncoding?) -> SKC.Wire_runtimeFieldEncoding
  public func _bridgeToObjectiveC() -> SKC.__Wire_runtimeFieldEncoding
  public typealias _ObjectiveCType = SKC.__Wire_runtimeFieldEncoding
  public typealias Companion = SKC.__Wire_runtimeFieldEncoding.Companion
  public static func == (a: SKC.Wire_runtimeFieldEncoding, b: SKC.Wire_runtimeFieldEncoding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.Wire_runtimeFieldEncoding]
  nonisolated public static var allCases: [SKC.Wire_runtimeFieldEncoding] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.Wire_runtimeFieldEncoding {
  public func toKotlinEnum() -> SKC.__Wire_runtimeFieldEncoding
}
extension SKC.__Wire_runtimeFieldEncoding {
  public func toSwiftEnum() -> SKC.Wire_runtimeFieldEncoding
}
@frozen public enum Wire_runtimeSyntax : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case proto2
  case proto3
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__Wire_runtimeSyntax.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__Wire_runtimeSyntax, result: inout SKC.Wire_runtimeSyntax?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__Wire_runtimeSyntax, result: inout SKC.Wire_runtimeSyntax?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__Wire_runtimeSyntax?) -> SKC.Wire_runtimeSyntax
  public func _bridgeToObjectiveC() -> SKC.__Wire_runtimeSyntax
  public typealias _ObjectiveCType = SKC.__Wire_runtimeSyntax
  public typealias Companion = SKC.__Wire_runtimeSyntax.Companion
  public static func == (a: SKC.Wire_runtimeSyntax, b: SKC.Wire_runtimeSyntax) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.Wire_runtimeSyntax]
  nonisolated public static var allCases: [SKC.Wire_runtimeSyntax] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.Wire_runtimeSyntax {
  public func toKotlinEnum() -> SKC.__Wire_runtimeSyntax
}
extension SKC.__Wire_runtimeSyntax {
  public func toSwiftEnum() -> SKC.Wire_runtimeSyntax
}
@frozen public enum CommonApplicationEC : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case applicationEcInvalid
  case ok
  case lockResourcesException
  case invalidLoadId
  case illegalState
  case authenticationFailure
  case invalidSessionToken
  case unauthorized
  case invalidRequest
  case serverError
  case tooManyRequests
  case unimplemented
  case invalidConfig
  case alreadyExists
  case readerInUse
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CommonApplicationEC.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CommonApplicationEC, result: inout SKC.CommonApplicationEC?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CommonApplicationEC, result: inout SKC.CommonApplicationEC?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CommonApplicationEC?) -> SKC.CommonApplicationEC
  public func _bridgeToObjectiveC() -> SKC.__CommonApplicationEC
  public typealias _ObjectiveCType = SKC.__CommonApplicationEC
  public typealias Companion = SKC.__CommonApplicationEC.Companion
  public static func == (a: SKC.CommonApplicationEC, b: SKC.CommonApplicationEC) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CommonApplicationEC]
  nonisolated public static var allCases: [SKC.CommonApplicationEC] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonApplicationEC {
  public func toKotlinEnum() -> SKC.__CommonApplicationEC
}
extension SKC.__CommonApplicationEC {
  public func toSwiftEnum() -> SKC.CommonApplicationEC
}
@frozen public enum CommonRpcEC : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case rpcEcInvalid
  case rpcOk
  case rpcError
  case networkUnavailable
  case serverUnresolvable
  case serverUnreachable
  case badRequest
  case badResponse
  case timeout
  case retry
  case serverBusy
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CommonRpcEC.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CommonRpcEC, result: inout SKC.CommonRpcEC?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CommonRpcEC, result: inout SKC.CommonRpcEC?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CommonRpcEC?) -> SKC.CommonRpcEC
  public func _bridgeToObjectiveC() -> SKC.__CommonRpcEC
  public typealias _ObjectiveCType = SKC.__CommonRpcEC
  public typealias Companion = SKC.__CommonRpcEC.Companion
  public static func == (a: SKC.CommonRpcEC, b: SKC.CommonRpcEC) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CommonRpcEC]
  nonisolated public static var allCases: [SKC.CommonRpcEC] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonRpcEC {
  public func toKotlinEnum() -> SKC.__CommonRpcEC
}
extension SKC.__CommonRpcEC {
  public func toSwiftEnum() -> SKC.CommonRpcEC
}
extension SKC.CommonDeviceInfo {
  public typealias DeviceClass = SKC.__Bridge__CommonDeviceInfo_DeviceClass
}
extension SKC.__Bridge__CommonDeviceInfo_DeviceClass {
  public func toKotlinEnum() -> SKC.CommonDeviceInfo.__DeviceClass
}
extension SKC.CommonDeviceInfo.__DeviceClass {
  public func toSwiftEnum() -> SKC.CommonDeviceInfo.DeviceClass
}
@frozen public enum __Bridge__CommonDeviceInfo_DeviceClass : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case invalid
  case pos
  case reader
  case server
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.CommonDeviceInfo.DeviceClassCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.CommonDeviceInfo.__DeviceClass, result: inout SKC.CommonDeviceInfo.DeviceClass?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.CommonDeviceInfo.__DeviceClass, result: inout SKC.CommonDeviceInfo.DeviceClass?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.CommonDeviceInfo.__DeviceClass?) -> SKC.__Bridge__CommonDeviceInfo_DeviceClass
  public func _bridgeToObjectiveC() -> SKC.CommonDeviceInfo.__DeviceClass
  public typealias _ObjectiveCType = SKC.CommonDeviceInfo.__DeviceClass
  public static func == (a: SKC.__Bridge__CommonDeviceInfo_DeviceClass, b: SKC.__Bridge__CommonDeviceInfo_DeviceClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__CommonDeviceInfo_DeviceClass]
  nonisolated public static var allCases: [SKC.__Bridge__CommonDeviceInfo_DeviceClass] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum CommonVerifoneHardware : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case modelNotSet
  case p400
  case p400Debug
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CommonVerifoneHardware.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CommonVerifoneHardware, result: inout SKC.CommonVerifoneHardware?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CommonVerifoneHardware, result: inout SKC.CommonVerifoneHardware?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CommonVerifoneHardware?) -> SKC.CommonVerifoneHardware
  public func _bridgeToObjectiveC() -> SKC.__CommonVerifoneHardware
  public typealias _ObjectiveCType = SKC.__CommonVerifoneHardware
  public typealias Companion = SKC.__CommonVerifoneHardware.Companion
  public static func == (a: SKC.CommonVerifoneHardware, b: SKC.CommonVerifoneHardware) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CommonVerifoneHardware]
  nonisolated public static var allCases: [SKC.CommonVerifoneHardware] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonVerifoneHardware {
  public func toKotlinEnum() -> SKC.__CommonVerifoneHardware
}
extension SKC.__CommonVerifoneHardware {
  public func toSwiftEnum() -> SKC.CommonVerifoneHardware
}
@frozen public enum CommonSunmiHardware : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case sunmiModelNotSet
  case shopifyWhistler
  case shopifyWhistlerDebug
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CommonSunmiHardware.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CommonSunmiHardware, result: inout SKC.CommonSunmiHardware?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CommonSunmiHardware, result: inout SKC.CommonSunmiHardware?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CommonSunmiHardware?) -> SKC.CommonSunmiHardware
  public func _bridgeToObjectiveC() -> SKC.__CommonSunmiHardware
  public typealias _ObjectiveCType = SKC.__CommonSunmiHardware
  public typealias Companion = SKC.__CommonSunmiHardware.Companion
  public static func == (a: SKC.CommonSunmiHardware, b: SKC.CommonSunmiHardware) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CommonSunmiHardware]
  nonisolated public static var allCases: [SKC.CommonSunmiHardware] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonSunmiHardware {
  public func toKotlinEnum() -> SKC.__CommonSunmiHardware
}
extension SKC.__CommonSunmiHardware {
  public func toSwiftEnum() -> SKC.CommonSunmiHardware
}
@frozen public enum CommonMobileOS : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknownOs
  case ios
  case android
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CommonMobileOS.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CommonMobileOS, result: inout SKC.CommonMobileOS?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CommonMobileOS, result: inout SKC.CommonMobileOS?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CommonMobileOS?) -> SKC.CommonMobileOS
  public func _bridgeToObjectiveC() -> SKC.__CommonMobileOS
  public typealias _ObjectiveCType = SKC.__CommonMobileOS
  public typealias Companion = SKC.__CommonMobileOS.Companion
  public static func == (a: SKC.CommonMobileOS, b: SKC.CommonMobileOS) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CommonMobileOS]
  nonisolated public static var allCases: [SKC.CommonMobileOS] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonMobileOS {
  public func toKotlinEnum() -> SKC.__CommonMobileOS
}
extension SKC.__CommonMobileOS {
  public func toSwiftEnum() -> SKC.CommonMobileOS
}
@frozen public enum CommonBBPosHardware : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case bbposModelNotSet
  case chipper2X
  case wisepad3
  case wisepad3S
  case wiseposplus
  case wiseposE
  case stripem2
  case chipper1X
  case wisecube
  case wiseposEDebug
  case shopifyEtna
  case shopifyEtnaDebug
  case s7
  case s7Debug
  case wiseposEDevkit
  case stripeS700
  case stripeS700Debug
  case stripeS700Devkit
  case stripeS710
  case stripeS710Debug
  case stripeS710Devkit
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CommonBBPosHardware.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CommonBBPosHardware, result: inout SKC.CommonBBPosHardware?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CommonBBPosHardware, result: inout SKC.CommonBBPosHardware?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CommonBBPosHardware?) -> SKC.CommonBBPosHardware
  public func _bridgeToObjectiveC() -> SKC.__CommonBBPosHardware
  public typealias _ObjectiveCType = SKC.__CommonBBPosHardware
  public typealias Companion = SKC.__CommonBBPosHardware.Companion
  public static func == (a: SKC.CommonBBPosHardware, b: SKC.CommonBBPosHardware) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CommonBBPosHardware]
  nonisolated public static var allCases: [SKC.CommonBBPosHardware] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonBBPosHardware {
  public func toKotlinEnum() -> SKC.__CommonBBPosHardware
}
extension SKC.__CommonBBPosHardware {
  public func toSwiftEnum() -> SKC.CommonBBPosHardware
}
@frozen public enum CommonMorphHardware : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case morphModelNotSet
  case vfs0100
  case vfs0200
  case vfm0100
  case vfm0200
  case vfu0100
  case cts0100
  case ctm0100
  case ctu0100
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CommonMorphHardware.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CommonMorphHardware, result: inout SKC.CommonMorphHardware?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CommonMorphHardware, result: inout SKC.CommonMorphHardware?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CommonMorphHardware?) -> SKC.CommonMorphHardware
  public func _bridgeToObjectiveC() -> SKC.__CommonMorphHardware
  public typealias _ObjectiveCType = SKC.__CommonMorphHardware
  public typealias Companion = SKC.__CommonMorphHardware.Companion
  public static func == (a: SKC.CommonMorphHardware, b: SKC.CommonMorphHardware) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CommonMorphHardware]
  nonisolated public static var allCases: [SKC.CommonMorphHardware] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonMorphHardware {
  public func toKotlinEnum() -> SKC.__CommonMorphHardware
}
extension SKC.__CommonMorphHardware {
  public func toSwiftEnum() -> SKC.CommonMorphHardware
}
@frozen public enum CommonInternetConnectionSource : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case ethernet
  case wifi
  case usbIp
  case mobileLte
  case mobile3G
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CommonInternetConnectionSource.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CommonInternetConnectionSource, result: inout SKC.CommonInternetConnectionSource?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CommonInternetConnectionSource, result: inout SKC.CommonInternetConnectionSource?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CommonInternetConnectionSource?) -> SKC.CommonInternetConnectionSource
  public func _bridgeToObjectiveC() -> SKC.__CommonInternetConnectionSource
  public typealias _ObjectiveCType = SKC.__CommonInternetConnectionSource
  public typealias Companion = SKC.__CommonInternetConnectionSource.Companion
  public static func == (a: SKC.CommonInternetConnectionSource, b: SKC.CommonInternetConnectionSource) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CommonInternetConnectionSource]
  nonisolated public static var allCases: [SKC.CommonInternetConnectionSource] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonInternetConnectionSource {
  public func toKotlinEnum() -> SKC.__CommonInternetConnectionSource
}
extension SKC.__CommonInternetConnectionSource {
  public func toSwiftEnum() -> SKC.CommonInternetConnectionSource
}
extension SKC.CommonVersionInfoPb {
  public typealias ClientType = SKC.__Bridge__CommonVersionInfoPb_ClientType
}
extension SKC.__Bridge__CommonVersionInfoPb_ClientType {
  public func toKotlinEnum() -> SKC.CommonVersionInfoPb.__ClientType
}
extension SKC.CommonVersionInfoPb.__ClientType {
  public func toSwiftEnum() -> SKC.CommonVersionInfoPb.ClientType
}
@frozen public enum __Bridge__CommonVersionInfoPb_ClientType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case clientTypeInvalid
  case test
  case iosSdk
  case androidSdk
  case jsSdk
  case indexServer
  case indexTool
  case javaQueueClient
  case raccoon
  case warden
  case stripeCli
  case androidReader
  case androidReaderUpdater
  case bbposFirmware
  case bbposConfiguration
  case bbposKeyProfile
  case androidStandaloneApp
  case androidHandoffApp
  case stripeApi
  case androidApk
  case bbposWpeRom
  case clientTypeNotSet
  case rnIosSdk
  case rnAndroidSdk
  case rnSdk
  case javaSdk
  case oracleOperaMiddleware
  case dotnetSdk
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.CommonVersionInfoPb.ClientTypeCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.CommonVersionInfoPb.__ClientType, result: inout SKC.CommonVersionInfoPb.ClientType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.CommonVersionInfoPb.__ClientType, result: inout SKC.CommonVersionInfoPb.ClientType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.CommonVersionInfoPb.__ClientType?) -> SKC.__Bridge__CommonVersionInfoPb_ClientType
  public func _bridgeToObjectiveC() -> SKC.CommonVersionInfoPb.__ClientType
  public typealias _ObjectiveCType = SKC.CommonVersionInfoPb.__ClientType
  public static func == (a: SKC.__Bridge__CommonVersionInfoPb_ClientType, b: SKC.__Bridge__CommonVersionInfoPb_ClientType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__CommonVersionInfoPb_ClientType]
  nonisolated public static var allCases: [SKC.__Bridge__CommonVersionInfoPb_ClientType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonClientUpgradeArgumentPb {
  public typealias UpgradeTimeArgument = SKC.__Bridge__CommonClientUpgradeArgumentPb_UpgradeTimeArgument
}
extension SKC.__Bridge__CommonClientUpgradeArgumentPb_UpgradeTimeArgument {
  public func toKotlinEnum() -> SKC.CommonClientUpgradeArgumentPb.__UpgradeTimeArgument
}
extension SKC.CommonClientUpgradeArgumentPb.__UpgradeTimeArgument {
  public func toSwiftEnum() -> SKC.CommonClientUpgradeArgumentPb.UpgradeTimeArgument
}
@frozen public enum __Bridge__CommonClientUpgradeArgumentPb_UpgradeTimeArgument : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case forceImmediate
  case onSignOff
  case midnight
  case custom
  case doNotUpgrade
  case onBoot
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.CommonClientUpgradeArgumentPb.UpgradeTimeArgumentCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.CommonClientUpgradeArgumentPb.__UpgradeTimeArgument, result: inout SKC.CommonClientUpgradeArgumentPb.UpgradeTimeArgument?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.CommonClientUpgradeArgumentPb.__UpgradeTimeArgument, result: inout SKC.CommonClientUpgradeArgumentPb.UpgradeTimeArgument?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.CommonClientUpgradeArgumentPb.__UpgradeTimeArgument?) -> SKC.__Bridge__CommonClientUpgradeArgumentPb_UpgradeTimeArgument
  public func _bridgeToObjectiveC() -> SKC.CommonClientUpgradeArgumentPb.__UpgradeTimeArgument
  public typealias _ObjectiveCType = SKC.CommonClientUpgradeArgumentPb.__UpgradeTimeArgument
  public static func == (a: SKC.__Bridge__CommonClientUpgradeArgumentPb_UpgradeTimeArgument, b: SKC.__Bridge__CommonClientUpgradeArgumentPb_UpgradeTimeArgument) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__CommonClientUpgradeArgumentPb_UpgradeTimeArgument]
  nonisolated public static var allCases: [SKC.__Bridge__CommonClientUpgradeArgumentPb_UpgradeTimeArgument] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonClientVersionSpecPb {
  public typealias InstallType = SKC.__Bridge__CommonClientVersionSpecPb_InstallType
}
extension SKC.__Bridge__CommonClientVersionSpecPb_InstallType {
  public func toKotlinEnum() -> SKC.CommonClientVersionSpecPb.__InstallType
}
extension SKC.CommonClientVersionSpecPb.__InstallType {
  public func toSwiftEnum() -> SKC.CommonClientVersionSpecPb.InstallType
}
@frozen public enum __Bridge__CommonClientVersionSpecPb_InstallType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case incremental
  case clean
  case uninstall
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.CommonClientVersionSpecPb.InstallTypeCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.CommonClientVersionSpecPb.__InstallType, result: inout SKC.CommonClientVersionSpecPb.InstallType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.CommonClientVersionSpecPb.__InstallType, result: inout SKC.CommonClientVersionSpecPb.InstallType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.CommonClientVersionSpecPb.__InstallType?) -> SKC.__Bridge__CommonClientVersionSpecPb_InstallType
  public func _bridgeToObjectiveC() -> SKC.CommonClientVersionSpecPb.__InstallType
  public typealias _ObjectiveCType = SKC.CommonClientVersionSpecPb.__InstallType
  public static func == (a: SKC.__Bridge__CommonClientVersionSpecPb_InstallType, b: SKC.__Bridge__CommonClientVersionSpecPb_InstallType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__CommonClientVersionSpecPb_InstallType]
  nonisolated public static var allCases: [SKC.__Bridge__CommonClientVersionSpecPb_InstallType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonSemanticVersionedAssetMetadata {
  public typealias BuildVariantType = SKC.__Bridge__CommonSemanticVersionedAssetMetadata_BuildVariantType
}
extension SKC.__Bridge__CommonSemanticVersionedAssetMetadata_BuildVariantType {
  public func toKotlinEnum() -> SKC.CommonSemanticVersionedAssetMetadata.__BuildVariantType
}
extension SKC.CommonSemanticVersionedAssetMetadata.__BuildVariantType {
  public func toSwiftEnum() -> SKC.CommonSemanticVersionedAssetMetadata.BuildVariantType
}
@frozen public enum __Bridge__CommonSemanticVersionedAssetMetadata_BuildVariantType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case buildVariantTypeInvalid
  case user
  case userdebug
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.CommonSemanticVersionedAssetMetadata.BuildVariantTypeCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.CommonSemanticVersionedAssetMetadata.__BuildVariantType, result: inout SKC.CommonSemanticVersionedAssetMetadata.BuildVariantType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.CommonSemanticVersionedAssetMetadata.__BuildVariantType, result: inout SKC.CommonSemanticVersionedAssetMetadata.BuildVariantType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.CommonSemanticVersionedAssetMetadata.__BuildVariantType?) -> SKC.__Bridge__CommonSemanticVersionedAssetMetadata_BuildVariantType
  public func _bridgeToObjectiveC() -> SKC.CommonSemanticVersionedAssetMetadata.__BuildVariantType
  public typealias _ObjectiveCType = SKC.CommonSemanticVersionedAssetMetadata.__BuildVariantType
  public static func == (a: SKC.__Bridge__CommonSemanticVersionedAssetMetadata_BuildVariantType, b: SKC.__Bridge__CommonSemanticVersionedAssetMetadata_BuildVariantType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__CommonSemanticVersionedAssetMetadata_BuildVariantType]
  nonisolated public static var allCases: [SKC.__Bridge__CommonSemanticVersionedAssetMetadata_BuildVariantType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonBbposKeyProfileMetadata {
  public typealias KeyProfileP2PEType = SKC.__Bridge__CommonBbposKeyProfileMetadata_KeyProfileP2PEType
}
extension SKC.__Bridge__CommonBbposKeyProfileMetadata_KeyProfileP2PEType {
  public func toKotlinEnum() -> SKC.CommonBbposKeyProfileMetadata.__KeyProfileP2PEType
}
extension SKC.CommonBbposKeyProfileMetadata.__KeyProfileP2PEType {
  public func toSwiftEnum() -> SKC.CommonBbposKeyProfileMetadata.KeyProfileP2PEType
}
@frozen public enum __Bridge__CommonBbposKeyProfileMetadata_KeyProfileP2PEType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case keyProfileP2PeTypeInvalid
  case notP2PeCapable
  case p2PeCapableMerchantDisabled
  case p2PeCapableMerchantEnabled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.CommonBbposKeyProfileMetadata.KeyProfileP2PETypeCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.CommonBbposKeyProfileMetadata.__KeyProfileP2PEType, result: inout SKC.CommonBbposKeyProfileMetadata.KeyProfileP2PEType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.CommonBbposKeyProfileMetadata.__KeyProfileP2PEType, result: inout SKC.CommonBbposKeyProfileMetadata.KeyProfileP2PEType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.CommonBbposKeyProfileMetadata.__KeyProfileP2PEType?) -> SKC.__Bridge__CommonBbposKeyProfileMetadata_KeyProfileP2PEType
  public func _bridgeToObjectiveC() -> SKC.CommonBbposKeyProfileMetadata.__KeyProfileP2PEType
  public typealias _ObjectiveCType = SKC.CommonBbposKeyProfileMetadata.__KeyProfileP2PEType
  public static func == (a: SKC.__Bridge__CommonBbposKeyProfileMetadata_KeyProfileP2PEType, b: SKC.__Bridge__CommonBbposKeyProfileMetadata_KeyProfileP2PEType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__CommonBbposKeyProfileMetadata_KeyProfileP2PEType]
  nonisolated public static var allCases: [SKC.__Bridge__CommonBbposKeyProfileMetadata_KeyProfileP2PEType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CommonDeviceAssetInfo {
  public typealias AssetType = SKC.__Bridge__CommonDeviceAssetInfo_AssetType
}
extension SKC.__Bridge__CommonDeviceAssetInfo_AssetType {
  public func toKotlinEnum() -> SKC.CommonDeviceAssetInfo.__AssetType
}
extension SKC.CommonDeviceAssetInfo.__AssetType {
  public func toSwiftEnum() -> SKC.CommonDeviceAssetInfo.AssetType
}
@frozen public enum __Bridge__CommonDeviceAssetInfo_AssetType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case assetTypeInvalid
  case p400Raccoon
  case p400Warden
  case raccoonUxBundle
  case raccoonLocalizationBundle
  case emvConfig
  case wiseposReader
  case wiseposUpdater
  case bbposFirmware
  case bbposConfig
  case bbposKeyProfile
  case androidApk
  case androidRom
  case factoryImage
  case internalAndroidApk
  case uberLanguagePack
  case languagePack
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.CommonDeviceAssetInfo.AssetTypeCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.CommonDeviceAssetInfo.__AssetType, result: inout SKC.CommonDeviceAssetInfo.AssetType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.CommonDeviceAssetInfo.__AssetType, result: inout SKC.CommonDeviceAssetInfo.AssetType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.CommonDeviceAssetInfo.__AssetType?) -> SKC.__Bridge__CommonDeviceAssetInfo_AssetType
  public func _bridgeToObjectiveC() -> SKC.CommonDeviceAssetInfo.__AssetType
  public typealias _ObjectiveCType = SKC.CommonDeviceAssetInfo.__AssetType
  public static func == (a: SKC.__Bridge__CommonDeviceAssetInfo_AssetType, b: SKC.__Bridge__CommonDeviceAssetInfo_AssetType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__CommonDeviceAssetInfo_AssetType]
  nonisolated public static var allCases: [SKC.__Bridge__CommonDeviceAssetInfo_AssetType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum SKCKmpToggleValue : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case enabled
  case disabled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SKCKmpToggleValue, result: inout SKC.SKCKmpToggleValue?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SKCKmpToggleValue, result: inout SKC.SKCKmpToggleValue?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SKCKmpToggleValue?) -> SKC.SKCKmpToggleValue
  public func _bridgeToObjectiveC() -> SKC.__SKCKmpToggleValue
  public typealias _ObjectiveCType = SKC.__SKCKmpToggleValue
  public static func == (a: SKC.SKCKmpToggleValue, b: SKC.SKCKmpToggleValue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SKCKmpToggleValue]
  nonisolated public static var allCases: [SKC.SKCKmpToggleValue] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SKCKmpToggleValue {
  public func toKotlinEnum() -> SKC.__SKCKmpToggleValue
}
extension SKC.__SKCKmpToggleValue {
  public func toSwiftEnum() -> SKC.SKCKmpToggleValue
}
@frozen public enum SKCKmpSelectionButtonStyle : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case primary
  case secondary
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SKCKmpSelectionButtonStyle, result: inout SKC.SKCKmpSelectionButtonStyle?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SKCKmpSelectionButtonStyle, result: inout SKC.SKCKmpSelectionButtonStyle?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SKCKmpSelectionButtonStyle?) -> SKC.SKCKmpSelectionButtonStyle
  public func _bridgeToObjectiveC() -> SKC.__SKCKmpSelectionButtonStyle
  public typealias _ObjectiveCType = SKC.__SKCKmpSelectionButtonStyle
  public static func == (a: SKC.SKCKmpSelectionButtonStyle, b: SKC.SKCKmpSelectionButtonStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SKCKmpSelectionButtonStyle]
  nonisolated public static var allCases: [SKC.SKCKmpSelectionButtonStyle] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SKCKmpSelectionButtonStyle {
  public func toKotlinEnum() -> SKC.__SKCKmpSelectionButtonStyle
}
extension SKC.__SKCKmpSelectionButtonStyle {
  public func toSwiftEnum() -> SKC.SKCKmpSelectionButtonStyle
}
@frozen public enum SKCKmpFormType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case signature
  case selection
  case phone
  case email
  case text
  case numeric
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SKCKmpFormType, result: inout SKC.SKCKmpFormType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SKCKmpFormType, result: inout SKC.SKCKmpFormType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SKCKmpFormType?) -> SKC.SKCKmpFormType
  public func _bridgeToObjectiveC() -> SKC.__SKCKmpFormType
  public typealias _ObjectiveCType = SKC.__SKCKmpFormType
  public static func == (a: SKC.SKCKmpFormType, b: SKC.SKCKmpFormType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SKCKmpFormType]
  nonisolated public static var allCases: [SKC.SKCKmpFormType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SKCKmpFormType {
  public func toKotlinEnum() -> SKC.__SKCKmpFormType
}
extension SKC.__SKCKmpFormType {
  public func toSwiftEnum() -> SKC.SKCKmpFormType
}
@frozen public enum SKCKmpToggleResult : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case enabled
  case disabled
  case skipped
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SKCKmpToggleResult, result: inout SKC.SKCKmpToggleResult?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SKCKmpToggleResult, result: inout SKC.SKCKmpToggleResult?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SKCKmpToggleResult?) -> SKC.SKCKmpToggleResult
  public func _bridgeToObjectiveC() -> SKC.__SKCKmpToggleResult
  public typealias _ObjectiveCType = SKC.__SKCKmpToggleResult
  public static func == (a: SKC.SKCKmpToggleResult, b: SKC.SKCKmpToggleResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SKCKmpToggleResult]
  nonisolated public static var allCases: [SKC.SKCKmpToggleResult] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SKCKmpToggleResult {
  public func toKotlinEnum() -> SKC.__SKCKmpToggleResult
}
extension SKC.__SKCKmpToggleResult {
  public func toSwiftEnum() -> SKC.SKCKmpToggleResult
}
@frozen public enum Ktor_utilsMonth : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case january
  case february
  case march
  case april
  case may
  case june
  case july
  case august
  case september
  case october
  case november
  case december
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.String {
    get
  }
  public static var companion: SKC.__Ktor_utilsMonth.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__Ktor_utilsMonth, result: inout SKC.Ktor_utilsMonth?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__Ktor_utilsMonth, result: inout SKC.Ktor_utilsMonth?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__Ktor_utilsMonth?) -> SKC.Ktor_utilsMonth
  public func _bridgeToObjectiveC() -> SKC.__Ktor_utilsMonth
  public typealias _ObjectiveCType = SKC.__Ktor_utilsMonth
  public typealias Companion = SKC.__Ktor_utilsMonth.Companion
  public static func == (a: SKC.Ktor_utilsMonth, b: SKC.Ktor_utilsMonth) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.Ktor_utilsMonth]
  nonisolated public static var allCases: [SKC.Ktor_utilsMonth] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.Ktor_utilsMonth {
  public func toKotlinEnum() -> SKC.__Ktor_utilsMonth
}
extension SKC.__Ktor_utilsMonth {
  public func toSwiftEnum() -> SKC.Ktor_utilsMonth
}
@frozen public enum Ktor_utilsWeekDay : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case monday
  case tuesday
  case wednesday
  case thursday
  case friday
  case saturday
  case sunday
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.String {
    get
  }
  public static var companion: SKC.__Ktor_utilsWeekDay.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__Ktor_utilsWeekDay, result: inout SKC.Ktor_utilsWeekDay?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__Ktor_utilsWeekDay, result: inout SKC.Ktor_utilsWeekDay?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__Ktor_utilsWeekDay?) -> SKC.Ktor_utilsWeekDay
  public func _bridgeToObjectiveC() -> SKC.__Ktor_utilsWeekDay
  public typealias _ObjectiveCType = SKC.__Ktor_utilsWeekDay
  public typealias Companion = SKC.__Ktor_utilsWeekDay.Companion
  public static func == (a: SKC.Ktor_utilsWeekDay, b: SKC.Ktor_utilsWeekDay) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.Ktor_utilsWeekDay]
  nonisolated public static var allCases: [SKC.Ktor_utilsWeekDay] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.Ktor_utilsWeekDay {
  public func toKotlinEnum() -> SKC.__Ktor_utilsWeekDay
}
extension SKC.__Ktor_utilsWeekDay {
  public func toSwiftEnum() -> SKC.Ktor_utilsWeekDay
}
@frozen public enum SKCTerminalErrorCode : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case cancelFailed
  case notConnectedToReader
  case alreadyConnectedToReader
  case confirmInvalidPaymentIntent
  case confirmInvalidSetupIntent
  case invalidClientSecret
  case unsupportedOperation
  case unexpectedOperation
  case unsupportedSdk
  case missingRequiredParameter
  case invalidRequiredParameter
  case invalidTipParameter
  case canceled
  case locationServicesDisabled
  case cardInsertNotRead
  case cardSwipeNotRead
  case cardReadTimedOut
  case cardRemoved
  case customerConsentRequired
  case cardLeftInReader
  case readerBusy
  case readerCommunicationError
  case unsupportedReaderVersion
  case genericReaderError
  case unexpectedSdkError
  case declinedByStripeApi
  case declinedByReader
  case requestTimedOut
  case stripeApiConnectionError
  case stripeApiError
  case stripeApiResponseDecodingError
  case connectionTokenProviderError
  case sessionExpired
  case amountExceedsMaxOfflineAmount
  case offlinePaymentsDatabaseTooLarge
  case readerConnectionNotAvailableOffline
  case locationConnectionNotAvailableOffline
  case noLastSeenAccount
  case invalidOfflineCurrency
  case featureNotEnabledOnAccount
  case cardSwipeNotAvailable
  case interacNotSupportedOffline
  case onlinePinNotSupportedOffline
  case mobileWalletNotSupportedOnSetupIntents
  case offlineAndCardExpired
  case offlineTransactionDeclined
  case offlineCollectAndConfirmMismatch
  case offlineTestmodePaymentInLivemode
  case offlineLivemodePaymentInTestmode
  case offlinePaymentIntentNotFound
  case missingEmvData
  case connectionTokenProviderErrorWhileForwarding
  case accountIdMismatchWhileForwarding
  case forceOfflineWithFeatureDisabled
  case testCardInLivemode
  case notConnectedToInternetAndRequireOnlineSet
  case collectInputsApplicationError
  case collectInputsTimedOut
  case collectInputsInvalidParameter
  case collectInputsUnsupported
  case readerSettingsError
  case readerMissingEncryptionKeys
  case invalidSurchargeParameter
  case readerCommunicationSslError
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__SKCTerminalErrorCode.Companion {
    get
  }
  public func toLogString() -> Swift.String
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SKCTerminalErrorCode, result: inout SKC.SKCTerminalErrorCode?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SKCTerminalErrorCode, result: inout SKC.SKCTerminalErrorCode?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SKCTerminalErrorCode?) -> SKC.SKCTerminalErrorCode
  public func _bridgeToObjectiveC() -> SKC.__SKCTerminalErrorCode
  public typealias _ObjectiveCType = SKC.__SKCTerminalErrorCode
  public typealias Companion = SKC.__SKCTerminalErrorCode.Companion
  public static func == (a: SKC.SKCTerminalErrorCode, b: SKC.SKCTerminalErrorCode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SKCTerminalErrorCode]
  nonisolated public static var allCases: [SKC.SKCTerminalErrorCode] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SKCTerminalErrorCode {
  public func toKotlinEnum() -> SKC.__SKCTerminalErrorCode
}
extension SKC.__SKCTerminalErrorCode {
  public func toSwiftEnum() -> SKC.SKCTerminalErrorCode
}
@frozen public enum PaymentMethodType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case cardPresent
  case card
  case interacPresent
  case wechatPay
  case affirm
  public var isNonCardPaymentMethod: Swift.Bool {
    get
  }
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var typeName: Swift.String {
    get
  }
  public static var companion: SKC.__PaymentMethodType.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PaymentMethodType, result: inout SKC.PaymentMethodType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentMethodType, result: inout SKC.PaymentMethodType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentMethodType?) -> SKC.PaymentMethodType
  public func _bridgeToObjectiveC() -> SKC.__PaymentMethodType
  public typealias _ObjectiveCType = SKC.__PaymentMethodType
  public typealias Companion = SKC.__PaymentMethodType.Companion
  public static func == (a: SKC.PaymentMethodType, b: SKC.PaymentMethodType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PaymentMethodType]
  nonisolated public static var allCases: [SKC.PaymentMethodType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PaymentMethodType {
  public func toKotlinEnum() -> SKC.__PaymentMethodType
}
extension SKC.__PaymentMethodType {
  public func toSwiftEnum() -> SKC.PaymentMethodType
}
@frozen public enum DeviceType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case chipper1X
  case chipper2X
  case stripeM2
  case tapToPayDevice
  case verifoneP400
  case wisecube
  case wisepad3
  case wisepad3S
  case wiseposE
  case wiseposEDevkit
  case etna
  case stripeS700
  case stripeS700Devkit
  case stripeS710
  case stripeS710Devkit
  case unknown
  public var deviceName: Swift.String {
    get
  }
  public var hardwareModel: SKC.CommonHardwareModel {
    get
  }
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var serialPrefixes: [Swift.String] {
    get
  }
  public var simulatedHardware: SKC.CommonSimulatedHardware {
    get
  }
  public static var companion: SKC.__DeviceType.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__DeviceType, result: inout SKC.DeviceType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__DeviceType, result: inout SKC.DeviceType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__DeviceType?) -> SKC.DeviceType
  public func _bridgeToObjectiveC() -> SKC.__DeviceType
  public typealias _ObjectiveCType = SKC.__DeviceType
  public typealias Companion = SKC.__DeviceType.Companion
  public static func == (a: SKC.DeviceType, b: SKC.DeviceType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.DeviceType]
  nonisolated public static var allCases: [SKC.DeviceType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.DeviceType {
  public func toKotlinEnum() -> SKC.__DeviceType
}
extension SKC.__DeviceType {
  public func toSwiftEnum() -> SKC.DeviceType
}
@frozen public enum AllowRedisplay : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case always
  case limited
  case unspecified
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.String {
    get
  }
  public static var companion: SKC.__AllowRedisplay.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__AllowRedisplay, result: inout SKC.AllowRedisplay?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__AllowRedisplay, result: inout SKC.AllowRedisplay?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__AllowRedisplay?) -> SKC.AllowRedisplay
  public func _bridgeToObjectiveC() -> SKC.__AllowRedisplay
  public typealias _ObjectiveCType = SKC.__AllowRedisplay
  public typealias Companion = SKC.__AllowRedisplay.Companion
  public static func == (a: SKC.AllowRedisplay, b: SKC.AllowRedisplay) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.AllowRedisplay]
  nonisolated public static var allCases: [SKC.AllowRedisplay] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.AllowRedisplay {
  public func toKotlinEnum() -> SKC.__AllowRedisplay
}
extension SKC.__AllowRedisplay {
  public func toSwiftEnum() -> SKC.AllowRedisplay
}
@frozen public enum OfflineBehavior : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case requireOnline
  case preferOnline
  case forceOffline
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__OfflineBehavior, result: inout SKC.OfflineBehavior?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__OfflineBehavior, result: inout SKC.OfflineBehavior?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__OfflineBehavior?) -> SKC.OfflineBehavior
  public func _bridgeToObjectiveC() -> SKC.__OfflineBehavior
  public typealias _ObjectiveCType = SKC.__OfflineBehavior
  public static func == (a: SKC.OfflineBehavior, b: SKC.OfflineBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.OfflineBehavior]
  nonisolated public static var allCases: [SKC.OfflineBehavior] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.OfflineBehavior {
  public func toKotlinEnum() -> SKC.__OfflineBehavior
}
extension SKC.__OfflineBehavior {
  public func toSwiftEnum() -> SKC.OfflineBehavior
}
@frozen public enum CardPresentRequestPartialAuthorization : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case ifAvailable
  case never
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var typeName: Swift.String {
    get
  }
  public static var companion: SKC.__CardPresentRequestPartialAuthorization.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CardPresentRequestPartialAuthorization, result: inout SKC.CardPresentRequestPartialAuthorization?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CardPresentRequestPartialAuthorization, result: inout SKC.CardPresentRequestPartialAuthorization?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CardPresentRequestPartialAuthorization?) -> SKC.CardPresentRequestPartialAuthorization
  public func _bridgeToObjectiveC() -> SKC.__CardPresentRequestPartialAuthorization
  public typealias _ObjectiveCType = SKC.__CardPresentRequestPartialAuthorization
  public typealias Companion = SKC.__CardPresentRequestPartialAuthorization.Companion
  public static func == (a: SKC.CardPresentRequestPartialAuthorization, b: SKC.CardPresentRequestPartialAuthorization) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CardPresentRequestPartialAuthorization]
  nonisolated public static var allCases: [SKC.CardPresentRequestPartialAuthorization] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CardPresentRequestPartialAuthorization {
  public func toKotlinEnum() -> SKC.__CardPresentRequestPartialAuthorization
}
extension SKC.__CardPresentRequestPartialAuthorization {
  public func toSwiftEnum() -> SKC.CardPresentRequestPartialAuthorization
}
@frozen public enum RoutingPriority : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case domestic
  case international
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__RoutingPriority.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__RoutingPriority, result: inout SKC.RoutingPriority?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__RoutingPriority, result: inout SKC.RoutingPriority?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__RoutingPriority?) -> SKC.RoutingPriority
  public func _bridgeToObjectiveC() -> SKC.__RoutingPriority
  public typealias _ObjectiveCType = SKC.__RoutingPriority
  public typealias Companion = SKC.__RoutingPriority.Companion
  public static func == (a: SKC.RoutingPriority, b: SKC.RoutingPriority) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.RoutingPriority]
  nonisolated public static var allCases: [SKC.RoutingPriority] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.RoutingPriority {
  public func toKotlinEnum() -> SKC.__RoutingPriority
}
extension SKC.__RoutingPriority {
  public func toSwiftEnum() -> SKC.RoutingPriority
}
@frozen public enum Request3dSecureType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case automatic
  case any
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__Request3dSecureType.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__Request3dSecureType, result: inout SKC.Request3dSecureType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__Request3dSecureType, result: inout SKC.Request3dSecureType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__Request3dSecureType?) -> SKC.Request3dSecureType
  public func _bridgeToObjectiveC() -> SKC.__Request3dSecureType
  public typealias _ObjectiveCType = SKC.__Request3dSecureType
  public typealias Companion = SKC.__Request3dSecureType.Companion
  public static func == (a: SKC.Request3dSecureType, b: SKC.Request3dSecureType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.Request3dSecureType]
  nonisolated public static var allCases: [SKC.Request3dSecureType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.Request3dSecureType {
  public func toKotlinEnum() -> SKC.__Request3dSecureType
}
extension SKC.__Request3dSecureType {
  public func toSwiftEnum() -> SKC.Request3dSecureType
}
@frozen public enum SetupIntentCancellationReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case duplicate
  case requestedByCustomer
  case abandoned
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__SetupIntentCancellationReason.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SetupIntentCancellationReason, result: inout SKC.SetupIntentCancellationReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SetupIntentCancellationReason, result: inout SKC.SetupIntentCancellationReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SetupIntentCancellationReason?) -> SKC.SetupIntentCancellationReason
  public func _bridgeToObjectiveC() -> SKC.__SetupIntentCancellationReason
  public typealias _ObjectiveCType = SKC.__SetupIntentCancellationReason
  public typealias Companion = SKC.__SetupIntentCancellationReason.Companion
  public static func == (a: SKC.SetupIntentCancellationReason, b: SKC.SetupIntentCancellationReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SetupIntentCancellationReason]
  nonisolated public static var allCases: [SKC.SetupIntentCancellationReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SetupIntentCancellationReason {
  public func toKotlinEnum() -> SKC.__SetupIntentCancellationReason
}
extension SKC.__SetupIntentCancellationReason {
  public func toSwiftEnum() -> SKC.SetupIntentCancellationReason
}
@frozen public enum SetupIntentUsage : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case onSession
  case offSession
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__SetupIntentUsage.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SetupIntentUsage, result: inout SKC.SetupIntentUsage?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SetupIntentUsage, result: inout SKC.SetupIntentUsage?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SetupIntentUsage?) -> SKC.SetupIntentUsage
  public func _bridgeToObjectiveC() -> SKC.__SetupIntentUsage
  public typealias _ObjectiveCType = SKC.__SetupIntentUsage
  public typealias Companion = SKC.__SetupIntentUsage.Companion
  public static func == (a: SKC.SetupIntentUsage, b: SKC.SetupIntentUsage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SetupIntentUsage]
  nonisolated public static var allCases: [SKC.SetupIntentUsage] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SetupIntentUsage {
  public func toKotlinEnum() -> SKC.__SetupIntentUsage
}
extension SKC.__SetupIntentUsage {
  public func toSwiftEnum() -> SKC.SetupIntentUsage
}
@frozen public enum SetupIntentStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case requiresPaymentMethod
  case requiresConfirmation
  case requiresAction
  case processing
  case succeeded
  case cancelled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__SetupIntentStatus.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SetupIntentStatus, result: inout SKC.SetupIntentStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SetupIntentStatus, result: inout SKC.SetupIntentStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SetupIntentStatus?) -> SKC.SetupIntentStatus
  public func _bridgeToObjectiveC() -> SKC.__SetupIntentStatus
  public typealias _ObjectiveCType = SKC.__SetupIntentStatus
  public typealias Companion = SKC.__SetupIntentStatus.Companion
  public static func == (a: SKC.SetupIntentStatus, b: SKC.SetupIntentStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SetupIntentStatus]
  nonisolated public static var allCases: [SKC.SetupIntentStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SetupIntentStatus {
  public func toKotlinEnum() -> SKC.__SetupIntentStatus
}
extension SKC.__SetupIntentStatus {
  public func toSwiftEnum() -> SKC.SetupIntentStatus
}
@frozen public enum ApiErrorType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case apiConnectionError
  case apiError
  case authenticationError
  case cardError
  case idempotencyError
  case invalidRequestError
  case rateLimitError
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__ApiErrorType.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ApiErrorType, result: inout SKC.ApiErrorType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ApiErrorType, result: inout SKC.ApiErrorType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ApiErrorType?) -> SKC.ApiErrorType
  public func _bridgeToObjectiveC() -> SKC.__ApiErrorType
  public typealias _ObjectiveCType = SKC.__ApiErrorType
  public typealias Companion = SKC.__ApiErrorType.Companion
  public static func == (a: SKC.ApiErrorType, b: SKC.ApiErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ApiErrorType]
  nonisolated public static var allCases: [SKC.ApiErrorType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ApiErrorType {
  public func toKotlinEnum() -> SKC.__ApiErrorType
}
extension SKC.__ApiErrorType {
  public func toSwiftEnum() -> SKC.ApiErrorType
}
@frozen public enum IncrementalAuthorizationStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case notSupported
  case supported
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__IncrementalAuthorizationStatus, result: inout SKC.IncrementalAuthorizationStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__IncrementalAuthorizationStatus, result: inout SKC.IncrementalAuthorizationStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__IncrementalAuthorizationStatus?) -> SKC.IncrementalAuthorizationStatus
  public func _bridgeToObjectiveC() -> SKC.__IncrementalAuthorizationStatus
  public typealias _ObjectiveCType = SKC.__IncrementalAuthorizationStatus
  public static func == (a: SKC.IncrementalAuthorizationStatus, b: SKC.IncrementalAuthorizationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.IncrementalAuthorizationStatus]
  nonisolated public static var allCases: [SKC.IncrementalAuthorizationStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.IncrementalAuthorizationStatus {
  public func toKotlinEnum() -> SKC.__IncrementalAuthorizationStatus
}
extension SKC.__IncrementalAuthorizationStatus {
  public func toSwiftEnum() -> SKC.IncrementalAuthorizationStatus
}
@frozen public enum PaymentIntentStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case canceled
  case processing
  case requiresCapture
  case requiresConfirmation
  case requiresPaymentMethod
  case requiresAction
  case succeeded
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__PaymentIntentStatus.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PaymentIntentStatus, result: inout SKC.PaymentIntentStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentIntentStatus, result: inout SKC.PaymentIntentStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentIntentStatus?) -> SKC.PaymentIntentStatus
  public func _bridgeToObjectiveC() -> SKC.__PaymentIntentStatus
  public typealias _ObjectiveCType = SKC.__PaymentIntentStatus
  public typealias Companion = SKC.__PaymentIntentStatus.Companion
  public static func == (a: SKC.PaymentIntentStatus, b: SKC.PaymentIntentStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PaymentIntentStatus]
  nonisolated public static var allCases: [SKC.PaymentIntentStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PaymentIntentStatus {
  public func toKotlinEnum() -> SKC.__PaymentIntentStatus
}
extension SKC.__PaymentIntentStatus {
  public func toSwiftEnum() -> SKC.PaymentIntentStatus
}
@frozen public enum SetupAttemptStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case requiresConfirmation
  case requiresAction
  case processing
  case succeeded
  case failed
  case abandoned
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__SetupAttemptStatus.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SetupAttemptStatus, result: inout SKC.SetupAttemptStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SetupAttemptStatus, result: inout SKC.SetupAttemptStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SetupAttemptStatus?) -> SKC.SetupAttemptStatus
  public func _bridgeToObjectiveC() -> SKC.__SetupAttemptStatus
  public typealias _ObjectiveCType = SKC.__SetupAttemptStatus
  public typealias Companion = SKC.__SetupAttemptStatus.Companion
  public static func == (a: SKC.SetupAttemptStatus, b: SKC.SetupAttemptStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SetupAttemptStatus]
  nonisolated public static var allCases: [SKC.SetupAttemptStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SetupAttemptStatus {
  public func toKotlinEnum() -> SKC.__SetupAttemptStatus
}
extension SKC.__SetupAttemptStatus {
  public func toSwiftEnum() -> SKC.SetupAttemptStatus
}
@frozen public enum SetupErrorType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case apiConnectionError
  case apiError
  case authenticationError
  case cardError
  case idempotencyError
  case invalidRequestError
  case rateLimitError
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SetupErrorType, result: inout SKC.SetupErrorType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SetupErrorType, result: inout SKC.SetupErrorType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SetupErrorType?) -> SKC.SetupErrorType
  public func _bridgeToObjectiveC() -> SKC.__SetupErrorType
  public typealias _ObjectiveCType = SKC.__SetupErrorType
  public static func == (a: SKC.SetupErrorType, b: SKC.SetupErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SetupErrorType]
  nonisolated public static var allCases: [SKC.SetupErrorType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SetupErrorType {
  public func toKotlinEnum() -> SKC.__SetupErrorType
}
extension SKC.__SetupErrorType {
  public func toSwiftEnum() -> SKC.SetupErrorType
}
extension SKC.Reader {
  public typealias NetworkStatus = SKC.__Bridge__Reader_NetworkStatus
}
extension SKC.__Bridge__Reader_NetworkStatus {
  public func toKotlinEnum() -> SKC.Reader.__NetworkStatus
}
extension SKC.Reader.__NetworkStatus {
  public func toSwiftEnum() -> SKC.Reader.NetworkStatus
}
@frozen public enum __Bridge__Reader_NetworkStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case online
  case offline
  case unknown
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var status: Swift.String {
    get
  }
  public static var companion: SKC.Reader.NetworkStatusCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.Reader.__NetworkStatus, result: inout SKC.Reader.NetworkStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.Reader.__NetworkStatus, result: inout SKC.Reader.NetworkStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.Reader.__NetworkStatus?) -> SKC.__Bridge__Reader_NetworkStatus
  public func _bridgeToObjectiveC() -> SKC.Reader.__NetworkStatus
  public typealias _ObjectiveCType = SKC.Reader.__NetworkStatus
  public static func == (a: SKC.__Bridge__Reader_NetworkStatus, b: SKC.__Bridge__Reader_NetworkStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__Reader_NetworkStatus]
  nonisolated public static var allCases: [SKC.__Bridge__Reader_NetworkStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderSoftwareUpdate {
  public typealias UpdateDurationEstimate = SKC.__Bridge__ReaderSoftwareUpdate_UpdateDurationEstimate
}
extension SKC.__Bridge__ReaderSoftwareUpdate_UpdateDurationEstimate {
  public func toKotlinEnum() -> SKC.ReaderSoftwareUpdate.__UpdateDurationEstimate
}
extension SKC.ReaderSoftwareUpdate.__UpdateDurationEstimate {
  public func toSwiftEnum() -> SKC.ReaderSoftwareUpdate.UpdateDurationEstimate
}
@frozen public enum __Bridge__ReaderSoftwareUpdate_UpdateDurationEstimate : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case lessThanOneMinute
  case oneToTwoMinutes
  case twoToFiveMinutes
  case fiveToFifteenMinutes
  public var description_: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ReaderSoftwareUpdate.__UpdateDurationEstimate, result: inout SKC.ReaderSoftwareUpdate.UpdateDurationEstimate?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ReaderSoftwareUpdate.__UpdateDurationEstimate, result: inout SKC.ReaderSoftwareUpdate.UpdateDurationEstimate?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ReaderSoftwareUpdate.__UpdateDurationEstimate?) -> SKC.__Bridge__ReaderSoftwareUpdate_UpdateDurationEstimate
  public func _bridgeToObjectiveC() -> SKC.ReaderSoftwareUpdate.__UpdateDurationEstimate
  public typealias _ObjectiveCType = SKC.ReaderSoftwareUpdate.__UpdateDurationEstimate
  public static func == (a: SKC.__Bridge__ReaderSoftwareUpdate_UpdateDurationEstimate, b: SKC.__Bridge__ReaderSoftwareUpdate_UpdateDurationEstimate) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ReaderSoftwareUpdate_UpdateDurationEstimate]
  nonisolated public static var allCases: [SKC.__Bridge__ReaderSoftwareUpdate_UpdateDurationEstimate] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderSoftwareUpdate {
  public typealias UpdateComponent = SKC.__Bridge__ReaderSoftwareUpdate_UpdateComponent
}
extension SKC.__Bridge__ReaderSoftwareUpdate_UpdateComponent {
  public func toKotlinEnum() -> SKC.ReaderSoftwareUpdate.__UpdateComponent
}
extension SKC.ReaderSoftwareUpdate.__UpdateComponent {
  public func toSwiftEnum() -> SKC.ReaderSoftwareUpdate.UpdateComponent
}
@frozen public enum __Bridge__ReaderSoftwareUpdate_UpdateComponent : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case incremental
  case firmware
  case config
  case keys
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ReaderSoftwareUpdate.__UpdateComponent, result: inout SKC.ReaderSoftwareUpdate.UpdateComponent?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ReaderSoftwareUpdate.__UpdateComponent, result: inout SKC.ReaderSoftwareUpdate.UpdateComponent?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ReaderSoftwareUpdate.__UpdateComponent?) -> SKC.__Bridge__ReaderSoftwareUpdate_UpdateComponent
  public func _bridgeToObjectiveC() -> SKC.ReaderSoftwareUpdate.__UpdateComponent
  public typealias _ObjectiveCType = SKC.ReaderSoftwareUpdate.__UpdateComponent
  public static func == (a: SKC.__Bridge__ReaderSoftwareUpdate_UpdateComponent, b: SKC.__Bridge__ReaderSoftwareUpdate_UpdateComponent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ReaderSoftwareUpdate_UpdateComponent]
  nonisolated public static var allCases: [SKC.__Bridge__ReaderSoftwareUpdate_UpdateComponent] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum LocationStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case set
  case notSet
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__LocationStatus, result: inout SKC.LocationStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__LocationStatus, result: inout SKC.LocationStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__LocationStatus?) -> SKC.LocationStatus
  public func _bridgeToObjectiveC() -> SKC.__LocationStatus
  public typealias _ObjectiveCType = SKC.__LocationStatus
  public static func == (a: SKC.LocationStatus, b: SKC.LocationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.LocationStatus]
  nonisolated public static var allCases: [SKC.LocationStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.LocationStatus {
  public func toKotlinEnum() -> SKC.__LocationStatus
}
extension SKC.__LocationStatus {
  public func toSwiftEnum() -> SKC.LocationStatus
}
@frozen public enum DisconnectReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case disconnectRequested
  case rebootRequested
  case securityReboot
  case criticallyLowBattery
  case poweredOff
  case bluetoothDisabled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__DisconnectReason, result: inout SKC.DisconnectReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__DisconnectReason, result: inout SKC.DisconnectReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__DisconnectReason?) -> SKC.DisconnectReason
  public func _bridgeToObjectiveC() -> SKC.__DisconnectReason
  public typealias _ObjectiveCType = SKC.__DisconnectReason
  public static func == (a: SKC.DisconnectReason, b: SKC.DisconnectReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.DisconnectReason]
  nonisolated public static var allCases: [SKC.DisconnectReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.DisconnectReason {
  public func toKotlinEnum() -> SKC.__DisconnectReason
}
extension SKC.__DisconnectReason {
  public func toSwiftEnum() -> SKC.DisconnectReason
}
@frozen public enum ReaderEvent_ : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case cardInserted
  case cardRemoved
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ReaderEvent_, result: inout SKC.ReaderEvent_?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderEvent_, result: inout SKC.ReaderEvent_?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderEvent_?) -> SKC.ReaderEvent_
  public func _bridgeToObjectiveC() -> SKC.__ReaderEvent_
  public typealias _ObjectiveCType = SKC.__ReaderEvent_
  public static func == (a: SKC.ReaderEvent_, b: SKC.ReaderEvent_) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ReaderEvent_]
  nonisolated public static var allCases: [SKC.ReaderEvent_] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderEvent_ {
  public func toKotlinEnum() -> SKC.__ReaderEvent_
}
extension SKC.__ReaderEvent_ {
  public func toSwiftEnum() -> SKC.ReaderEvent_
}
extension SKC.ReaderInputOptions_ {
  public typealias ReaderInputOption = SKC.__Bridge__ReaderInputOptions__ReaderInputOption
}
extension SKC.__Bridge__ReaderInputOptions__ReaderInputOption {
  public func toKotlinEnum() -> SKC.ReaderInputOptions_.__ReaderInputOption
}
extension SKC.ReaderInputOptions_.__ReaderInputOption {
  public func toSwiftEnum() -> SKC.ReaderInputOptions_.ReaderInputOption
}
@frozen public enum __Bridge__ReaderInputOptions__ReaderInputOption : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case none
  case insert
  case swipe
  case tap
  case manualEntry
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ReaderInputOptions_.__ReaderInputOption, result: inout SKC.ReaderInputOptions_.ReaderInputOption?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ReaderInputOptions_.__ReaderInputOption, result: inout SKC.ReaderInputOptions_.ReaderInputOption?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ReaderInputOptions_.__ReaderInputOption?) -> SKC.__Bridge__ReaderInputOptions__ReaderInputOption
  public func _bridgeToObjectiveC() -> SKC.ReaderInputOptions_.__ReaderInputOption
  public typealias _ObjectiveCType = SKC.ReaderInputOptions_.__ReaderInputOption
  public static func == (a: SKC.__Bridge__ReaderInputOptions__ReaderInputOption, b: SKC.__Bridge__ReaderInputOptions__ReaderInputOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ReaderInputOptions__ReaderInputOption]
  nonisolated public static var allCases: [SKC.__Bridge__ReaderInputOptions__ReaderInputOption] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum ReaderDisplayMessage_ : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case checkMobileDevice
  case retryCard
  case insertCard
  case insertOrSwipeCard
  case swipeCard
  case removeCard
  case multipleContactlessCardsDetected
  case tryAnotherReadMethod
  case tryAnotherCard
  case cardRemovedTooEarly
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ReaderDisplayMessage_, result: inout SKC.ReaderDisplayMessage_?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderDisplayMessage_, result: inout SKC.ReaderDisplayMessage_?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderDisplayMessage_?) -> SKC.ReaderDisplayMessage_
  public func _bridgeToObjectiveC() -> SKC.__ReaderDisplayMessage_
  public typealias _ObjectiveCType = SKC.__ReaderDisplayMessage_
  public static func == (a: SKC.ReaderDisplayMessage_, b: SKC.ReaderDisplayMessage_) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ReaderDisplayMessage_]
  nonisolated public static var allCases: [SKC.ReaderDisplayMessage_] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderDisplayMessage_ {
  public func toKotlinEnum() -> SKC.__ReaderDisplayMessage_
}
extension SKC.__ReaderDisplayMessage_ {
  public func toSwiftEnum() -> SKC.ReaderDisplayMessage_
}
@frozen public enum BatteryStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case critical
  case low
  case nominal
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__BatteryStatus, result: inout SKC.BatteryStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__BatteryStatus, result: inout SKC.BatteryStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__BatteryStatus?) -> SKC.BatteryStatus
  public func _bridgeToObjectiveC() -> SKC.__BatteryStatus
  public typealias _ObjectiveCType = SKC.__BatteryStatus
  public static func == (a: SKC.BatteryStatus, b: SKC.BatteryStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.BatteryStatus]
  nonisolated public static var allCases: [SKC.BatteryStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.BatteryStatus {
  public func toKotlinEnum() -> SKC.__BatteryStatus
}
extension SKC.__BatteryStatus {
  public func toSwiftEnum() -> SKC.BatteryStatus
}
@frozen public enum NetworkStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case offline
  case online
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__NetworkStatus.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__NetworkStatus, result: inout SKC.NetworkStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__NetworkStatus, result: inout SKC.NetworkStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__NetworkStatus?) -> SKC.NetworkStatus
  public func _bridgeToObjectiveC() -> SKC.__NetworkStatus
  public typealias _ObjectiveCType = SKC.__NetworkStatus
  public typealias Companion = SKC.__NetworkStatus.Companion
  public static func == (a: SKC.NetworkStatus, b: SKC.NetworkStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.NetworkStatus]
  nonisolated public static var allCases: [SKC.NetworkStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.NetworkStatus {
  public func toKotlinEnum() -> SKC.__NetworkStatus
}
extension SKC.__NetworkStatus {
  public func toSwiftEnum() -> SKC.NetworkStatus
}
@frozen public enum PaymentStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case notReady
  case ready
  case waitingForInput
  case processing
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PaymentStatus, result: inout SKC.PaymentStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentStatus, result: inout SKC.PaymentStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentStatus?) -> SKC.PaymentStatus
  public func _bridgeToObjectiveC() -> SKC.__PaymentStatus
  public typealias _ObjectiveCType = SKC.__PaymentStatus
  public static func == (a: SKC.PaymentStatus, b: SKC.PaymentStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PaymentStatus]
  nonisolated public static var allCases: [SKC.PaymentStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PaymentStatus {
  public func toKotlinEnum() -> SKC.__PaymentStatus
}
extension SKC.__PaymentStatus {
  public func toSwiftEnum() -> SKC.PaymentStatus
}
@frozen public enum ConnectionStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case notConnected
  case discovering
  case connecting
  case connected
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ConnectionStatus, result: inout SKC.ConnectionStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ConnectionStatus, result: inout SKC.ConnectionStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ConnectionStatus?) -> SKC.ConnectionStatus
  public func _bridgeToObjectiveC() -> SKC.__ConnectionStatus
  public typealias _ObjectiveCType = SKC.__ConnectionStatus
  public static func == (a: SKC.ConnectionStatus, b: SKC.ConnectionStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ConnectionStatus]
  nonisolated public static var allCases: [SKC.ConnectionStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ConnectionStatus {
  public func toKotlinEnum() -> SKC.__ConnectionStatus
}
extension SKC.__ConnectionStatus {
  public func toSwiftEnum() -> SKC.ConnectionStatus
}
@frozen public enum CollectDataType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case magstripe
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CollectDataType, result: inout SKC.CollectDataType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CollectDataType, result: inout SKC.CollectDataType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CollectDataType?) -> SKC.CollectDataType
  public func _bridgeToObjectiveC() -> SKC.__CollectDataType
  public typealias _ObjectiveCType = SKC.__CollectDataType
  public static func == (a: SKC.CollectDataType, b: SKC.CollectDataType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CollectDataType]
  nonisolated public static var allCases: [SKC.CollectDataType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CollectDataType {
  public func toKotlinEnum() -> SKC.__CollectDataType
}
extension SKC.__CollectDataType {
  public func toSwiftEnum() -> SKC.CollectDataType
}
@frozen public enum CustomerAcceptanceType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case online
  case offline
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CustomerAcceptanceType, result: inout SKC.CustomerAcceptanceType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CustomerAcceptanceType, result: inout SKC.CustomerAcceptanceType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CustomerAcceptanceType?) -> SKC.CustomerAcceptanceType
  public func _bridgeToObjectiveC() -> SKC.__CustomerAcceptanceType
  public typealias _ObjectiveCType = SKC.__CustomerAcceptanceType
  public static func == (a: SKC.CustomerAcceptanceType, b: SKC.CustomerAcceptanceType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CustomerAcceptanceType]
  nonisolated public static var allCases: [SKC.CustomerAcceptanceType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CustomerAcceptanceType {
  public func toKotlinEnum() -> SKC.__CustomerAcceptanceType
}
extension SKC.__CustomerAcceptanceType {
  public func toSwiftEnum() -> SKC.CustomerAcceptanceType
}
@frozen public enum ToggleValue : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case enabled
  case disabled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ToggleValue, result: inout SKC.ToggleValue?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ToggleValue, result: inout SKC.ToggleValue?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ToggleValue?) -> SKC.ToggleValue
  public func _bridgeToObjectiveC() -> SKC.__ToggleValue
  public typealias _ObjectiveCType = SKC.__ToggleValue
  public static func == (a: SKC.ToggleValue, b: SKC.ToggleValue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ToggleValue]
  nonisolated public static var allCases: [SKC.ToggleValue] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ToggleValue {
  public func toKotlinEnum() -> SKC.__ToggleValue
}
extension SKC.__ToggleValue {
  public func toSwiftEnum() -> SKC.ToggleValue
}
@frozen public enum ToggleResult : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case enabled
  case disabled
  case skipped
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ToggleResult, result: inout SKC.ToggleResult?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ToggleResult, result: inout SKC.ToggleResult?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ToggleResult?) -> SKC.ToggleResult
  public func _bridgeToObjectiveC() -> SKC.__ToggleResult
  public typealias _ObjectiveCType = SKC.__ToggleResult
  public static func == (a: SKC.ToggleResult, b: SKC.ToggleResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ToggleResult]
  nonisolated public static var allCases: [SKC.ToggleResult] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ToggleResult {
  public func toKotlinEnum() -> SKC.__ToggleResult
}
extension SKC.__ToggleResult {
  public func toSwiftEnum() -> SKC.ToggleResult
}
@frozen public enum ReaderTextToSpeechStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case off
  case headphones
  case speakers
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ReaderTextToSpeechStatus, result: inout SKC.ReaderTextToSpeechStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderTextToSpeechStatus, result: inout SKC.ReaderTextToSpeechStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderTextToSpeechStatus?) -> SKC.ReaderTextToSpeechStatus
  public func _bridgeToObjectiveC() -> SKC.__ReaderTextToSpeechStatus
  public typealias _ObjectiveCType = SKC.__ReaderTextToSpeechStatus
  public static func == (a: SKC.ReaderTextToSpeechStatus, b: SKC.ReaderTextToSpeechStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ReaderTextToSpeechStatus]
  nonisolated public static var allCases: [SKC.ReaderTextToSpeechStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderTextToSpeechStatus {
  public func toKotlinEnum() -> SKC.__ReaderTextToSpeechStatus
}
extension SKC.__ReaderTextToSpeechStatus {
  public func toSwiftEnum() -> SKC.ReaderTextToSpeechStatus
}
@frozen public enum SelectionButtonStyle : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case primary
  case secondary
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SelectionButtonStyle, result: inout SKC.SelectionButtonStyle?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SelectionButtonStyle, result: inout SKC.SelectionButtonStyle?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SelectionButtonStyle?) -> SKC.SelectionButtonStyle
  public func _bridgeToObjectiveC() -> SKC.__SelectionButtonStyle
  public typealias _ObjectiveCType = SKC.__SelectionButtonStyle
  public static func == (a: SKC.SelectionButtonStyle, b: SKC.SelectionButtonStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SelectionButtonStyle]
  nonisolated public static var allCases: [SKC.SelectionButtonStyle] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SelectionButtonStyle {
  public func toKotlinEnum() -> SKC.__SelectionButtonStyle
}
extension SKC.__SelectionButtonStyle {
  public func toSwiftEnum() -> SKC.SelectionButtonStyle
}
@frozen public enum SimulateReaderUpdate : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case updateAvailable
  case none
  case required
  case requiredForOffline
  case lowBattery
  case lowBatterySucceedConnect
  case random
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SimulateReaderUpdate, result: inout SKC.SimulateReaderUpdate?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SimulateReaderUpdate, result: inout SKC.SimulateReaderUpdate?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SimulateReaderUpdate?) -> SKC.SimulateReaderUpdate
  public func _bridgeToObjectiveC() -> SKC.__SimulateReaderUpdate
  public typealias _ObjectiveCType = SKC.__SimulateReaderUpdate
  public static func == (a: SKC.SimulateReaderUpdate, b: SKC.SimulateReaderUpdate) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SimulateReaderUpdate]
  nonisolated public static var allCases: [SKC.SimulateReaderUpdate] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SimulateReaderUpdate {
  public func toKotlinEnum() -> SKC.__SimulateReaderUpdate
}
extension SKC.__SimulateReaderUpdate {
  public func toSwiftEnum() -> SKC.SimulateReaderUpdate
}
@frozen public enum SimulatedCardType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case visa
  case visaDebit
  case mastercard
  case mastercardDebit
  case mastercardPrepaid
  case amex
  case amex2
  case discover
  case discover2
  case diners
  case diners14Digits
  case jcb
  case unionPay
  case interac
  case eftposAuDebit
  case visaUsCommonDebit
  case chargeDeclined
  case chargeDeclinedInsufficientFunds
  case chargeDeclinedLostCard
  case chargeDeclinedStolenCard
  case chargeDeclinedExpiredCard
  case chargeDeclinedProcessingError
  case eftposAuVisaDebit
  case eftposAuDebitMastercard
  case offlinePinCvm
  case offlinePinScaRetry
  case onlinePinCvm
  case onlinePinScaRetry
  public var cardNumber: Swift.String {
    get
  }
  public var expMonth: Swift.Int32 {
    get
  }
  public var expYear: Swift.Int32 {
    get
  }
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SimulatedCardType, result: inout SKC.SimulatedCardType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SimulatedCardType, result: inout SKC.SimulatedCardType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SimulatedCardType?) -> SKC.SimulatedCardType
  public func _bridgeToObjectiveC() -> SKC.__SimulatedCardType
  public typealias _ObjectiveCType = SKC.__SimulatedCardType
  public static func == (a: SKC.SimulatedCardType, b: SKC.SimulatedCardType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SimulatedCardType]
  nonisolated public static var allCases: [SKC.SimulatedCardType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SimulatedCardType {
  public func toKotlinEnum() -> SKC.__SimulatedCardType
}
extension SKC.__SimulatedCardType {
  public func toSwiftEnum() -> SKC.SimulatedCardType
}
@frozen public enum ObjectClass : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case universal
  case application
  case contextSpecific
  case `private`
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__ObjectClass.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ObjectClass, result: inout SKC.ObjectClass?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ObjectClass, result: inout SKC.ObjectClass?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ObjectClass?) -> SKC.ObjectClass
  public func _bridgeToObjectiveC() -> SKC.__ObjectClass
  public typealias _ObjectiveCType = SKC.__ObjectClass
  public typealias Companion = SKC.__ObjectClass.Companion
  public static func == (a: SKC.ObjectClass, b: SKC.ObjectClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ObjectClass]
  nonisolated public static var allCases: [SKC.ObjectClass] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ObjectClass {
  public func toKotlinEnum() -> SKC.__ObjectClass
}
extension SKC.__ObjectClass {
  public func toSwiftEnum() -> SKC.ObjectClass
}
@frozen public enum Construction : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case primitive
  case constructed
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__Construction.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__Construction, result: inout SKC.Construction?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__Construction, result: inout SKC.Construction?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__Construction?) -> SKC.Construction
  public func _bridgeToObjectiveC() -> SKC.__Construction
  public typealias _ObjectiveCType = SKC.__Construction
  public typealias Companion = SKC.__Construction.Companion
  public static func == (a: SKC.Construction, b: SKC.Construction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.Construction]
  nonisolated public static var allCases: [SKC.Construction] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.Construction {
  public func toKotlinEnum() -> SKC.__Construction
}
extension SKC.__Construction {
  public func toSwiftEnum() -> SKC.Construction
}
@frozen public enum ElementOrigin : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case terminal
  case icc
  case issuer
  case issuerOrTerminal
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ElementOrigin, result: inout SKC.ElementOrigin?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ElementOrigin, result: inout SKC.ElementOrigin?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ElementOrigin?) -> SKC.ElementOrigin
  public func _bridgeToObjectiveC() -> SKC.__ElementOrigin
  public typealias _ObjectiveCType = SKC.__ElementOrigin
  public static func == (a: SKC.ElementOrigin, b: SKC.ElementOrigin) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ElementOrigin]
  nonisolated public static var allCases: [SKC.ElementOrigin] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ElementOrigin {
  public func toKotlinEnum() -> SKC.__ElementOrigin
}
extension SKC.__ElementOrigin {
  public func toSwiftEnum() -> SKC.ElementOrigin
}
@frozen public enum TaggedDataElementSpec : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case accountType
  case acquirerIdentifier
  case additionalTerminalCapabilities
  case amountAuthorizedBinary
  case amountAuthorizedNumeric
  case amountOtherBinary
  case amountOtherNumeric
  case amountReferenceCurrency
  case applicationCryptogram
  case applicationCurrencyCode
  case applicationCurrencyExponent
  case applicationDiscretionaryData
  case applicationEffectiveDate
  case applicationExpirationDate
  case applicationFileLocatorAfl
  case applicationDedicatedFileAdfName
  case applicationIdentifierAidTerminal
  case applicationInterchangeProfile
  case applicationLabel
  case applicationPreferredName
  case applicationPrimaryAccountNumber
  case applicationPrimaryAccountNumberPanSequenceNumber
  case applicationPriorityIndicator
  case applicationReferenceCurrency
  case applicationReferenceCurrencyExponent
  case applicationTemplate
  case applicationTransactionCounterAtc
  case applicationUsageControl
  case applicationVersionNumberIcc
  case applicationVersionNumberTerminal
  case authorisationCode
  case authorisationResponseCode
  case bankIdentifierCodeBic
  case cardRiskManagementDateObjectList1Cdol1
  case cardRiskManagementDateObjectList1Cdol2
  case cardholderName
  case cardholderNameExtended
  case cardholderVerificationMethodCvmList
  case cardholderVerificationMethodCvmResults
  case certificationAuthorityPublicKeyIndexIcc
  case certificationAuthorityPublicKeyIndexTerminal
  case commandTemplate
  case cryptogramInformationData
  case dataAuthenticationCode
  case dedicatedFileDfName
  case directoryDefinitionFileDdfName
  case directoryDiscretionaryTemplate
  case dynamicDataAuthenticationDataObjectListDdol
  case fileControlInformationFciIssuerDiscretionaryData
  case fileControlInformationFciProprietaryTemplate
  case fileControlInformationFciTemplate
  case iccDynamicNumber
  case iccPinEnciphermentPublicKeyCertificate
  case iccPinEnciphermentPublicKeyExponent
  case iccPinEnciphermentPublicKeyRemainder
  case iccPublicKeyCertificate
  case iccPublicKeyExponent
  case iccPublicKeyRemainder
  case interfaceDeviceIfdSerialNumber
  case internationalBankAccountNumberIban
  case issuerActionCodeDefault
  case issuerActionCodeDenial
  case issuerActionCodeOnline
  case issuerApplicationData
  case issuerAuthenticationData
  case issuerCodeTableIndex
  case issuerCountryCode
  case issuerCountryCodeAlpha2Format
  case issuerCountryCodeAlpha3Format
  case issuerIdentificationNumberIin
  case issuerPublicKeyCertificate
  case issuerPublicKeyExponent
  case issuerPublicKeyRemainder
  case issuerScriptCommand
  case issuerScriptIdentifier
  case issuerScript1Template
  case issuerScript2Template
  case issuerUrl
  case languagePreference
  case lastOnlineApplicationTransactionCounterAtcRegister
  case logEntry
  case logFormat
  case lowerConsecutiveOfflineLimit
  case merchantCategoryCode
  case merchantIdentifier
  case merchantNameAndLocation
  case personalIdentificationNumberPinTryCounter
  case pointOfServicePosEntryMode
  case processingOptionsDataObjectListPdol
  case readRecordResponseMessageTemplate
  case responseMessageTemplateFormat1
  case responseMessageTemplateFormat2
  case serviceCode
  case shortFileIdentifierSfi
  case signedDynamicApplicationData
  case signedStaticApplicationData
  case staticDataAuthenticationTagList
  case terminalCapabilities
  case terminalCountryCode
  case terminalFloorLimit
  case terminalIdentification
  case terminalRiskManagementData
  case terminalType
  case terminalVerificationResults
  case track1DiscretionaryData
  case track2DiscretionaryData
  case track2EquivalentData
  case transactionCertificateDataObjectListTdol
  case transactionCertificateTcHashValue
  case transactionCurrencyCode
  case transactionCurrencyExponent
  case transactionDate
  case transactionPersonalIdentificationNumberPinData
  case transactionReferenceCurrencyCode
  case transactionReferenceCurrencyExponent
  case transactionSequenceCounter
  case transactionStatusInformation
  case transactionTime
  case transactionType
  case unpredictableNumber
  case upperConsecutiveOfflineLimit
  public var description_: Swift.String {
    get
  }
  public var humanReadableName: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var origin: SKC.ElementOrigin {
    get
  }
  public var tag: SKC.Tag {
    get
  }
  public static var companion: SKC.__TaggedDataElementSpec.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__TaggedDataElementSpec, result: inout SKC.TaggedDataElementSpec?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__TaggedDataElementSpec, result: inout SKC.TaggedDataElementSpec?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__TaggedDataElementSpec?) -> SKC.TaggedDataElementSpec
  public func _bridgeToObjectiveC() -> SKC.__TaggedDataElementSpec
  public typealias _ObjectiveCType = SKC.__TaggedDataElementSpec
  public typealias Companion = SKC.__TaggedDataElementSpec.Companion
  public static func == (a: SKC.TaggedDataElementSpec, b: SKC.TaggedDataElementSpec) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.TaggedDataElementSpec]
  nonisolated public static var allCases: [SKC.TaggedDataElementSpec] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.TaggedDataElementSpec {
  public func toKotlinEnum() -> SKC.__TaggedDataElementSpec
}
extension SKC.__TaggedDataElementSpec {
  public func toSwiftEnum() -> SKC.TaggedDataElementSpec
}
@frozen public enum PaymentCollectionState : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case empty
  case tippingSelection
  case displayCartPreCollection
  case displayCartPostCollection
  case collection
  case processing
  case applicationSelection
  case languageSelection
  case accountSelection
  case pinEntry
  case magstripePinEntry
  case prepareToCollectAgain
  case recoverableErrorSummary
  case onlineAuthorization
  case onlineAuthorizationMagStripe
  case removeCard
  case onlineConfirmation
  case collectionComplete
  case cancel
  case timeout
  case finished
  case manualEntry
  case collectPaymentMethodApiError
  case dccSelection
  case nonCardPaymentMethodSelection
  case nonCardPaymentMethodConfirmation
  case nonCardPaymentMethodActionRequired
  case interstitial
  case passthroughConfirmation
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PaymentCollectionState, result: inout SKC.PaymentCollectionState?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentCollectionState, result: inout SKC.PaymentCollectionState?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentCollectionState?) -> SKC.PaymentCollectionState
  public func _bridgeToObjectiveC() -> SKC.__PaymentCollectionState
  public typealias _ObjectiveCType = SKC.__PaymentCollectionState
  public static func == (a: SKC.PaymentCollectionState, b: SKC.PaymentCollectionState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PaymentCollectionState]
  nonisolated public static var allCases: [SKC.PaymentCollectionState] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PaymentCollectionState {
  public func toKotlinEnum() -> SKC.__PaymentCollectionState
}
extension SKC.__PaymentCollectionState {
  public func toSwiftEnum() -> SKC.PaymentCollectionState
}
@frozen public enum SCARequirement : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case generic
  case onlineOrOfflinePin
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SCARequirement, result: inout SKC.SCARequirement?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SCARequirement, result: inout SKC.SCARequirement?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SCARequirement?) -> SKC.SCARequirement
  public func _bridgeToObjectiveC() -> SKC.__SCARequirement
  public typealias _ObjectiveCType = SKC.__SCARequirement
  public static func == (a: SKC.SCARequirement, b: SKC.SCARequirement) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SCARequirement]
  nonisolated public static var allCases: [SKC.SCARequirement] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SCARequirement {
  public func toKotlinEnum() -> SKC.__SCARequirement
}
extension SKC.__SCARequirement {
  public func toSwiftEnum() -> SKC.SCARequirement
}
@frozen public enum CancelReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case hardwareCancelled
  case merchantCancelled
  case customerCancelled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CancelReason, result: inout SKC.CancelReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CancelReason, result: inout SKC.CancelReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CancelReason?) -> SKC.CancelReason
  public func _bridgeToObjectiveC() -> SKC.__CancelReason
  public typealias _ObjectiveCType = SKC.__CancelReason
  public static func == (a: SKC.CancelReason, b: SKC.CancelReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CancelReason]
  nonisolated public static var allCases: [SKC.CancelReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CancelReason {
  public func toKotlinEnum() -> SKC.__CancelReason
}
extension SKC.__CancelReason {
  public func toSwiftEnum() -> SKC.CancelReason
}
@frozen public enum EarlyTransactionAbortReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case chipCardInitializationFailed
  case emptyCandidateList
  case pinEntryCanceled
  case pinEntryTimedOut
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__EarlyTransactionAbortReason, result: inout SKC.EarlyTransactionAbortReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__EarlyTransactionAbortReason, result: inout SKC.EarlyTransactionAbortReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__EarlyTransactionAbortReason?) -> SKC.EarlyTransactionAbortReason
  public func _bridgeToObjectiveC() -> SKC.__EarlyTransactionAbortReason
  public typealias _ObjectiveCType = SKC.__EarlyTransactionAbortReason
  public static func == (a: SKC.EarlyTransactionAbortReason, b: SKC.EarlyTransactionAbortReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.EarlyTransactionAbortReason]
  nonisolated public static var allCases: [SKC.EarlyTransactionAbortReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.EarlyTransactionAbortReason {
  public func toKotlinEnum() -> SKC.__EarlyTransactionAbortReason
}
extension SKC.__EarlyTransactionAbortReason {
  public func toSwiftEnum() -> SKC.EarlyTransactionAbortReason
}
@frozen public enum PendingPosCommand : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case startCollection
  case processPayment
  case resumePayment
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PendingPosCommand, result: inout SKC.PendingPosCommand?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PendingPosCommand, result: inout SKC.PendingPosCommand?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PendingPosCommand?) -> SKC.PendingPosCommand
  public func _bridgeToObjectiveC() -> SKC.__PendingPosCommand
  public typealias _ObjectiveCType = SKC.__PendingPosCommand
  public static func == (a: SKC.PendingPosCommand, b: SKC.PendingPosCommand) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PendingPosCommand]
  nonisolated public static var allCases: [SKC.PendingPosCommand] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PendingPosCommand {
  public func toKotlinEnum() -> SKC.__PendingPosCommand
}
extension SKC.__PendingPosCommand {
  public func toSwiftEnum() -> SKC.PendingPosCommand
}
@frozen public enum OnlineAuthType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case confirmation
  case secondGenAc
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__OnlineAuthType, result: inout SKC.OnlineAuthType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__OnlineAuthType, result: inout SKC.OnlineAuthType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__OnlineAuthType?) -> SKC.OnlineAuthType
  public func _bridgeToObjectiveC() -> SKC.__OnlineAuthType
  public typealias _ObjectiveCType = SKC.__OnlineAuthType
  public static func == (a: SKC.OnlineAuthType, b: SKC.OnlineAuthType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.OnlineAuthType]
  nonisolated public static var allCases: [SKC.OnlineAuthType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.OnlineAuthType {
  public func toKotlinEnum() -> SKC.__OnlineAuthType
}
extension SKC.__OnlineAuthType {
  public func toSwiftEnum() -> SKC.OnlineAuthType
}
@frozen public enum PinEntryFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case timeout
  case bypassed
  case wrongPinLength
  case incorrectPin
  case iccRemoved
  case cardError
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PinEntryFailureReason, result: inout SKC.PinEntryFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PinEntryFailureReason, result: inout SKC.PinEntryFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PinEntryFailureReason?) -> SKC.PinEntryFailureReason
  public func _bridgeToObjectiveC() -> SKC.__PinEntryFailureReason
  public typealias _ObjectiveCType = SKC.__PinEntryFailureReason
  public static func == (a: SKC.PinEntryFailureReason, b: SKC.PinEntryFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PinEntryFailureReason]
  nonisolated public static var allCases: [SKC.PinEntryFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PinEntryFailureReason {
  public func toKotlinEnum() -> SKC.__PinEntryFailureReason
}
extension SKC.__PinEntryFailureReason {
  public func toSwiftEnum() -> SKC.PinEntryFailureReason
}
@frozen public enum Result : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case success
  case failure
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public func toOutcome() -> any SKC.PublicOutcome
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__Result, result: inout SKC.Result?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__Result, result: inout SKC.Result?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__Result?) -> SKC.Result
  public func _bridgeToObjectiveC() -> SKC.__Result
  public typealias _ObjectiveCType = SKC.__Result
  public static func == (a: SKC.Result, b: SKC.Result) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.Result]
  nonisolated public static var allCases: [SKC.Result] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.Result {
  public func toKotlinEnum() -> SKC.__Result
}
extension SKC.__Result {
  public func toSwiftEnum() -> SKC.Result
}
@frozen public enum DisplayCartResult : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case cartUpdated
  case startedCollection
  case merchantCancelled
  case customerCancelled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__DisplayCartResult, result: inout SKC.DisplayCartResult?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__DisplayCartResult, result: inout SKC.DisplayCartResult?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__DisplayCartResult?) -> SKC.DisplayCartResult
  public func _bridgeToObjectiveC() -> SKC.__DisplayCartResult
  public typealias _ObjectiveCType = SKC.__DisplayCartResult
  public static func == (a: SKC.DisplayCartResult, b: SKC.DisplayCartResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.DisplayCartResult]
  nonisolated public static var allCases: [SKC.DisplayCartResult] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.DisplayCartResult {
  public func toKotlinEnum() -> SKC.__DisplayCartResult
}
extension SKC.__DisplayCartResult {
  public func toSwiftEnum() -> SKC.DisplayCartResult
}
@frozen public enum LatencyCategory : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case userAction
  case kernelProcessing
  case posCommandDelay
  case networkProcessing
  case unknown
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__LatencyCategory, result: inout SKC.LatencyCategory?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__LatencyCategory, result: inout SKC.LatencyCategory?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__LatencyCategory?) -> SKC.LatencyCategory
  public func _bridgeToObjectiveC() -> SKC.__LatencyCategory
  public typealias _ObjectiveCType = SKC.__LatencyCategory
  public static func == (a: SKC.LatencyCategory, b: SKC.LatencyCategory) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.LatencyCategory]
  nonisolated public static var allCases: [SKC.LatencyCategory] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.LatencyCategory {
  public func toKotlinEnum() -> SKC.__LatencyCategory
}
extension SKC.__LatencyCategory {
  public func toSwiftEnum() -> SKC.LatencyCategory
}
@frozen public enum ManualEntryFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case userCancelled
  case invalidEncryptedDataResult
  case timeout
  case deviceFailure
  case earlyTransactionResult
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ManualEntryFailureReason, result: inout SKC.ManualEntryFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ManualEntryFailureReason, result: inout SKC.ManualEntryFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ManualEntryFailureReason?) -> SKC.ManualEntryFailureReason
  public func _bridgeToObjectiveC() -> SKC.__ManualEntryFailureReason
  public typealias _ObjectiveCType = SKC.__ManualEntryFailureReason
  public static func == (a: SKC.ManualEntryFailureReason, b: SKC.ManualEntryFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ManualEntryFailureReason]
  nonisolated public static var allCases: [SKC.ManualEntryFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ManualEntryFailureReason {
  public func toKotlinEnum() -> SKC.__ManualEntryFailureReason
}
extension SKC.__ManualEntryFailureReason {
  public func toSwiftEnum() -> SKC.ManualEntryFailureReason
}
@frozen public enum ManualEntryState : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case empty
  case configureReader
  case panEntry
  case expiryDateEntry
  case cvvEntry
  case zipCode
  case confirmDetails
  case finished
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ManualEntryState, result: inout SKC.ManualEntryState?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ManualEntryState, result: inout SKC.ManualEntryState?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ManualEntryState?) -> SKC.ManualEntryState
  public func _bridgeToObjectiveC() -> SKC.__ManualEntryState
  public typealias _ObjectiveCType = SKC.__ManualEntryState
  public static func == (a: SKC.ManualEntryState, b: SKC.ManualEntryState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ManualEntryState]
  nonisolated public static var allCases: [SKC.ManualEntryState] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ManualEntryState {
  public func toKotlinEnum() -> SKC.__ManualEntryState
}
extension SKC.__ManualEntryState {
  public func toSwiftEnum() -> SKC.ManualEntryState
}
@frozen public enum OnlineAuthFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case declined
  case scaNeeded
  case unknownNetworkFailure
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__OnlineAuthFailureReason, result: inout SKC.OnlineAuthFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__OnlineAuthFailureReason, result: inout SKC.OnlineAuthFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__OnlineAuthFailureReason?) -> SKC.OnlineAuthFailureReason
  public func _bridgeToObjectiveC() -> SKC.__OnlineAuthFailureReason
  public typealias _ObjectiveCType = SKC.__OnlineAuthFailureReason
  public static func == (a: SKC.OnlineAuthFailureReason, b: SKC.OnlineAuthFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.OnlineAuthFailureReason]
  nonisolated public static var allCases: [SKC.OnlineAuthFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.OnlineAuthFailureReason {
  public func toKotlinEnum() -> SKC.__OnlineAuthFailureReason
}
extension SKC.__OnlineAuthFailureReason {
  public func toSwiftEnum() -> SKC.OnlineAuthFailureReason
}
@frozen public enum OnlineAuthFailureReason_ : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case hardwareCancelled
  case timeout
  case declined
  case scaNeeded
  case unknownNetworkFailure
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__OnlineAuthFailureReason_, result: inout SKC.OnlineAuthFailureReason_?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__OnlineAuthFailureReason_, result: inout SKC.OnlineAuthFailureReason_?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__OnlineAuthFailureReason_?) -> SKC.OnlineAuthFailureReason_
  public func _bridgeToObjectiveC() -> SKC.__OnlineAuthFailureReason_
  public typealias _ObjectiveCType = SKC.__OnlineAuthFailureReason_
  public static func == (a: SKC.OnlineAuthFailureReason_, b: SKC.OnlineAuthFailureReason_) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.OnlineAuthFailureReason_]
  nonisolated public static var allCases: [SKC.OnlineAuthFailureReason_] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.OnlineAuthFailureReason_ {
  public func toKotlinEnum() -> SKC.__OnlineAuthFailureReason_
}
extension SKC.__OnlineAuthFailureReason_ {
  public func toSwiftEnum() -> SKC.OnlineAuthFailureReason_
}
@frozen public enum AccountSelectionFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case hardwareCancelled
  case collectionFailure
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__AccountSelectionFailureReason, result: inout SKC.AccountSelectionFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__AccountSelectionFailureReason, result: inout SKC.AccountSelectionFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__AccountSelectionFailureReason?) -> SKC.AccountSelectionFailureReason
  public func _bridgeToObjectiveC() -> SKC.__AccountSelectionFailureReason
  public typealias _ObjectiveCType = SKC.__AccountSelectionFailureReason
  public static func == (a: SKC.AccountSelectionFailureReason, b: SKC.AccountSelectionFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.AccountSelectionFailureReason]
  nonisolated public static var allCases: [SKC.AccountSelectionFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.AccountSelectionFailureReason {
  public func toKotlinEnum() -> SKC.__AccountSelectionFailureReason
}
extension SKC.__AccountSelectionFailureReason {
  public func toSwiftEnum() -> SKC.AccountSelectionFailureReason
}
@frozen public enum ActionType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case automatic
  case customerInput
  case networkResponse
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ActionType, result: inout SKC.ActionType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ActionType, result: inout SKC.ActionType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ActionType?) -> SKC.ActionType
  public func _bridgeToObjectiveC() -> SKC.__ActionType
  public typealias _ObjectiveCType = SKC.__ActionType
  public static func == (a: SKC.ActionType, b: SKC.ActionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ActionType]
  nonisolated public static var allCases: [SKC.ActionType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ActionType {
  public func toKotlinEnum() -> SKC.__ActionType
}
extension SKC.__ActionType {
  public func toSwiftEnum() -> SKC.ActionType
}
@frozen public enum ApplicationSelectionFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case hardwareCancelled
  case collectionFailure
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ApplicationSelectionFailureReason, result: inout SKC.ApplicationSelectionFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ApplicationSelectionFailureReason, result: inout SKC.ApplicationSelectionFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ApplicationSelectionFailureReason?) -> SKC.ApplicationSelectionFailureReason
  public func _bridgeToObjectiveC() -> SKC.__ApplicationSelectionFailureReason
  public typealias _ObjectiveCType = SKC.__ApplicationSelectionFailureReason
  public static func == (a: SKC.ApplicationSelectionFailureReason, b: SKC.ApplicationSelectionFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ApplicationSelectionFailureReason]
  nonisolated public static var allCases: [SKC.ApplicationSelectionFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ApplicationSelectionFailureReason {
  public func toKotlinEnum() -> SKC.__ApplicationSelectionFailureReason
}
extension SKC.__ApplicationSelectionFailureReason {
  public func toSwiftEnum() -> SKC.ApplicationSelectionFailureReason
}
@frozen public enum CardPresentFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case hardwareCancelled
  case timeout
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CardPresentFailureReason, result: inout SKC.CardPresentFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CardPresentFailureReason, result: inout SKC.CardPresentFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CardPresentFailureReason?) -> SKC.CardPresentFailureReason
  public func _bridgeToObjectiveC() -> SKC.__CardPresentFailureReason
  public typealias _ObjectiveCType = SKC.__CardPresentFailureReason
  public static func == (a: SKC.CardPresentFailureReason, b: SKC.CardPresentFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CardPresentFailureReason]
  nonisolated public static var allCases: [SKC.CardPresentFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CardPresentFailureReason {
  public func toKotlinEnum() -> SKC.__CardPresentFailureReason
}
extension SKC.__CardPresentFailureReason {
  public func toSwiftEnum() -> SKC.CardPresentFailureReason
}
@frozen public enum CollectionFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case magstripeNotAllowed
  case chipCardInitializationFailed
  case emptyCandidateList
  case pinEntryCanceled
  case pinEntryTimedOut
  case contactlessLimitExceeded
  case readerDeclined
  case readerTerminated
  case multipleCardsDetected
  case cardBlocked
  case deviceFailure
  case iccCardRemoved
  case checkMobileDevice
  case insertOrSwipeRequired
  case timeout
  case onlineConfirmationDeclined
  case onlineConfirmationUnknown
  case scaNeeded
  case mobileWalletTooManyTaps
  case cardStillInserted
  case invalidCollectedData
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CollectionFailureReason, result: inout SKC.CollectionFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CollectionFailureReason, result: inout SKC.CollectionFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CollectionFailureReason?) -> SKC.CollectionFailureReason
  public func _bridgeToObjectiveC() -> SKC.__CollectionFailureReason
  public typealias _ObjectiveCType = SKC.__CollectionFailureReason
  public static func == (a: SKC.CollectionFailureReason, b: SKC.CollectionFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CollectionFailureReason]
  nonisolated public static var allCases: [SKC.CollectionFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CollectionFailureReason {
  public func toKotlinEnum() -> SKC.__CollectionFailureReason
}
extension SKC.__CollectionFailureReason {
  public func toSwiftEnum() -> SKC.CollectionFailureReason
}
@frozen public enum DynamicCurrencyConversionSelectionFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case hardwareCancelled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__DynamicCurrencyConversionSelectionFailureReason, result: inout SKC.DynamicCurrencyConversionSelectionFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__DynamicCurrencyConversionSelectionFailureReason, result: inout SKC.DynamicCurrencyConversionSelectionFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__DynamicCurrencyConversionSelectionFailureReason?) -> SKC.DynamicCurrencyConversionSelectionFailureReason
  public func _bridgeToObjectiveC() -> SKC.__DynamicCurrencyConversionSelectionFailureReason
  public typealias _ObjectiveCType = SKC.__DynamicCurrencyConversionSelectionFailureReason
  public static func == (a: SKC.DynamicCurrencyConversionSelectionFailureReason, b: SKC.DynamicCurrencyConversionSelectionFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.DynamicCurrencyConversionSelectionFailureReason]
  nonisolated public static var allCases: [SKC.DynamicCurrencyConversionSelectionFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.DynamicCurrencyConversionSelectionFailureReason {
  public func toKotlinEnum() -> SKC.__DynamicCurrencyConversionSelectionFailureReason
}
extension SKC.__DynamicCurrencyConversionSelectionFailureReason {
  public func toSwiftEnum() -> SKC.DynamicCurrencyConversionSelectionFailureReason
}
@frozen public enum DynamicCurrencyConversionSelectionResult : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case original
  case target
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__DynamicCurrencyConversionSelectionResult, result: inout SKC.DynamicCurrencyConversionSelectionResult?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__DynamicCurrencyConversionSelectionResult, result: inout SKC.DynamicCurrencyConversionSelectionResult?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__DynamicCurrencyConversionSelectionResult?) -> SKC.DynamicCurrencyConversionSelectionResult
  public func _bridgeToObjectiveC() -> SKC.__DynamicCurrencyConversionSelectionResult
  public typealias _ObjectiveCType = SKC.__DynamicCurrencyConversionSelectionResult
  public static func == (a: SKC.DynamicCurrencyConversionSelectionResult, b: SKC.DynamicCurrencyConversionSelectionResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.DynamicCurrencyConversionSelectionResult]
  nonisolated public static var allCases: [SKC.DynamicCurrencyConversionSelectionResult] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.DynamicCurrencyConversionSelectionResult {
  public func toKotlinEnum() -> SKC.__DynamicCurrencyConversionSelectionResult
}
extension SKC.__DynamicCurrencyConversionSelectionResult {
  public func toSwiftEnum() -> SKC.DynamicCurrencyConversionSelectionResult
}
@frozen public enum KernelProcessingFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case hardwareCancelled
  case timeout
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__KernelProcessingFailureReason, result: inout SKC.KernelProcessingFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__KernelProcessingFailureReason, result: inout SKC.KernelProcessingFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__KernelProcessingFailureReason?) -> SKC.KernelProcessingFailureReason
  public func _bridgeToObjectiveC() -> SKC.__KernelProcessingFailureReason
  public typealias _ObjectiveCType = SKC.__KernelProcessingFailureReason
  public static func == (a: SKC.KernelProcessingFailureReason, b: SKC.KernelProcessingFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.KernelProcessingFailureReason]
  nonisolated public static var allCases: [SKC.KernelProcessingFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.KernelProcessingFailureReason {
  public func toKotlinEnum() -> SKC.__KernelProcessingFailureReason
}
extension SKC.__KernelProcessingFailureReason {
  public func toSwiftEnum() -> SKC.KernelProcessingFailureReason
}
@frozen public enum KernelProcessingStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case busy
  case idle
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__KernelProcessingStatus, result: inout SKC.KernelProcessingStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__KernelProcessingStatus, result: inout SKC.KernelProcessingStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__KernelProcessingStatus?) -> SKC.KernelProcessingStatus
  public func _bridgeToObjectiveC() -> SKC.__KernelProcessingStatus
  public typealias _ObjectiveCType = SKC.__KernelProcessingStatus
  public static func == (a: SKC.KernelProcessingStatus, b: SKC.KernelProcessingStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.KernelProcessingStatus]
  nonisolated public static var allCases: [SKC.KernelProcessingStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.KernelProcessingStatus {
  public func toKotlinEnum() -> SKC.__KernelProcessingStatus
}
extension SKC.__KernelProcessingStatus {
  public func toSwiftEnum() -> SKC.KernelProcessingStatus
}
@frozen public enum NonCardPaymentMethodActionRequiredFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case hardwareCancelled
  case timeout
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__NonCardPaymentMethodActionRequiredFailureReason, result: inout SKC.NonCardPaymentMethodActionRequiredFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__NonCardPaymentMethodActionRequiredFailureReason, result: inout SKC.NonCardPaymentMethodActionRequiredFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__NonCardPaymentMethodActionRequiredFailureReason?) -> SKC.NonCardPaymentMethodActionRequiredFailureReason
  public func _bridgeToObjectiveC() -> SKC.__NonCardPaymentMethodActionRequiredFailureReason
  public typealias _ObjectiveCType = SKC.__NonCardPaymentMethodActionRequiredFailureReason
  public static func == (a: SKC.NonCardPaymentMethodActionRequiredFailureReason, b: SKC.NonCardPaymentMethodActionRequiredFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.NonCardPaymentMethodActionRequiredFailureReason]
  nonisolated public static var allCases: [SKC.NonCardPaymentMethodActionRequiredFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.NonCardPaymentMethodActionRequiredFailureReason {
  public func toKotlinEnum() -> SKC.__NonCardPaymentMethodActionRequiredFailureReason
}
extension SKC.__NonCardPaymentMethodActionRequiredFailureReason {
  public func toSwiftEnum() -> SKC.NonCardPaymentMethodActionRequiredFailureReason
}
@frozen public enum NonCardPaymentMethodSelectionFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case hardwareCancelled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__NonCardPaymentMethodSelectionFailureReason, result: inout SKC.NonCardPaymentMethodSelectionFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__NonCardPaymentMethodSelectionFailureReason, result: inout SKC.NonCardPaymentMethodSelectionFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__NonCardPaymentMethodSelectionFailureReason?) -> SKC.NonCardPaymentMethodSelectionFailureReason
  public func _bridgeToObjectiveC() -> SKC.__NonCardPaymentMethodSelectionFailureReason
  public typealias _ObjectiveCType = SKC.__NonCardPaymentMethodSelectionFailureReason
  public static func == (a: SKC.NonCardPaymentMethodSelectionFailureReason, b: SKC.NonCardPaymentMethodSelectionFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.NonCardPaymentMethodSelectionFailureReason]
  nonisolated public static var allCases: [SKC.NonCardPaymentMethodSelectionFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.NonCardPaymentMethodSelectionFailureReason {
  public func toKotlinEnum() -> SKC.__NonCardPaymentMethodSelectionFailureReason
}
extension SKC.__NonCardPaymentMethodSelectionFailureReason {
  public func toSwiftEnum() -> SKC.NonCardPaymentMethodSelectionFailureReason
}
@frozen public enum OnlineConfirmationFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case timeout
  case declined
  case scaNeeded
  case unknownNetworkFailure
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__OnlineConfirmationFailureReason, result: inout SKC.OnlineConfirmationFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__OnlineConfirmationFailureReason, result: inout SKC.OnlineConfirmationFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__OnlineConfirmationFailureReason?) -> SKC.OnlineConfirmationFailureReason
  public func _bridgeToObjectiveC() -> SKC.__OnlineConfirmationFailureReason
  public typealias _ObjectiveCType = SKC.__OnlineConfirmationFailureReason
  public static func == (a: SKC.OnlineConfirmationFailureReason, b: SKC.OnlineConfirmationFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.OnlineConfirmationFailureReason]
  nonisolated public static var allCases: [SKC.OnlineConfirmationFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.OnlineConfirmationFailureReason {
  public func toKotlinEnum() -> SKC.__OnlineConfirmationFailureReason
}
extension SKC.__OnlineConfirmationFailureReason {
  public func toSwiftEnum() -> SKC.OnlineConfirmationFailureReason
}
@frozen public enum PaymentMethodType_ : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case emvTap
  case emvInsertQuick
  case emvInsertFull
  case magstripe
  case manualEntry
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PaymentMethodType_, result: inout SKC.PaymentMethodType_?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentMethodType_, result: inout SKC.PaymentMethodType_?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentMethodType_?) -> SKC.PaymentMethodType_
  public func _bridgeToObjectiveC() -> SKC.__PaymentMethodType_
  public typealias _ObjectiveCType = SKC.__PaymentMethodType_
  public static func == (a: SKC.PaymentMethodType_, b: SKC.PaymentMethodType_) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PaymentMethodType_]
  nonisolated public static var allCases: [SKC.PaymentMethodType_] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PaymentMethodType_ {
  public func toKotlinEnum() -> SKC.__PaymentMethodType_
}
extension SKC.__PaymentMethodType_ {
  public func toSwiftEnum() -> SKC.PaymentMethodType_
}
@frozen public enum WaitForPosCommandFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case merchantCancelled
  case customerCancelled
  case hardwareCancelled
  case timedOut
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__WaitForPosCommandFailureReason, result: inout SKC.WaitForPosCommandFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__WaitForPosCommandFailureReason, result: inout SKC.WaitForPosCommandFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__WaitForPosCommandFailureReason?) -> SKC.WaitForPosCommandFailureReason
  public func _bridgeToObjectiveC() -> SKC.__WaitForPosCommandFailureReason
  public typealias _ObjectiveCType = SKC.__WaitForPosCommandFailureReason
  public static func == (a: SKC.WaitForPosCommandFailureReason, b: SKC.WaitForPosCommandFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.WaitForPosCommandFailureReason]
  nonisolated public static var allCases: [SKC.WaitForPosCommandFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.WaitForPosCommandFailureReason {
  public func toKotlinEnum() -> SKC.__WaitForPosCommandFailureReason
}
extension SKC.__WaitForPosCommandFailureReason {
  public func toSwiftEnum() -> SKC.WaitForPosCommandFailureReason
}
extension SKC.ChargeAttempt {
  public typealias ExtendedAttemptRequirement = SKC.__Bridge__ChargeAttempt_ExtendedAttemptRequirement
}
extension SKC.__Bridge__ChargeAttempt_ExtendedAttemptRequirement {
  public func toKotlinEnum() -> SKC.ChargeAttempt.__ExtendedAttemptRequirement
}
extension SKC.ChargeAttempt.__ExtendedAttemptRequirement {
  public func toSwiftEnum() -> SKC.ChargeAttempt.ExtendedAttemptRequirement
}
@frozen public enum __Bridge__ChargeAttempt_ExtendedAttemptRequirement : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case offlinePinRequired
  case onlineOrOfflinePinRequired
  case mobileDeviceAuthenticationRequired
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ChargeAttempt.__ExtendedAttemptRequirement, result: inout SKC.ChargeAttempt.ExtendedAttemptRequirement?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ChargeAttempt.__ExtendedAttemptRequirement, result: inout SKC.ChargeAttempt.ExtendedAttemptRequirement?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ChargeAttempt.__ExtendedAttemptRequirement?) -> SKC.__Bridge__ChargeAttempt_ExtendedAttemptRequirement
  public func _bridgeToObjectiveC() -> SKC.ChargeAttempt.__ExtendedAttemptRequirement
  public typealias _ObjectiveCType = SKC.ChargeAttempt.__ExtendedAttemptRequirement
  public static func == (a: SKC.__Bridge__ChargeAttempt_ExtendedAttemptRequirement, b: SKC.__Bridge__ChargeAttempt_ExtendedAttemptRequirement) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ChargeAttempt_ExtendedAttemptRequirement]
  nonisolated public static var allCases: [SKC.__Bridge__ChargeAttempt_ExtendedAttemptRequirement] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum NonCardPaymentMethodCompletionMethod : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case notApplicable
  case polling
  case iotMessage
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__NonCardPaymentMethodCompletionMethod, result: inout SKC.NonCardPaymentMethodCompletionMethod?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__NonCardPaymentMethodCompletionMethod, result: inout SKC.NonCardPaymentMethodCompletionMethod?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__NonCardPaymentMethodCompletionMethod?) -> SKC.NonCardPaymentMethodCompletionMethod
  public func _bridgeToObjectiveC() -> SKC.__NonCardPaymentMethodCompletionMethod
  public typealias _ObjectiveCType = SKC.__NonCardPaymentMethodCompletionMethod
  public static func == (a: SKC.NonCardPaymentMethodCompletionMethod, b: SKC.NonCardPaymentMethodCompletionMethod) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.NonCardPaymentMethodCompletionMethod]
  nonisolated public static var allCases: [SKC.NonCardPaymentMethodCompletionMethod] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.NonCardPaymentMethodCompletionMethod {
  public func toKotlinEnum() -> SKC.__NonCardPaymentMethodCompletionMethod
}
extension SKC.__NonCardPaymentMethodCompletionMethod {
  public func toSwiftEnum() -> SKC.NonCardPaymentMethodCompletionMethod
}
extension SKC.PaymentMethodCollectionTypePassthrough {
  public typealias PassthroughType = SKC.__Bridge__PaymentMethodCollectionTypePassthrough_PassthroughType
}
extension SKC.__Bridge__PaymentMethodCollectionTypePassthrough_PassthroughType {
  public func toKotlinEnum() -> SKC.PaymentMethodCollectionTypePassthrough.__PassthroughType
}
extension SKC.PaymentMethodCollectionTypePassthrough.__PassthroughType {
  public func toSwiftEnum() -> SKC.PaymentMethodCollectionTypePassthrough.PassthroughType
}
@frozen public enum __Bridge__PaymentMethodCollectionTypePassthrough_PassthroughType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case magstripe
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.PaymentMethodCollectionTypePassthrough.__PassthroughType, result: inout SKC.PaymentMethodCollectionTypePassthrough.PassthroughType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.PaymentMethodCollectionTypePassthrough.__PassthroughType, result: inout SKC.PaymentMethodCollectionTypePassthrough.PassthroughType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.PaymentMethodCollectionTypePassthrough.__PassthroughType?) -> SKC.__Bridge__PaymentMethodCollectionTypePassthrough_PassthroughType
  public func _bridgeToObjectiveC() -> SKC.PaymentMethodCollectionTypePassthrough.__PassthroughType
  public typealias _ObjectiveCType = SKC.PaymentMethodCollectionTypePassthrough.__PassthroughType
  public static func == (a: SKC.__Bridge__PaymentMethodCollectionTypePassthrough_PassthroughType, b: SKC.__Bridge__PaymentMethodCollectionTypePassthrough_PassthroughType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__PaymentMethodCollectionTypePassthrough_PassthroughType]
  nonisolated public static var allCases: [SKC.__Bridge__PaymentMethodCollectionTypePassthrough_PassthroughType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication {
  public typealias Requirement = SKC.__Bridge__PaymentMethodCollectionTypeStrongCustomerAuthentication_Requirement
}
extension SKC.__Bridge__PaymentMethodCollectionTypeStrongCustomerAuthentication_Requirement {
  public func toKotlinEnum() -> SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication.__Requirement
}
extension SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication.__Requirement {
  public func toSwiftEnum() -> SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication.Requirement
}
@frozen public enum __Bridge__PaymentMethodCollectionTypeStrongCustomerAuthentication_Requirement : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case generic
  case onlineOrOfflinePin
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication.__Requirement, result: inout SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication.Requirement?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication.__Requirement, result: inout SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication.Requirement?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication.__Requirement?) -> SKC.__Bridge__PaymentMethodCollectionTypeStrongCustomerAuthentication_Requirement
  public func _bridgeToObjectiveC() -> SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication.__Requirement
  public typealias _ObjectiveCType = SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication.__Requirement
  public static func == (a: SKC.__Bridge__PaymentMethodCollectionTypeStrongCustomerAuthentication_Requirement, b: SKC.__Bridge__PaymentMethodCollectionTypeStrongCustomerAuthentication_Requirement) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__PaymentMethodCollectionTypeStrongCustomerAuthentication_Requirement]
  nonisolated public static var allCases: [SKC.__Bridge__PaymentMethodCollectionTypeStrongCustomerAuthentication_Requirement] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.MagstripePayment {
  public typealias FallbackReason = SKC.__Bridge__MagstripePayment_FallbackReason
}
extension SKC.__Bridge__MagstripePayment_FallbackReason {
  public func toKotlinEnum() -> SKC.MagstripePayment.__FallbackReason
}
extension SKC.MagstripePayment.__FallbackReason {
  public func toSwiftEnum() -> SKC.MagstripePayment.FallbackReason
}
@frozen public enum __Bridge__MagstripePayment_FallbackReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case none
  case chipError
  case emptyCandidateList
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.MagstripePayment.__FallbackReason, result: inout SKC.MagstripePayment.FallbackReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.MagstripePayment.__FallbackReason, result: inout SKC.MagstripePayment.FallbackReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.MagstripePayment.__FallbackReason?) -> SKC.__Bridge__MagstripePayment_FallbackReason
  public func _bridgeToObjectiveC() -> SKC.MagstripePayment.__FallbackReason
  public typealias _ObjectiveCType = SKC.MagstripePayment.__FallbackReason
  public static func == (a: SKC.__Bridge__MagstripePayment_FallbackReason, b: SKC.__Bridge__MagstripePayment_FallbackReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__MagstripePayment_FallbackReason]
  nonisolated public static var allCases: [SKC.__Bridge__MagstripePayment_FallbackReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum CountryCode : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case undefined
  case ac
  case ad
  case ae
  case af
  case ag
  case ai
  case al
  case am
  case an
  case ao
  case aq
  case ar
  case `as`
  case at
  case au
  case aw
  case ax
  case az
  case ba
  case bb
  case bd
  case be
  case bf
  case bg
  case bh
  case bi
  case bj
  case bl
  case bm
  case bn
  case bo
  case bq
  case br
  case bs
  case bt
  case bu
  case bv
  case bw
  case by
  case bz
  case ca
  case cc
  case cd
  case cf
  case cg
  case ch
  case ci
  case ck
  case cl
  case cm
  case cn
  case co
  case cp
  case cr
  case cs
  case cu
  case cv
  case cw
  case cx
  case cy
  case cz
  case de
  case dg
  case dj
  case dk
  case dm
  case `do`
  case dz
  case ea
  case ec
  case ee
  case eg
  case eh
  case er
  case es
  case et
  case eu
  case ez
  case fi
  case fj
  case fk
  case fm
  case fo
  case fr
  case fx
  case ga
  case gb
  case gd
  case ge
  case gf
  case gg
  case gh
  case gi
  case gl
  case gm
  case gn
  case gp
  case gq
  case gr
  case gs
  case gt
  case gu
  case gw
  case gy
  case hk
  case hm
  case hn
  case hr
  case ht
  case hu
  case ic
  case id
  case ie
  case il
  case im
  case `in`
  case io
  case iq
  case ir
  case `is`
  case it
  case je
  case jm
  case jo
  case jp
  case ke
  case kg
  case kh
  case ki
  case km
  case kn
  case kp
  case kr
  case kw
  case ky
  case kz
  case la
  case lb
  case lc
  case li
  case lk
  case lr
  case ls
  case lt
  case lu
  case lv
  case ly
  case ma
  case mc
  case md
  case me
  case mf
  case mg
  case mh
  case mk
  case ml
  case mm
  case mn
  case mo
  case mp
  case mq
  case mr
  case ms
  case mt
  case mu
  case mv
  case mw
  case mx
  case my
  case mz
  case na
  case nc
  case ne
  case nf
  case ng
  case ni
  case nl
  case no
  case np
  case nr
  case nt
  case nu
  case nz
  case om
  case pa
  case pe
  case pf
  case pg
  case ph
  case pk
  case pl
  case pm
  case pn
  case pr
  case ps
  case pt
  case pw
  case py
  case qa
  case re
  case ro
  case rs
  case ru
  case rw
  case sa
  case sb
  case sc
  case sd
  case se
  case sf
  case sg
  case sh
  case si
  case sj
  case sk
  case sl
  case sm
  case sn
  case so
  case sr
  case ss
  case st
  case su
  case sv
  case sx
  case sy
  case sz
  case ta
  case tc
  case td
  case tf
  case tg
  case th
  case tj
  case tk
  case tl
  case tm
  case tn
  case to
  case tp
  case tr
  case tt
  case tv
  case tw
  case tz
  case ua
  case ug
  case uk
  case um
  case us
  case uy
  case uz
  case va
  case vc
  case ve
  case vg
  case vi
  case vn
  case vu
  case wf
  case ws
  case xi
  case xu
  case xk
  case ye
  case yt
  case yu
  case za
  case zm
  case zr
  case zw
  public var alpha2: Swift.String {
    get
  }
  public var alpha3: Swift.String? {
    get
  }
  public var countryName: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public var numeric: Swift.Int32 {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CountryCode.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CountryCode, result: inout SKC.CountryCode?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CountryCode, result: inout SKC.CountryCode?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CountryCode?) -> SKC.CountryCode
  public func _bridgeToObjectiveC() -> SKC.__CountryCode
  public typealias _ObjectiveCType = SKC.__CountryCode
  public typealias Companion = SKC.__CountryCode.Companion
  public typealias __Assignment = SKC.__CountryCode.__Assignment
  public typealias Assignment = SKC.__CountryCode.Assignment
  public static func == (a: SKC.CountryCode, b: SKC.CountryCode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CountryCode]
  nonisolated public static var allCases: [SKC.CountryCode] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CountryCode {
  public func toKotlinEnum() -> SKC.__CountryCode
}
extension SKC.__CountryCode {
  public func toSwiftEnum() -> SKC.CountryCode
}
extension SKC.__CountryCode {
  public typealias Assignment = SKC.__Bridge____CountryCode_Assignment
}
extension SKC.__Bridge____CountryCode_Assignment {
  public func toKotlinEnum() -> SKC.__CountryCode.__Assignment
}
extension SKC.__CountryCode.__Assignment {
  public func toSwiftEnum() -> SKC.__CountryCode.Assignment
}
@frozen public enum __Bridge____CountryCode_Assignment : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case officiallyAssigned
  case userAssigned
  case exceptionallyReserved
  case transitionallyReserved
  case indeterminatelyReserved
  case notUsed
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CountryCode.__Assignment, result: inout SKC.__CountryCode.Assignment?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CountryCode.__Assignment, result: inout SKC.__CountryCode.Assignment?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CountryCode.__Assignment?) -> SKC.__Bridge____CountryCode_Assignment
  public func _bridgeToObjectiveC() -> SKC.__CountryCode.__Assignment
  public typealias _ObjectiveCType = SKC.__CountryCode.__Assignment
  public static func == (a: SKC.__Bridge____CountryCode_Assignment, b: SKC.__Bridge____CountryCode_Assignment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge____CountryCode_Assignment]
  nonisolated public static var allCases: [SKC.__Bridge____CountryCode_Assignment] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum CurrencyCode : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case undefined
  case aed
  case afn
  case all
  case amd
  case ang
  case aoa
  case ars
  case aud
  case awg
  case azn
  case bam
  case bbd
  case bdt
  case bgn
  case bhd
  case bif
  case bmd
  case bnd
  case bob
  case bov
  case brl
  case bsd
  case btn
  case bwp
  case byn
  case byr
  case bzd
  case cad
  case cdf
  case che
  case chf
  case chw
  case clf
  case clp
  case cny
  case cop
  case cou
  case crc
  case cuc
  case cup
  case cve
  case czk
  case djf
  case dkk
  case dop
  case dzd
  case egp
  case ern
  case etb
  case eur
  case fjd
  case fkp
  case gbp
  case gel
  case ghs
  case gip
  case gmd
  case gnf
  case gtq
  case gyd
  case hkd
  case hnl
  case hrk
  case htg
  case huf
  case idr
  case ils
  case inr
  case iqd
  case irr
  case isk
  case jmd
  case jod
  case jpy
  case kes
  case kgs
  case khr
  case kmf
  case kpw
  case krw
  case kwd
  case kyd
  case kzt
  case lak
  case lbp
  case lkr
  case lrd
  case lsl
  case ltl
  case lyd
  case mad
  case mdl
  case mga
  case mkd
  case mmk
  case mnt
  case mop
  case mro
  case mru
  case mur
  case mvr
  case mwk
  case mxn
  case mxv
  case myr
  case mzn
  case nad
  case ngn
  case nio
  case nok
  case npr
  case nzd
  case omr
  case pab
  case pen
  case pgk
  case php
  case pkr
  case pln
  case pyg
  case qar
  case ron
  case rsd
  case rub
  case rur
  case rwf
  case sar
  case sbd
  case scr
  case sdg
  case sek
  case sgd
  case shp
  case sll
  case sos
  case srd
  case ssp
  case std
  case stn
  case svc
  case syp
  case szl
  case thb
  case tjs
  case tmt
  case tnd
  case top
  case `try`
  case ttd
  case twd
  case tzs
  case uah
  case ugx
  case usd
  case usn
  case uss
  case uyi
  case uyu
  case uzs
  case vef
  case ves
  case vnd
  case vuv
  case wst
  case xaf
  case xag
  case xau
  case xba
  case xbb
  case xbc
  case xbd
  case xcd
  case xdr
  case xof
  case xpd
  case xpf
  case xpt
  case xsu
  case xts
  case xua
  case xxx
  case yer
  case zar
  case zmw
  case zwl
  public var countryList: [SKC.CountryCode] {
    get
  }
  public var currencyName: Swift.String {
    get
  }
  public var minorUnit: Swift.Int32 {
    get
  }
  public var name: Swift.String {
    get
  }
  public var numeric: Swift.Int32 {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CurrencyCode.Companion {
    get
  }
  public func isFund() -> Swift.Bool
  public func isPreciousMetal() -> Swift.Bool
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CurrencyCode, result: inout SKC.CurrencyCode?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CurrencyCode, result: inout SKC.CurrencyCode?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CurrencyCode?) -> SKC.CurrencyCode
  public func _bridgeToObjectiveC() -> SKC.__CurrencyCode
  public typealias _ObjectiveCType = SKC.__CurrencyCode
  public typealias Companion = SKC.__CurrencyCode.Companion
  public static func == (a: SKC.CurrencyCode, b: SKC.CurrencyCode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CurrencyCode]
  nonisolated public static var allCases: [SKC.CurrencyCode] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CurrencyCode {
  public func toKotlinEnum() -> SKC.__CurrencyCode
}
extension SKC.__CurrencyCode {
  public func toSwiftEnum() -> SKC.CurrencyCode
}
extension SKC.ReaderConfiguration {
  public typealias DomesticDebitPriority = SKC.__Bridge__ReaderConfiguration_DomesticDebitPriority
}
extension SKC.__Bridge__ReaderConfiguration_DomesticDebitPriority {
  public func toKotlinEnum() -> SKC.ReaderConfiguration.__DomesticDebitPriority
}
extension SKC.ReaderConfiguration.__DomesticDebitPriority {
  public func toSwiftEnum() -> SKC.ReaderConfiguration.DomesticDebitPriority
}
@frozen public enum __Bridge__ReaderConfiguration_DomesticDebitPriority : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case standard
  case top
  case bottom
  case off
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public func domesticDebitPriorityOverride(domesticDebitAids: [Swift.String], isOffline: SKC.KotlinBoolean?) -> SKC.ReaderConfiguration.DomesticDebitPriority?
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__DomesticDebitPriority, result: inout SKC.ReaderConfiguration.DomesticDebitPriority?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__DomesticDebitPriority, result: inout SKC.ReaderConfiguration.DomesticDebitPriority?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__DomesticDebitPriority?) -> SKC.__Bridge__ReaderConfiguration_DomesticDebitPriority
  public func _bridgeToObjectiveC() -> SKC.ReaderConfiguration.__DomesticDebitPriority
  public typealias _ObjectiveCType = SKC.ReaderConfiguration.__DomesticDebitPriority
  public static func == (a: SKC.__Bridge__ReaderConfiguration_DomesticDebitPriority, b: SKC.__Bridge__ReaderConfiguration_DomesticDebitPriority) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ReaderConfiguration_DomesticDebitPriority]
  nonisolated public static var allCases: [SKC.__Bridge__ReaderConfiguration_DomesticDebitPriority] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderConfiguration {
  public typealias ReaderType = SKC.__Bridge__ReaderConfiguration_ReaderType
}
extension SKC.__Bridge__ReaderConfiguration_ReaderType {
  public func toKotlinEnum() -> SKC.ReaderConfiguration.__ReaderType
}
extension SKC.ReaderConfiguration.__ReaderType {
  public func toSwiftEnum() -> SKC.ReaderConfiguration.ReaderType
}
@frozen public enum __Bridge__ReaderConfiguration_ReaderType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case magstripe
  case icc
  case nfc
  case manualEntry
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__ReaderType, result: inout SKC.ReaderConfiguration.ReaderType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__ReaderType, result: inout SKC.ReaderConfiguration.ReaderType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__ReaderType?) -> SKC.__Bridge__ReaderConfiguration_ReaderType
  public func _bridgeToObjectiveC() -> SKC.ReaderConfiguration.__ReaderType
  public typealias _ObjectiveCType = SKC.ReaderConfiguration.__ReaderType
  public static func == (a: SKC.__Bridge__ReaderConfiguration_ReaderType, b: SKC.__Bridge__ReaderConfiguration_ReaderType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ReaderConfiguration_ReaderType]
  nonisolated public static var allCases: [SKC.__Bridge__ReaderConfiguration_ReaderType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderConfiguration {
  public typealias ContactlessOnlinePinOption = SKC.__Bridge__ReaderConfiguration_ContactlessOnlinePinOption
}
extension SKC.__Bridge__ReaderConfiguration_ContactlessOnlinePinOption {
  public func toKotlinEnum() -> SKC.ReaderConfiguration.__ContactlessOnlinePinOption
}
extension SKC.ReaderConfiguration.__ContactlessOnlinePinOption {
  public func toSwiftEnum() -> SKC.ReaderConfiguration.ContactlessOnlinePinOption
}
@frozen public enum __Bridge__ReaderConfiguration_ContactlessOnlinePinOption : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case disabled
  case enabled
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__ContactlessOnlinePinOption, result: inout SKC.ReaderConfiguration.ContactlessOnlinePinOption?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__ContactlessOnlinePinOption, result: inout SKC.ReaderConfiguration.ContactlessOnlinePinOption?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__ContactlessOnlinePinOption?) -> SKC.__Bridge__ReaderConfiguration_ContactlessOnlinePinOption
  public func _bridgeToObjectiveC() -> SKC.ReaderConfiguration.__ContactlessOnlinePinOption
  public typealias _ObjectiveCType = SKC.ReaderConfiguration.__ContactlessOnlinePinOption
  public static func == (a: SKC.__Bridge__ReaderConfiguration_ContactlessOnlinePinOption, b: SKC.__Bridge__ReaderConfiguration_ContactlessOnlinePinOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ReaderConfiguration_ContactlessOnlinePinOption]
  nonisolated public static var allCases: [SKC.__Bridge__ReaderConfiguration_ContactlessOnlinePinOption] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderConfiguration {
  public typealias QuickChipOption = SKC.__Bridge__ReaderConfiguration_QuickChipOption
}
extension SKC.__Bridge__ReaderConfiguration_QuickChipOption {
  public func toKotlinEnum() -> SKC.ReaderConfiguration.__QuickChipOption
}
extension SKC.ReaderConfiguration.__QuickChipOption {
  public func toSwiftEnum() -> SKC.ReaderConfiguration.QuickChipOption
}
@frozen public enum __Bridge__ReaderConfiguration_QuickChipOption : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case useEmv
  case useConfig
  case useQuickchip
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__QuickChipOption, result: inout SKC.ReaderConfiguration.QuickChipOption?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__QuickChipOption, result: inout SKC.ReaderConfiguration.QuickChipOption?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__QuickChipOption?) -> SKC.__Bridge__ReaderConfiguration_QuickChipOption
  public func _bridgeToObjectiveC() -> SKC.ReaderConfiguration.__QuickChipOption
  public typealias _ObjectiveCType = SKC.ReaderConfiguration.__QuickChipOption
  public static func == (a: SKC.__Bridge__ReaderConfiguration_QuickChipOption, b: SKC.__Bridge__ReaderConfiguration_QuickChipOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ReaderConfiguration_QuickChipOption]
  nonisolated public static var allCases: [SKC.__Bridge__ReaderConfiguration_QuickChipOption] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderConfiguration {
  public typealias TransactionType = SKC.__Bridge__ReaderConfiguration_TransactionType
}
extension SKC.__Bridge__ReaderConfiguration_TransactionType {
  public func toKotlinEnum() -> SKC.ReaderConfiguration.__TransactionType
}
extension SKC.ReaderConfiguration.__TransactionType {
  public func toSwiftEnum() -> SKC.ReaderConfiguration.TransactionType
}
@frozen public enum __Bridge__ReaderConfiguration_TransactionType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case goods
  case refund
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__TransactionType, result: inout SKC.ReaderConfiguration.TransactionType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__TransactionType, result: inout SKC.ReaderConfiguration.TransactionType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ReaderConfiguration.__TransactionType?) -> SKC.__Bridge__ReaderConfiguration_TransactionType
  public func _bridgeToObjectiveC() -> SKC.ReaderConfiguration.__TransactionType
  public typealias _ObjectiveCType = SKC.ReaderConfiguration.__TransactionType
  public static func == (a: SKC.__Bridge__ReaderConfiguration_TransactionType, b: SKC.__Bridge__ReaderConfiguration_TransactionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ReaderConfiguration_TransactionType]
  nonisolated public static var allCases: [SKC.__Bridge__ReaderConfiguration_TransactionType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum CheckForCardBehavior : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case pollForCardRemoval
  case doNotPoll
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CheckForCardBehavior, result: inout SKC.CheckForCardBehavior?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CheckForCardBehavior, result: inout SKC.CheckForCardBehavior?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CheckForCardBehavior?) -> SKC.CheckForCardBehavior
  public func _bridgeToObjectiveC() -> SKC.__CheckForCardBehavior
  public typealias _ObjectiveCType = SKC.__CheckForCardBehavior
  public static func == (a: SKC.CheckForCardBehavior, b: SKC.CheckForCardBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CheckForCardBehavior]
  nonisolated public static var allCases: [SKC.CheckForCardBehavior] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CheckForCardBehavior {
  public func toKotlinEnum() -> SKC.__CheckForCardBehavior
}
extension SKC.__CheckForCardBehavior {
  public func toSwiftEnum() -> SKC.CheckForCardBehavior
}
extension SKC.TransactionResult {
  public typealias Result = SKC.__Bridge__TransactionResult_Result
}
extension SKC.__Bridge__TransactionResult_Result {
  public func toKotlinEnum() -> SKC.TransactionResult.__Result
}
extension SKC.TransactionResult.__Result {
  public func toSwiftEnum() -> SKC.TransactionResult.Result
}
@frozen public enum __Bridge__TransactionResult_Result : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case approved
  case contactlessLimitExceeded
  case declined
  case terminated
  case timeout
  case canceled
  case emptyCandidateList
  case cardBlocked
  case deviceFailure
  case iccCardRemoved
  case checkMobileDevice
  case insertOrSwipeRequired
  case multipleCardsDetected
  case mobileWalletTooManyTaps
  case cardStillInserted
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public func isFatalError() -> Swift.Bool
  public static func _forceBridgeFromObjectiveC(_ source: SKC.TransactionResult.__Result, result: inout SKC.TransactionResult.Result?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.TransactionResult.__Result, result: inout SKC.TransactionResult.Result?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.TransactionResult.__Result?) -> SKC.__Bridge__TransactionResult_Result
  public func _bridgeToObjectiveC() -> SKC.TransactionResult.__Result
  public typealias _ObjectiveCType = SKC.TransactionResult.__Result
  public static func == (a: SKC.__Bridge__TransactionResult_Result, b: SKC.__Bridge__TransactionResult_Result) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__TransactionResult_Result]
  nonisolated public static var allCases: [SKC.__Bridge__TransactionResult_Result] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum IntermediateTransactionError : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case contactlessLimitExceeded
  case checkMobileDevice
  case multipleCardsDetected
  case badTapRead
  case tooManyTaps
  case cardNotAdmitted
  case invalidTransaction
  case invalidCardNumber
  case systemMalfunction
  case expiredCard
  case transactionNotPermitted
  case invalidFunction
  case invalidCard
  case wrongCard
  case terminalNotPermitted
  case originalAmountIncorrect
  case cardNotReadable
  case authenticationRequired
  case notAcceptedTryAgain
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__IntermediateTransactionError, result: inout SKC.IntermediateTransactionError?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__IntermediateTransactionError, result: inout SKC.IntermediateTransactionError?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__IntermediateTransactionError?) -> SKC.IntermediateTransactionError
  public func _bridgeToObjectiveC() -> SKC.__IntermediateTransactionError
  public typealias _ObjectiveCType = SKC.__IntermediateTransactionError
  public static func == (a: SKC.IntermediateTransactionError, b: SKC.IntermediateTransactionError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.IntermediateTransactionError]
  nonisolated public static var allCases: [SKC.IntermediateTransactionError] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.IntermediateTransactionError {
  public func toKotlinEnum() -> SKC.__IntermediateTransactionError
}
extension SKC.__IntermediateTransactionError {
  public func toSwiftEnum() -> SKC.IntermediateTransactionError
}
extension SKC.AccessiblePinPadTouchEvent {
  public typealias Type_ = SKC.__Bridge__AccessiblePinPadTouchEvent_Type_
}
extension SKC.__Bridge__AccessiblePinPadTouchEvent_Type_ {
  public func toKotlinEnum() -> SKC.AccessiblePinPadTouchEvent.__Type_
}
extension SKC.AccessiblePinPadTouchEvent.__Type_ {
  public func toSwiftEnum() -> SKC.AccessiblePinPadTouchEvent.Type_
}
@frozen public enum __Bridge__AccessiblePinPadTouchEvent_Type_ : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case pinPadTouchEventUnknown
  case outOfPinPad
  case newKeyDetected
  case backspaceKeyDetected
  case clearKeyDetected
  case cancelKeyDetected
  case enterKeyDetected
  case enterKeyDetectedIncorrectPinLength
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.AccessiblePinPadTouchEvent.__Type_, result: inout SKC.AccessiblePinPadTouchEvent.Type_?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.AccessiblePinPadTouchEvent.__Type_, result: inout SKC.AccessiblePinPadTouchEvent.Type_?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.AccessiblePinPadTouchEvent.__Type_?) -> SKC.__Bridge__AccessiblePinPadTouchEvent_Type_
  public func _bridgeToObjectiveC() -> SKC.AccessiblePinPadTouchEvent.__Type_
  public typealias _ObjectiveCType = SKC.AccessiblePinPadTouchEvent.__Type_
  public static func == (a: SKC.__Bridge__AccessiblePinPadTouchEvent_Type_, b: SKC.__Bridge__AccessiblePinPadTouchEvent_Type_) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__AccessiblePinPadTouchEvent_Type_]
  nonisolated public static var allCases: [SKC.__Bridge__AccessiblePinPadTouchEvent_Type_] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum PinEntryRetryReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case wrongPinLength
  case incorrectPin
  case cardError
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PinEntryRetryReason, result: inout SKC.PinEntryRetryReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PinEntryRetryReason, result: inout SKC.PinEntryRetryReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PinEntryRetryReason?) -> SKC.PinEntryRetryReason
  public func _bridgeToObjectiveC() -> SKC.__PinEntryRetryReason
  public typealias _ObjectiveCType = SKC.__PinEntryRetryReason
  public static func == (a: SKC.PinEntryRetryReason, b: SKC.PinEntryRetryReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PinEntryRetryReason]
  nonisolated public static var allCases: [SKC.PinEntryRetryReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PinEntryRetryReason {
  public func toKotlinEnum() -> SKC.__PinEntryRetryReason
}
extension SKC.__PinEntryRetryReason {
  public func toSwiftEnum() -> SKC.PinEntryRetryReason
}
@frozen public enum PinEntryStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case notRequested
  case requested
  case entered
  case success
  case cancel
  case timeout
  case bypass
  case wrongPinLength
  case incorrectPin
  case iccRemoved
  case cardError
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public func toFailureReason() -> SKC.PinEntryFailureReason?
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PinEntryStatus, result: inout SKC.PinEntryStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PinEntryStatus, result: inout SKC.PinEntryStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PinEntryStatus?) -> SKC.PinEntryStatus
  public func _bridgeToObjectiveC() -> SKC.__PinEntryStatus
  public typealias _ObjectiveCType = SKC.__PinEntryStatus
  public static func == (a: SKC.PinEntryStatus, b: SKC.PinEntryStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PinEntryStatus]
  nonisolated public static var allCases: [SKC.PinEntryStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PinEntryStatus {
  public func toKotlinEnum() -> SKC.__PinEntryStatus
}
extension SKC.__PinEntryStatus {
  public func toSwiftEnum() -> SKC.PinEntryStatus
}
extension SKC.ApplicationSelectionModel {
  public typealias ApplicationSelectionRetryReason = SKC.__Bridge__ApplicationSelectionModel_ApplicationSelectionRetryReason
}
extension SKC.__Bridge__ApplicationSelectionModel_ApplicationSelectionRetryReason {
  public func toKotlinEnum() -> SKC.ApplicationSelectionModel.__ApplicationSelectionRetryReason
}
extension SKC.ApplicationSelectionModel.__ApplicationSelectionRetryReason {
  public func toSwiftEnum() -> SKC.ApplicationSelectionModel.ApplicationSelectionRetryReason
}
@frozen public enum __Bridge__ApplicationSelectionModel_ApplicationSelectionRetryReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case notAccepted
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ApplicationSelectionModel.__ApplicationSelectionRetryReason, result: inout SKC.ApplicationSelectionModel.ApplicationSelectionRetryReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ApplicationSelectionModel.__ApplicationSelectionRetryReason, result: inout SKC.ApplicationSelectionModel.ApplicationSelectionRetryReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ApplicationSelectionModel.__ApplicationSelectionRetryReason?) -> SKC.__Bridge__ApplicationSelectionModel_ApplicationSelectionRetryReason
  public func _bridgeToObjectiveC() -> SKC.ApplicationSelectionModel.__ApplicationSelectionRetryReason
  public typealias _ObjectiveCType = SKC.ApplicationSelectionModel.__ApplicationSelectionRetryReason
  public static func == (a: SKC.__Bridge__ApplicationSelectionModel_ApplicationSelectionRetryReason, b: SKC.__Bridge__ApplicationSelectionModel_ApplicationSelectionRetryReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ApplicationSelectionModel_ApplicationSelectionRetryReason]
  nonisolated public static var allCases: [SKC.__Bridge__ApplicationSelectionModel_ApplicationSelectionRetryReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum ContactCardSlotState : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case empty
  case cardInsertedIncorrectly
  case cardInsertedCorrectly
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ContactCardSlotState, result: inout SKC.ContactCardSlotState?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ContactCardSlotState, result: inout SKC.ContactCardSlotState?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ContactCardSlotState?) -> SKC.ContactCardSlotState
  public func _bridgeToObjectiveC() -> SKC.__ContactCardSlotState
  public typealias _ObjectiveCType = SKC.__ContactCardSlotState
  public static func == (a: SKC.ContactCardSlotState, b: SKC.ContactCardSlotState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ContactCardSlotState]
  nonisolated public static var allCases: [SKC.ContactCardSlotState] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ContactCardSlotState {
  public func toKotlinEnum() -> SKC.__ContactCardSlotState
}
extension SKC.__ContactCardSlotState {
  public func toSwiftEnum() -> SKC.ContactCardSlotState
}
@frozen public enum EmvTransactionType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case quick
  case traditional
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public func toEmvProcessingMethod() -> Swift.String
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__EmvTransactionType, result: inout SKC.EmvTransactionType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__EmvTransactionType, result: inout SKC.EmvTransactionType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__EmvTransactionType?) -> SKC.EmvTransactionType
  public func _bridgeToObjectiveC() -> SKC.__EmvTransactionType
  public typealias _ObjectiveCType = SKC.__EmvTransactionType
  public static func == (a: SKC.EmvTransactionType, b: SKC.EmvTransactionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.EmvTransactionType]
  nonisolated public static var allCases: [SKC.EmvTransactionType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.EmvTransactionType {
  public func toKotlinEnum() -> SKC.__EmvTransactionType
}
extension SKC.__EmvTransactionType {
  public func toSwiftEnum() -> SKC.EmvTransactionType
}
@frozen public enum TransactionType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case charge
  case refund
  case setup
  case reusableCard
  case strongCustomerAuthentication
  case magstripePassthrough
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__TransactionType, result: inout SKC.TransactionType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__TransactionType, result: inout SKC.TransactionType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__TransactionType?) -> SKC.TransactionType
  public func _bridgeToObjectiveC() -> SKC.__TransactionType
  public typealias _ObjectiveCType = SKC.__TransactionType
  public static func == (a: SKC.TransactionType, b: SKC.TransactionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.TransactionType]
  nonisolated public static var allCases: [SKC.TransactionType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.TransactionType {
  public func toKotlinEnum() -> SKC.__TransactionType
}
extension SKC.__TransactionType {
  public func toSwiftEnum() -> SKC.TransactionType
}
@frozen public enum PaymentCollectionResultType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case success
  case cancelled
  case deviceFailure
  case deviceDeclined
  case onlineConfirmationDeclined
  case onlineConfirmationUnknownFailure
  case scaNeeded
  case timeout
  case notFinished
  case collectPaymentMethodApiError
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PaymentCollectionResultType, result: inout SKC.PaymentCollectionResultType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentCollectionResultType, result: inout SKC.PaymentCollectionResultType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentCollectionResultType?) -> SKC.PaymentCollectionResultType
  public func _bridgeToObjectiveC() -> SKC.__PaymentCollectionResultType
  public typealias _ObjectiveCType = SKC.__PaymentCollectionResultType
  public static func == (a: SKC.PaymentCollectionResultType, b: SKC.PaymentCollectionResultType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PaymentCollectionResultType]
  nonisolated public static var allCases: [SKC.PaymentCollectionResultType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PaymentCollectionResultType {
  public func toKotlinEnum() -> SKC.__PaymentCollectionResultType
}
extension SKC.__PaymentCollectionResultType {
  public func toSwiftEnum() -> SKC.PaymentCollectionResultType
}
@frozen public enum TippingSelectionFailureReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case merchantCancelled
  case hardwareCancelled
  case customerCancelled
  case tipSelectionTypeNotFound
  case callbackNoTipAmount
  case callbackNoData
  case timeout
  case invalidAmount
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__TippingSelectionFailureReason, result: inout SKC.TippingSelectionFailureReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__TippingSelectionFailureReason, result: inout SKC.TippingSelectionFailureReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__TippingSelectionFailureReason?) -> SKC.TippingSelectionFailureReason
  public func _bridgeToObjectiveC() -> SKC.__TippingSelectionFailureReason
  public typealias _ObjectiveCType = SKC.__TippingSelectionFailureReason
  public static func == (a: SKC.TippingSelectionFailureReason, b: SKC.TippingSelectionFailureReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.TippingSelectionFailureReason]
  nonisolated public static var allCases: [SKC.TippingSelectionFailureReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.TippingSelectionFailureReason {
  public func toKotlinEnum() -> SKC.__TippingSelectionFailureReason
}
extension SKC.__TippingSelectionFailureReason {
  public func toSwiftEnum() -> SKC.TippingSelectionFailureReason
}
@frozen public enum TippingSelectionType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case selectedPercentage
  case selectedPercentageSmartTip
  case selectedFixed
  case selectedFixedSmartTip
  case customized
  case noTip
  case noTipSelectionTypeFromBbpos
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__TippingSelectionType, result: inout SKC.TippingSelectionType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__TippingSelectionType, result: inout SKC.TippingSelectionType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__TippingSelectionType?) -> SKC.TippingSelectionType
  public func _bridgeToObjectiveC() -> SKC.__TippingSelectionType
  public typealias _ObjectiveCType = SKC.__TippingSelectionType
  public static func == (a: SKC.TippingSelectionType, b: SKC.TippingSelectionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.TippingSelectionType]
  nonisolated public static var allCases: [SKC.TippingSelectionType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.TippingSelectionType {
  public func toKotlinEnum() -> SKC.__TippingSelectionType
}
extension SKC.__TippingSelectionType {
  public func toSwiftEnum() -> SKC.TippingSelectionType
}
@frozen public enum ManualEntryType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case panEntry
  case expiryDateEntry
  case cvvEntry
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ManualEntryType, result: inout SKC.ManualEntryType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ManualEntryType, result: inout SKC.ManualEntryType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ManualEntryType?) -> SKC.ManualEntryType
  public func _bridgeToObjectiveC() -> SKC.__ManualEntryType
  public typealias _ObjectiveCType = SKC.__ManualEntryType
  public static func == (a: SKC.ManualEntryType, b: SKC.ManualEntryType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ManualEntryType]
  nonisolated public static var allCases: [SKC.ManualEntryType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ManualEntryType {
  public func toKotlinEnum() -> SKC.__ManualEntryType
}
extension SKC.__ManualEntryType {
  public func toSwiftEnum() -> SKC.ManualEntryType
}
@frozen public enum PaymentCollectionTimeoutResultDetails : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case transactionNotProcessed
  case transactionTimedOut
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PaymentCollectionTimeoutResultDetails, result: inout SKC.PaymentCollectionTimeoutResultDetails?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentCollectionTimeoutResultDetails, result: inout SKC.PaymentCollectionTimeoutResultDetails?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PaymentCollectionTimeoutResultDetails?) -> SKC.PaymentCollectionTimeoutResultDetails
  public func _bridgeToObjectiveC() -> SKC.__PaymentCollectionTimeoutResultDetails
  public typealias _ObjectiveCType = SKC.__PaymentCollectionTimeoutResultDetails
  public static func == (a: SKC.PaymentCollectionTimeoutResultDetails, b: SKC.PaymentCollectionTimeoutResultDetails) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PaymentCollectionTimeoutResultDetails]
  nonisolated public static var allCases: [SKC.PaymentCollectionTimeoutResultDetails] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PaymentCollectionTimeoutResultDetails {
  public func toKotlinEnum() -> SKC.__PaymentCollectionTimeoutResultDetails
}
extension SKC.__PaymentCollectionTimeoutResultDetails {
  public func toSwiftEnum() -> SKC.PaymentCollectionTimeoutResultDetails
}
@frozen public enum RecoverableError : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case chipCardMustBeInsertedForSca
  case chipCardInsertedIncorrectly
  case checkMobileDevice
  case contactlessLimitExceeded
  case cardBlocked
  case emptyCandidateList
  case insertOrSwipeRequired
  case multipleCardsDetected
  case declined
  case chipCardSwiped
  case swipeFailed
  case invalidCard
  case badTapRead
  case tooManyTaps
  case cardRemovedTooSoon
  case cardNotAdmitted
  case invalidTransaction
  case invalidCardNumber
  case systemMalfunction
  case expiredCard
  case transactionNotPermitted
  case invalidFunction
  case wrongCard
  case terminalNotPermitted
  case originalAmountIncorrect
  case cardNotReadable
  case authenticationRequired
  case notAcceptedTryAgain
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__RecoverableError.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__RecoverableError, result: inout SKC.RecoverableError?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__RecoverableError, result: inout SKC.RecoverableError?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__RecoverableError?) -> SKC.RecoverableError
  public func _bridgeToObjectiveC() -> SKC.__RecoverableError
  public typealias _ObjectiveCType = SKC.__RecoverableError
  public typealias Companion = SKC.__RecoverableError.Companion
  public static func == (a: SKC.RecoverableError, b: SKC.RecoverableError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.RecoverableError]
  nonisolated public static var allCases: [SKC.RecoverableError] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.RecoverableError {
  public func toKotlinEnum() -> SKC.__RecoverableError
}
extension SKC.__RecoverableError {
  public func toSwiftEnum() -> SKC.RecoverableError
}
@frozen public enum AudioAlertType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case success
  case alert
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__AudioAlertType, result: inout SKC.AudioAlertType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__AudioAlertType, result: inout SKC.AudioAlertType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__AudioAlertType?) -> SKC.AudioAlertType
  public func _bridgeToObjectiveC() -> SKC.__AudioAlertType
  public typealias _ObjectiveCType = SKC.__AudioAlertType
  public static func == (a: SKC.AudioAlertType, b: SKC.AudioAlertType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.AudioAlertType]
  nonisolated public static var allCases: [SKC.AudioAlertType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.AudioAlertType {
  public func toKotlinEnum() -> SKC.__AudioAlertType
}
extension SKC.__AudioAlertType {
  public func toSwiftEnum() -> SKC.AudioAlertType
}
@frozen public enum ReaderDisplayMessage : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case checkMobileDevice
  case retryCard
  case insertCard
  case insertOrSwipeCard
  case swipeCard
  case removeCard
  case multipleContactlessCardsDetected
  case tryAnotherReadMethod
  case tryAnotherCard
  case cardRemovedTooEarly
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ReaderDisplayMessage, result: inout SKC.ReaderDisplayMessage?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderDisplayMessage, result: inout SKC.ReaderDisplayMessage?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderDisplayMessage?) -> SKC.ReaderDisplayMessage
  public func _bridgeToObjectiveC() -> SKC.__ReaderDisplayMessage
  public typealias _ObjectiveCType = SKC.__ReaderDisplayMessage
  public static func == (a: SKC.ReaderDisplayMessage, b: SKC.ReaderDisplayMessage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ReaderDisplayMessage]
  nonisolated public static var allCases: [SKC.ReaderDisplayMessage] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderDisplayMessage {
  public func toKotlinEnum() -> SKC.__ReaderDisplayMessage
}
extension SKC.__ReaderDisplayMessage {
  public func toSwiftEnum() -> SKC.ReaderDisplayMessage
}
@frozen public enum DispositionCanceledReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case userCanceled
  case timedOut
  case reset
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__DispositionCanceledReason, result: inout SKC.DispositionCanceledReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__DispositionCanceledReason, result: inout SKC.DispositionCanceledReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__DispositionCanceledReason?) -> SKC.DispositionCanceledReason
  public func _bridgeToObjectiveC() -> SKC.__DispositionCanceledReason
  public typealias _ObjectiveCType = SKC.__DispositionCanceledReason
  public static func == (a: SKC.DispositionCanceledReason, b: SKC.DispositionCanceledReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.DispositionCanceledReason]
  nonisolated public static var allCases: [SKC.DispositionCanceledReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.DispositionCanceledReason {
  public func toKotlinEnum() -> SKC.__DispositionCanceledReason
}
extension SKC.__DispositionCanceledReason {
  public func toSwiftEnum() -> SKC.DispositionCanceledReason
}
@frozen public enum DisclosureMode : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case setupFutureUsage
  case incremental
  case extended
  case incrementalAndExtended
  case setupAndIncrementalAndExtended
  case none
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__DisclosureMode.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__DisclosureMode, result: inout SKC.DisclosureMode?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__DisclosureMode, result: inout SKC.DisclosureMode?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__DisclosureMode?) -> SKC.DisclosureMode
  public func _bridgeToObjectiveC() -> SKC.__DisclosureMode
  public typealias _ObjectiveCType = SKC.__DisclosureMode
  public typealias Companion = SKC.__DisclosureMode.Companion
  public static func == (a: SKC.DisclosureMode, b: SKC.DisclosureMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.DisclosureMode]
  nonisolated public static var allCases: [SKC.DisclosureMode] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.DisclosureMode {
  public func toKotlinEnum() -> SKC.__DisclosureMode
}
extension SKC.__DisclosureMode {
  public func toSwiftEnum() -> SKC.DisclosureMode
}
@frozen public enum CancellationPhase : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case collection
  case auth
  case accountTypeSelection
  case applicationSelection
  case pin
  case finalConfirmation
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CancellationPhase, result: inout SKC.CancellationPhase?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CancellationPhase, result: inout SKC.CancellationPhase?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CancellationPhase?) -> SKC.CancellationPhase
  public func _bridgeToObjectiveC() -> SKC.__CancellationPhase
  public typealias _ObjectiveCType = SKC.__CancellationPhase
  public static func == (a: SKC.CancellationPhase, b: SKC.CancellationPhase) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CancellationPhase]
  nonisolated public static var allCases: [SKC.CancellationPhase] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CancellationPhase {
  public func toKotlinEnum() -> SKC.__CancellationPhase
}
extension SKC.__CancellationPhase {
  public func toSwiftEnum() -> SKC.CancellationPhase
}
extension SKC.Confirmation {
  public typealias PinError = SKC.__Bridge__Confirmation_PinError
}
extension SKC.__Bridge__Confirmation_PinError {
  public func toKotlinEnum() -> SKC.Confirmation.__PinError
}
extension SKC.Confirmation.__PinError {
  public func toSwiftEnum() -> SKC.Confirmation.PinError
}
@frozen public enum __Bridge__Confirmation_PinError : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case wrongLength
  case incorrect
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.Confirmation.__PinError, result: inout SKC.Confirmation.PinError?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.Confirmation.__PinError, result: inout SKC.Confirmation.PinError?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.Confirmation.__PinError?) -> SKC.__Bridge__Confirmation_PinError
  public func _bridgeToObjectiveC() -> SKC.Confirmation.__PinError
  public typealias _ObjectiveCType = SKC.Confirmation.__PinError
  public static func == (a: SKC.__Bridge__Confirmation_PinError, b: SKC.__Bridge__Confirmation_PinError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__Confirmation_PinError]
  nonisolated public static var allCases: [SKC.__Bridge__Confirmation_PinError] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum CardStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case noCard
  case cardProcessing
  case cardIdle
  case cardNotWorking
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CardStatus, result: inout SKC.CardStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CardStatus, result: inout SKC.CardStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CardStatus?) -> SKC.CardStatus
  public func _bridgeToObjectiveC() -> SKC.__CardStatus
  public typealias _ObjectiveCType = SKC.__CardStatus
  public static func == (a: SKC.CardStatus, b: SKC.CardStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CardStatus]
  nonisolated public static var allCases: [SKC.CardStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CardStatus {
  public func toKotlinEnum() -> SKC.__CardStatus
}
extension SKC.__CardStatus {
  public func toSwiftEnum() -> SKC.CardStatus
}
@frozen public enum Phase : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case none
  case accountTypeSelection
  case applicationSelection
  case pin
  case finalConfirmation
  case auth
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__Phase, result: inout SKC.Phase?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__Phase, result: inout SKC.Phase?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__Phase?) -> SKC.Phase
  public func _bridgeToObjectiveC() -> SKC.__Phase
  public typealias _ObjectiveCType = SKC.__Phase
  public static func == (a: SKC.Phase, b: SKC.Phase) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.Phase]
  nonisolated public static var allCases: [SKC.Phase] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.Phase {
  public func toKotlinEnum() -> SKC.__Phase
}
extension SKC.__Phase {
  public func toSwiftEnum() -> SKC.Phase
}
@frozen public enum BbposErrorMode : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case key
  case config
  case firmware
  case unrecoverableTamper
  case unknown
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__BbposErrorMode.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__BbposErrorMode, result: inout SKC.BbposErrorMode?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__BbposErrorMode, result: inout SKC.BbposErrorMode?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__BbposErrorMode?) -> SKC.BbposErrorMode
  public func _bridgeToObjectiveC() -> SKC.__BbposErrorMode
  public typealias _ObjectiveCType = SKC.__BbposErrorMode
  public typealias Companion = SKC.__BbposErrorMode.Companion
  public static func == (a: SKC.BbposErrorMode, b: SKC.BbposErrorMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.BbposErrorMode]
  nonisolated public static var allCases: [SKC.BbposErrorMode] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.BbposErrorMode {
  public func toKotlinEnum() -> SKC.__BbposErrorMode
}
extension SKC.__BbposErrorMode {
  public func toSwiftEnum() -> SKC.BbposErrorMode
}
@frozen public enum TamperType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case firmwareIntegrityCheck
  case configIntegrityCheck
  case keyIntegrityCheck
  case unrecoverableTamper
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__TamperType, result: inout SKC.TamperType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__TamperType, result: inout SKC.TamperType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__TamperType?) -> SKC.TamperType
  public func _bridgeToObjectiveC() -> SKC.__TamperType
  public typealias _ObjectiveCType = SKC.__TamperType
  public static func == (a: SKC.TamperType, b: SKC.TamperType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.TamperType]
  nonisolated public static var allCases: [SKC.TamperType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.TamperType {
  public func toKotlinEnum() -> SKC.__TamperType
}
extension SKC.__TamperType {
  public func toSwiftEnum() -> SKC.TamperType
}
@frozen public enum CancellationType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case cancelWhileIdle
  case cancelDuringOperation
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CancellationType, result: inout SKC.CancellationType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CancellationType, result: inout SKC.CancellationType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CancellationType?) -> SKC.CancellationType
  public func _bridgeToObjectiveC() -> SKC.__CancellationType
  public typealias _ObjectiveCType = SKC.__CancellationType
  public static func == (a: SKC.CancellationType, b: SKC.CancellationType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CancellationType]
  nonisolated public static var allCases: [SKC.CancellationType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CancellationType {
  public func toKotlinEnum() -> SKC.__CancellationType
}
extension SKC.__CancellationType {
  public func toSwiftEnum() -> SKC.CancellationType
}
@frozen public enum DisconnectCause : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case commLinkUninitialized
  case connectedToAnotherDevice
  case failToStartBluetooth
  case failToStartUsb
  case usbDeviceNotFound
  case usbDevicePermissionDenied
  case usbNotSupported
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__DisconnectCause, result: inout SKC.DisconnectCause?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__DisconnectCause, result: inout SKC.DisconnectCause?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__DisconnectCause?) -> SKC.DisconnectCause
  public func _bridgeToObjectiveC() -> SKC.__DisconnectCause
  public typealias _ObjectiveCType = SKC.__DisconnectCause
  public static func == (a: SKC.DisconnectCause, b: SKC.DisconnectCause) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.DisconnectCause]
  nonisolated public static var allCases: [SKC.DisconnectCause] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.DisconnectCause {
  public func toKotlinEnum() -> SKC.__DisconnectCause
}
extension SKC.__DisconnectCause {
  public func toSwiftEnum() -> SKC.DisconnectCause
}
@frozen public enum ReaderBatteryStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case low
  case criticallyLow
  case charging
  case notCharging
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ReaderBatteryStatus, result: inout SKC.ReaderBatteryStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderBatteryStatus, result: inout SKC.ReaderBatteryStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderBatteryStatus?) -> SKC.ReaderBatteryStatus
  public func _bridgeToObjectiveC() -> SKC.__ReaderBatteryStatus
  public typealias _ObjectiveCType = SKC.__ReaderBatteryStatus
  public static func == (a: SKC.ReaderBatteryStatus, b: SKC.ReaderBatteryStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ReaderBatteryStatus]
  nonisolated public static var allCases: [SKC.ReaderBatteryStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderBatteryStatus {
  public func toKotlinEnum() -> SKC.__ReaderBatteryStatus
}
extension SKC.__ReaderBatteryStatus {
  public func toSwiftEnum() -> SKC.ReaderBatteryStatus
}
@frozen public enum ReaderEvent : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case cardInserted
  case cardRemoved
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ReaderEvent, result: inout SKC.ReaderEvent?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderEvent, result: inout SKC.ReaderEvent?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderEvent?) -> SKC.ReaderEvent
  public func _bridgeToObjectiveC() -> SKC.__ReaderEvent
  public typealias _ObjectiveCType = SKC.__ReaderEvent
  public static func == (a: SKC.ReaderEvent, b: SKC.ReaderEvent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ReaderEvent]
  nonisolated public static var allCases: [SKC.ReaderEvent] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderEvent {
  public func toKotlinEnum() -> SKC.__ReaderEvent
}
extension SKC.__ReaderEvent {
  public func toSwiftEnum() -> SKC.ReaderEvent
}
extension SKC.ReaderInputOptions {
  public typealias ReaderInputOption = SKC.__Bridge__ReaderInputOptions_ReaderInputOption
}
extension SKC.__Bridge__ReaderInputOptions_ReaderInputOption {
  public func toKotlinEnum() -> SKC.ReaderInputOptions.__ReaderInputOption
}
extension SKC.ReaderInputOptions.__ReaderInputOption {
  public func toSwiftEnum() -> SKC.ReaderInputOptions.ReaderInputOption
}
@frozen public enum __Bridge__ReaderInputOptions_ReaderInputOption : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case none
  case insert
  case swipe
  case tap
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.ReaderInputOptions.__ReaderInputOption, result: inout SKC.ReaderInputOptions.ReaderInputOption?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.ReaderInputOptions.__ReaderInputOption, result: inout SKC.ReaderInputOptions.ReaderInputOption?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.ReaderInputOptions.__ReaderInputOption?) -> SKC.__Bridge__ReaderInputOptions_ReaderInputOption
  public func _bridgeToObjectiveC() -> SKC.ReaderInputOptions.__ReaderInputOption
  public typealias _ObjectiveCType = SKC.ReaderInputOptions.__ReaderInputOption
  public static func == (a: SKC.__Bridge__ReaderInputOptions_ReaderInputOption, b: SKC.__Bridge__ReaderInputOptions_ReaderInputOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__ReaderInputOptions_ReaderInputOption]
  nonisolated public static var allCases: [SKC.__Bridge__ReaderInputOptions_ReaderInputOption] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum ReaderPowerEvent : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case powerButtonPressed
  case powerDown
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ReaderPowerEvent, result: inout SKC.ReaderPowerEvent?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderPowerEvent, result: inout SKC.ReaderPowerEvent?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ReaderPowerEvent?) -> SKC.ReaderPowerEvent
  public func _bridgeToObjectiveC() -> SKC.__ReaderPowerEvent
  public typealias _ObjectiveCType = SKC.__ReaderPowerEvent
  public static func == (a: SKC.ReaderPowerEvent, b: SKC.ReaderPowerEvent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ReaderPowerEvent]
  nonisolated public static var allCases: [SKC.ReaderPowerEvent] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ReaderPowerEvent {
  public func toKotlinEnum() -> SKC.__ReaderPowerEvent
}
extension SKC.__ReaderPowerEvent {
  public func toSwiftEnum() -> SKC.ReaderPowerEvent
}
@frozen public enum RebootCause : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case sdkRequestedReboot
  case firmwareSelfTest
  case recoveryAttempt
  case watchdogTimeout
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__RebootCause, result: inout SKC.RebootCause?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__RebootCause, result: inout SKC.RebootCause?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__RebootCause?) -> SKC.RebootCause
  public func _bridgeToObjectiveC() -> SKC.__RebootCause
  public typealias _ObjectiveCType = SKC.__RebootCause
  public static func == (a: SKC.RebootCause, b: SKC.RebootCause) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.RebootCause]
  nonisolated public static var allCases: [SKC.RebootCause] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.RebootCause {
  public func toKotlinEnum() -> SKC.__RebootCause
}
extension SKC.__RebootCause {
  public func toSwiftEnum() -> SKC.RebootCause
}
extension SKC.InvalidTipConfig {
  public typealias Reason = SKC.__Bridge__InvalidTipConfig_Reason
}
extension SKC.__Bridge__InvalidTipConfig_Reason {
  public func toKotlinEnum() -> SKC.InvalidTipConfig.__Reason
}
extension SKC.InvalidTipConfig.__Reason {
  public func toSwiftEnum() -> SKC.InvalidTipConfig.Reason
}
@frozen public enum __Bridge__InvalidTipConfig_Reason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case threeTipOptionsExpected
  case tipOutOfBounds
  case nullTipConfig
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.InvalidTipConfig.__Reason, result: inout SKC.InvalidTipConfig.Reason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.InvalidTipConfig.__Reason, result: inout SKC.InvalidTipConfig.Reason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.InvalidTipConfig.__Reason?) -> SKC.__Bridge__InvalidTipConfig_Reason
  public func _bridgeToObjectiveC() -> SKC.InvalidTipConfig.__Reason
  public typealias _ObjectiveCType = SKC.InvalidTipConfig.__Reason
  public static func == (a: SKC.__Bridge__InvalidTipConfig_Reason, b: SKC.__Bridge__InvalidTipConfig_Reason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__InvalidTipConfig_Reason]
  nonisolated public static var allCases: [SKC.__Bridge__InvalidTipConfig_Reason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum IntegrationType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case localPos
  case serverDriven
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__IntegrationType, result: inout SKC.IntegrationType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__IntegrationType, result: inout SKC.IntegrationType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__IntegrationType?) -> SKC.IntegrationType
  public func _bridgeToObjectiveC() -> SKC.__IntegrationType
  public typealias _ObjectiveCType = SKC.__IntegrationType
  public static func == (a: SKC.IntegrationType, b: SKC.IntegrationType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.IntegrationType]
  nonisolated public static var allCases: [SKC.IntegrationType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.IntegrationType {
  public func toKotlinEnum() -> SKC.__IntegrationType
}
extension SKC.__IntegrationType {
  public func toSwiftEnum() -> SKC.IntegrationType
}
@frozen public enum TransactionOpType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case activation
  case confirmPaymentIntent
  case confirmInteracRefund
  case confirmSetupIntent
  case confirmReusableCard
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__TransactionOpType, result: inout SKC.TransactionOpType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__TransactionOpType, result: inout SKC.TransactionOpType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__TransactionOpType?) -> SKC.TransactionOpType
  public func _bridgeToObjectiveC() -> SKC.__TransactionOpType
  public typealias _ObjectiveCType = SKC.__TransactionOpType
  public static func == (a: SKC.TransactionOpType, b: SKC.TransactionOpType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.TransactionOpType]
  nonisolated public static var allCases: [SKC.TransactionOpType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.TransactionOpType {
  public func toKotlinEnum() -> SKC.__TransactionOpType
}
extension SKC.__TransactionOpType {
  public func toSwiftEnum() -> SKC.TransactionOpType
}
@frozen public enum MagStripePaymentCollectionAuthority : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case nonIcc
  case technicalFallback
  case emptyCandidateListFallback
  case passthrough
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__MagStripePaymentCollectionAuthority, result: inout SKC.MagStripePaymentCollectionAuthority?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__MagStripePaymentCollectionAuthority, result: inout SKC.MagStripePaymentCollectionAuthority?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__MagStripePaymentCollectionAuthority?) -> SKC.MagStripePaymentCollectionAuthority
  public func _bridgeToObjectiveC() -> SKC.__MagStripePaymentCollectionAuthority
  public typealias _ObjectiveCType = SKC.__MagStripePaymentCollectionAuthority
  public static func == (a: SKC.MagStripePaymentCollectionAuthority, b: SKC.MagStripePaymentCollectionAuthority) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.MagStripePaymentCollectionAuthority]
  nonisolated public static var allCases: [SKC.MagStripePaymentCollectionAuthority] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.MagStripePaymentCollectionAuthority {
  public func toKotlinEnum() -> SKC.__MagStripePaymentCollectionAuthority
}
extension SKC.__MagStripePaymentCollectionAuthority {
  public func toSwiftEnum() -> SKC.MagStripePaymentCollectionAuthority
}
extension SKC.MagStripeReadFailure {
  public typealias FailureType = SKC.__Bridge__MagStripeReadFailure_FailureType
}
extension SKC.__Bridge__MagStripeReadFailure_FailureType {
  public func toKotlinEnum() -> SKC.MagStripeReadFailure.__FailureType
}
extension SKC.MagStripeReadFailure.__FailureType {
  public func toSwiftEnum() -> SKC.MagStripeReadFailure.FailureType
}
@frozen public enum __Bridge__MagStripeReadFailure_FailureType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case badSwipe
  case msrFailure
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.MagStripeReadFailure.__FailureType, result: inout SKC.MagStripeReadFailure.FailureType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.MagStripeReadFailure.__FailureType, result: inout SKC.MagStripeReadFailure.FailureType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.MagStripeReadFailure.__FailureType?) -> SKC.__Bridge__MagStripeReadFailure_FailureType
  public func _bridgeToObjectiveC() -> SKC.MagStripeReadFailure.__FailureType
  public typealias _ObjectiveCType = SKC.MagStripeReadFailure.__FailureType
  public static func == (a: SKC.__Bridge__MagStripeReadFailure_FailureType, b: SKC.__Bridge__MagStripeReadFailure_FailureType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__MagStripeReadFailure_FailureType]
  nonisolated public static var allCases: [SKC.__Bridge__MagStripeReadFailure_FailureType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum AccountType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case `default`
  case savings
  case checking
  case credit
  public var emvValue: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__AccountType.Companion {
    get
  }
  public func toTlvBlob() -> Swift.String
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__AccountType, result: inout SKC.AccountType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__AccountType, result: inout SKC.AccountType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__AccountType?) -> SKC.AccountType
  public func _bridgeToObjectiveC() -> SKC.__AccountType
  public typealias _ObjectiveCType = SKC.__AccountType
  public typealias Companion = SKC.__AccountType.Companion
  public static func == (a: SKC.AccountType, b: SKC.AccountType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.AccountType]
  nonisolated public static var allCases: [SKC.AccountType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.AccountType {
  public func toKotlinEnum() -> SKC.__AccountType
}
extension SKC.__AccountType {
  public func toSwiftEnum() -> SKC.AccountType
}
@frozen public enum InterfaceType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case contact
  case contactless
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__InterfaceType, result: inout SKC.InterfaceType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__InterfaceType, result: inout SKC.InterfaceType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__InterfaceType?) -> SKC.InterfaceType
  public func _bridgeToObjectiveC() -> SKC.__InterfaceType
  public typealias _ObjectiveCType = SKC.__InterfaceType
  public static func == (a: SKC.InterfaceType, b: SKC.InterfaceType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.InterfaceType]
  nonisolated public static var allCases: [SKC.InterfaceType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.InterfaceType {
  public func toKotlinEnum() -> SKC.__InterfaceType
}
extension SKC.__InterfaceType {
  public func toSwiftEnum() -> SKC.InterfaceType
}
@frozen public enum SourceType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case cardPresent
  case interacPresent
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__SourceType, result: inout SKC.SourceType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__SourceType, result: inout SKC.SourceType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__SourceType?) -> SKC.SourceType
  public func _bridgeToObjectiveC() -> SKC.__SourceType
  public typealias _ObjectiveCType = SKC.__SourceType
  public static func == (a: SKC.SourceType, b: SKC.SourceType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.SourceType]
  nonisolated public static var allCases: [SKC.SourceType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.SourceType {
  public func toKotlinEnum() -> SKC.__SourceType
}
extension SKC.__SourceType {
  public func toSwiftEnum() -> SKC.SourceType
}
@frozen public enum ApplicationId : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case visaCredit
  case visaElectron
  case visaUsCommonDebit
  case mastercardCredit
  case amexCredit
  case interac
  case eftposSaving
  case eftposChecking
  case girocard
  case jcb
  case discover
  case discoverZip
  case unionPay
  case unionPayQuasi
  case maestroDebit
  case maestroUs
  public var id: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public func getCardBrandForApplication() -> SKC.PublicCardBrand
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ApplicationId, result: inout SKC.ApplicationId?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ApplicationId, result: inout SKC.ApplicationId?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ApplicationId?) -> SKC.ApplicationId
  public func _bridgeToObjectiveC() -> SKC.__ApplicationId
  public typealias _ObjectiveCType = SKC.__ApplicationId
  public static func == (a: SKC.ApplicationId, b: SKC.ApplicationId) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ApplicationId]
  nonisolated public static var allCases: [SKC.ApplicationId] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ApplicationId {
  public func toKotlinEnum() -> SKC.__ApplicationId
}
extension SKC.__ApplicationId {
  public func toSwiftEnum() -> SKC.ApplicationId
}
@frozen public enum ApplicationPreferredName : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case interac
  case mastercard
  case visa
  case unionPayCredit
  case amex
  case jcb
  case discover
  case eftposSaving
  case visaUsCommonDebit
  public var id: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__ApplicationPreferredName, result: inout SKC.ApplicationPreferredName?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__ApplicationPreferredName, result: inout SKC.ApplicationPreferredName?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__ApplicationPreferredName?) -> SKC.ApplicationPreferredName
  public func _bridgeToObjectiveC() -> SKC.__ApplicationPreferredName
  public typealias _ObjectiveCType = SKC.__ApplicationPreferredName
  public static func == (a: SKC.ApplicationPreferredName, b: SKC.ApplicationPreferredName) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.ApplicationPreferredName]
  nonisolated public static var allCases: [SKC.ApplicationPreferredName] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.ApplicationPreferredName {
  public func toKotlinEnum() -> SKC.__ApplicationPreferredName
}
extension SKC.__ApplicationPreferredName {
  public func toSwiftEnum() -> SKC.ApplicationPreferredName
}
@frozen public enum CvmStatus : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case failure
  case success
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CvmStatus, result: inout SKC.CvmStatus?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CvmStatus, result: inout SKC.CvmStatus?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CvmStatus?) -> SKC.CvmStatus
  public func _bridgeToObjectiveC() -> SKC.__CvmStatus
  public typealias _ObjectiveCType = SKC.__CvmStatus
  public static func == (a: SKC.CvmStatus, b: SKC.CvmStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CvmStatus]
  nonisolated public static var allCases: [SKC.CvmStatus] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CvmStatus {
  public func toKotlinEnum() -> SKC.__CvmStatus
}
extension SKC.__CvmStatus {
  public func toSwiftEnum() -> SKC.CvmStatus
}
@frozen public enum CvmType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case failure
  case offlinePlaintextPin
  case onlineEncipheredPin
  case offlinePlaintextPinAndSignature
  case offlineEncipheredPin
  case offlineEncipheredPinAndSignature
  case signature
  case approval
  case none
  public var code: Swift.Int32 {
    get
  }
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__CvmType.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__CvmType, result: inout SKC.CvmType?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__CvmType, result: inout SKC.CvmType?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__CvmType?) -> SKC.CvmType
  public func _bridgeToObjectiveC() -> SKC.__CvmType
  public typealias _ObjectiveCType = SKC.__CvmType
  public typealias Companion = SKC.__CvmType.Companion
  public static func == (a: SKC.CvmType, b: SKC.CvmType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.CvmType]
  nonisolated public static var allCases: [SKC.CvmType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.CvmType {
  public func toKotlinEnum() -> SKC.__CvmType
}
extension SKC.__CvmType {
  public func toSwiftEnum() -> SKC.CvmType
}
@frozen public enum TerminalApplicationSelectionIndicator : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case partialMatch
  case exactMatch
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__TerminalApplicationSelectionIndicator.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__TerminalApplicationSelectionIndicator, result: inout SKC.TerminalApplicationSelectionIndicator?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__TerminalApplicationSelectionIndicator, result: inout SKC.TerminalApplicationSelectionIndicator?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__TerminalApplicationSelectionIndicator?) -> SKC.TerminalApplicationSelectionIndicator
  public func _bridgeToObjectiveC() -> SKC.__TerminalApplicationSelectionIndicator
  public typealias _ObjectiveCType = SKC.__TerminalApplicationSelectionIndicator
  public typealias Companion = SKC.__TerminalApplicationSelectionIndicator.Companion
  public static func == (a: SKC.TerminalApplicationSelectionIndicator, b: SKC.TerminalApplicationSelectionIndicator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.TerminalApplicationSelectionIndicator]
  nonisolated public static var allCases: [SKC.TerminalApplicationSelectionIndicator] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.TerminalApplicationSelectionIndicator {
  public func toKotlinEnum() -> SKC.__TerminalApplicationSelectionIndicator
}
extension SKC.__TerminalApplicationSelectionIndicator {
  public func toSwiftEnum() -> SKC.TerminalApplicationSelectionIndicator
}
@frozen public enum TerminalEmvKernelVersionVectorConfiguration : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case none
  case vcInternationalDefault
  case vcUsDefault
  case vcUsSaf
  case vcInternationalSaf
  case vcVerifone8C
  case vcUsNoOnlinePin
  case vcInternationalNoOda
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.TerminalEmvKernelVersionVectorConfigurationCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__TerminalEmvKernelVersionVectorConfiguration, result: inout SKC.TerminalEmvKernelVersionVectorConfiguration?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__TerminalEmvKernelVersionVectorConfiguration, result: inout SKC.TerminalEmvKernelVersionVectorConfiguration?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__TerminalEmvKernelVersionVectorConfiguration?) -> SKC.TerminalEmvKernelVersionVectorConfiguration
  public func _bridgeToObjectiveC() -> SKC.__TerminalEmvKernelVersionVectorConfiguration
  public typealias _ObjectiveCType = SKC.__TerminalEmvKernelVersionVectorConfiguration
  public static func == (a: SKC.TerminalEmvKernelVersionVectorConfiguration, b: SKC.TerminalEmvKernelVersionVectorConfiguration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.TerminalEmvKernelVersionVectorConfiguration]
  nonisolated public static var allCases: [SKC.TerminalEmvKernelVersionVectorConfiguration] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.TerminalEmvKernelVersionVectorConfiguration {
  public func toKotlinEnum() -> SKC.__TerminalEmvKernelVersionVectorConfiguration
}
extension SKC.__TerminalEmvKernelVersionVectorConfiguration {
  public func toSwiftEnum() -> SKC.TerminalEmvKernelVersionVectorConfiguration
}
@frozen public enum TerminalEmvApplicationId : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknownAid
  case aidVisa
  case aidVisaUsCommonDebit
  case aidVisaInterlink
  case aidVisaElectron
  case aidMastercard
  case aidInternationalMaestro
  case aidUsMaestro
  case aidDiscover
  case aidDiscoverUsCommonDebit
  case aidDnaUsCommonDebit
  case aidAmex
  case aidCup
  case aidCupDebit
  case aidJcb
  case aidInterac
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__TerminalEmvApplicationId.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__TerminalEmvApplicationId, result: inout SKC.TerminalEmvApplicationId?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__TerminalEmvApplicationId, result: inout SKC.TerminalEmvApplicationId?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__TerminalEmvApplicationId?) -> SKC.TerminalEmvApplicationId
  public func _bridgeToObjectiveC() -> SKC.__TerminalEmvApplicationId
  public typealias _ObjectiveCType = SKC.__TerminalEmvApplicationId
  public typealias Companion = SKC.__TerminalEmvApplicationId.Companion
  public static func == (a: SKC.TerminalEmvApplicationId, b: SKC.TerminalEmvApplicationId) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.TerminalEmvApplicationId]
  nonisolated public static var allCases: [SKC.TerminalEmvApplicationId] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.TerminalEmvApplicationId {
  public func toKotlinEnum() -> SKC.__TerminalEmvApplicationId
}
extension SKC.__TerminalEmvApplicationId {
  public func toSwiftEnum() -> SKC.TerminalEmvApplicationId
}
extension SKC.TerminalDeviceTraceLevel {
  public typealias TraceLevel = SKC.__Bridge__TerminalDeviceTraceLevel_TraceLevel
}
extension SKC.__Bridge__TerminalDeviceTraceLevel_TraceLevel {
  public func toKotlinEnum() -> SKC.TerminalDeviceTraceLevel.__TraceLevel
}
extension SKC.TerminalDeviceTraceLevel.__TraceLevel {
  public func toSwiftEnum() -> SKC.TerminalDeviceTraceLevel.TraceLevel
}
@frozen public enum __Bridge__TerminalDeviceTraceLevel_TraceLevel : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case unknown
  case levelNone
  case levelError
  case levelLite
  case levelAll
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.TerminalDeviceTraceLevel.TraceLevelCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.TerminalDeviceTraceLevel.__TraceLevel, result: inout SKC.TerminalDeviceTraceLevel.TraceLevel?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.TerminalDeviceTraceLevel.__TraceLevel, result: inout SKC.TerminalDeviceTraceLevel.TraceLevel?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.TerminalDeviceTraceLevel.__TraceLevel?) -> SKC.__Bridge__TerminalDeviceTraceLevel_TraceLevel
  public func _bridgeToObjectiveC() -> SKC.TerminalDeviceTraceLevel.__TraceLevel
  public typealias _ObjectiveCType = SKC.TerminalDeviceTraceLevel.__TraceLevel
  public static func == (a: SKC.__Bridge__TerminalDeviceTraceLevel_TraceLevel, b: SKC.__Bridge__TerminalDeviceTraceLevel_TraceLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__TerminalDeviceTraceLevel_TraceLevel]
  nonisolated public static var allCases: [SKC.__Bridge__TerminalDeviceTraceLevel_TraceLevel] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum TerminalLocale : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case invalidLocale
  case ab
  case aa
  case af
  case ak
  case sq
  case am
  case ar
  case an
  case hy
  case `as`
  case av
  case ae
  case ay
  case az
  case bm
  case ba
  case eu
  case be
  case bn
  case bh
  case bi
  case bs
  case br
  case bg
  case my
  case ca
  case ch
  case ce
  case ny
  case zh
  case cu
  case cv
  case kw
  case co
  case cr
  case hr
  case cs
  case da
  case dv
  case nl
  case dz
  case en
  case eo
  case et
  case ee
  case fo
  case fj
  case fi
  case fr
  case ff
  case gd
  case gl
  case lg
  case ka
  case de
  case el
  case gn
  case gu
  case ht
  case ha
  case he
  case hi
  case ho
  case hu
  case `is`
  case io
  case ig
  case id
  case ia
  case ie
  case iu
  case ik
  case ga
  case it
  case ja
  case jv
  case kl
  case kn
  case kr
  case ks
  case kk
  case ki
  case rw
  case ky
  case kv
  case kg
  case ko
  case kj
  case ku
  case lo
  case la
  case lv
  case li
  case ln
  case lt
  case lu
  case lb
  case mk
  case mg
  case ms
  case ml
  case nt
  case gv
  case mi
  case mr
  case mh
  case mn
  case na
  case nv
  case ng
  case ne
  case nd
  case se
  case no
  case nb
  case nn
  case oc
  case oj
  case or
  case om
  case os
  case pi
  case pa
  case ps
  case fa
  case pl
  case pt
  case qu
  case ro
  case rm
  case rn
  case ru
  case sm
  case sg
  case sa
  case sc
  case sr
  case sn
  case ii
  case sd
  case si
  case sk
  case sl
  case so
  case nr
  case st
  case es
  case su
  case sw
  case ss
  case sv
  case tl
  case ty
  case tg
  case ta
  case tt
  case te
  case th
  case bo
  case ti
  case to
  case ts
  case tn
  case tr
  case tk
  case tw
  case ug
  case uk
  case ur
  case ve
  case vi
  case vo
  case wa
  case cy
  case fy
  case wo
  case xh
  case yi
  case yo
  case za
  case zu
  case frCa
  case enCa
  case enGb
  case csCz
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.__TerminalLocale.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__TerminalLocale, result: inout SKC.TerminalLocale?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__TerminalLocale, result: inout SKC.TerminalLocale?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__TerminalLocale?) -> SKC.TerminalLocale
  public func _bridgeToObjectiveC() -> SKC.__TerminalLocale
  public typealias _ObjectiveCType = SKC.__TerminalLocale
  public typealias Companion = SKC.__TerminalLocale.Companion
  public static func == (a: SKC.TerminalLocale, b: SKC.TerminalLocale) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.TerminalLocale]
  nonisolated public static var allCases: [SKC.TerminalLocale] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.TerminalLocale {
  public func toKotlinEnum() -> SKC.__TerminalLocale
}
extension SKC.__TerminalLocale {
  public func toSwiftEnum() -> SKC.TerminalLocale
}
extension SKC.TerminalImageRef {
  public typealias ImageFormat = SKC.__Bridge__TerminalImageRef_ImageFormat
}
extension SKC.__Bridge__TerminalImageRef_ImageFormat {
  public func toKotlinEnum() -> SKC.TerminalImageRef.__ImageFormat
}
extension SKC.TerminalImageRef.__ImageFormat {
  public func toSwiftEnum() -> SKC.TerminalImageRef.ImageFormat
}
@frozen public enum __Bridge__TerminalImageRef_ImageFormat : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case imageFormatInvalid
  case png
  case jpg
  case gif
  case webp
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var value: Swift.Int32 {
    get
  }
  public static var companion: SKC.TerminalImageRef.ImageFormatCompanion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.TerminalImageRef.__ImageFormat, result: inout SKC.TerminalImageRef.ImageFormat?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.TerminalImageRef.__ImageFormat, result: inout SKC.TerminalImageRef.ImageFormat?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.TerminalImageRef.__ImageFormat?) -> SKC.__Bridge__TerminalImageRef_ImageFormat
  public func _bridgeToObjectiveC() -> SKC.TerminalImageRef.__ImageFormat
  public typealias _ObjectiveCType = SKC.TerminalImageRef.__ImageFormat
  public static func == (a: SKC.__Bridge__TerminalImageRef_ImageFormat, b: SKC.__Bridge__TerminalImageRef_ImageFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.__Bridge__TerminalImageRef_ImageFormat]
  nonisolated public static var allCases: [SKC.__Bridge__TerminalImageRef_ImageFormat] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public enum PublicSwipeReason : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case chipError
  case emptyCandidateList
  case collectData
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public var reason: Swift.String {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PublicSwipeReason, result: inout SKC.PublicSwipeReason?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PublicSwipeReason, result: inout SKC.PublicSwipeReason?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PublicSwipeReason?) -> SKC.PublicSwipeReason
  public func _bridgeToObjectiveC() -> SKC.__PublicSwipeReason
  public typealias _ObjectiveCType = SKC.__PublicSwipeReason
  public static func == (a: SKC.PublicSwipeReason, b: SKC.PublicSwipeReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PublicSwipeReason]
  nonisolated public static var allCases: [SKC.PublicSwipeReason] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PublicSwipeReason {
  public func toKotlinEnum() -> SKC.__PublicSwipeReason
}
extension SKC.__PublicSwipeReason {
  public func toSwiftEnum() -> SKC.PublicSwipeReason
}
@frozen public enum PublicReadMethod : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case contactEmv
  case contactlessEmv
  case magneticStripeFallback
  case magneticStripeTrack2
  case contactlessMagstripeMode
  public var method: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static var companion: SKC.__PublicReadMethod.Companion {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PublicReadMethod, result: inout SKC.PublicReadMethod?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PublicReadMethod, result: inout SKC.PublicReadMethod?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PublicReadMethod?) -> SKC.PublicReadMethod
  public func _bridgeToObjectiveC() -> SKC.__PublicReadMethod
  public typealias _ObjectiveCType = SKC.__PublicReadMethod
  public typealias Companion = SKC.__PublicReadMethod.Companion
  public static func == (a: SKC.PublicReadMethod, b: SKC.PublicReadMethod) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PublicReadMethod]
  nonisolated public static var allCases: [SKC.PublicReadMethod] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PublicReadMethod {
  public func toKotlinEnum() -> SKC.__PublicReadMethod
}
extension SKC.__PublicReadMethod {
  public func toSwiftEnum() -> SKC.PublicReadMethod
}
@frozen public enum PublicCardBrand : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {
  case amex
  case dinersClub
  case discover
  case eftposAu
  case girocard
  case jcb
  case mastercard
  case unionpay
  case unknown
  case visa
  public var name: Swift.String {
    get
  }
  public var ordinal: Swift.Int32 {
    get
  }
  public static func _forceBridgeFromObjectiveC(_ source: SKC.__PublicCardBrand, result: inout SKC.PublicCardBrand?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: SKC.__PublicCardBrand, result: inout SKC.PublicCardBrand?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: SKC.__PublicCardBrand?) -> SKC.PublicCardBrand
  public func _bridgeToObjectiveC() -> SKC.__PublicCardBrand
  public typealias _ObjectiveCType = SKC.__PublicCardBrand
  public static func == (a: SKC.PublicCardBrand, b: SKC.PublicCardBrand) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SKC.PublicCardBrand]
  nonisolated public static var allCases: [SKC.PublicCardBrand] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension SKC.PublicCardBrand {
  public func toKotlinEnum() -> SKC.__PublicCardBrand
}
extension SKC.__PublicCardBrand {
  public func toSwiftEnum() -> SKC.PublicCardBrand
}
extension SKC.Skie.Jackrabbitclient.CollectDataResultInternal {
  @frozen public enum __Sealed {
    case failure(any SKC.CollectDataResultInternalFailure)
    case success(SKC.CollectDataResultInternalSuccess)
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.Jackrabbitclient.CollectDataResultInternal.__Sealed where __Sealed : SKC.CollectDataResultInternal
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.Jackrabbitclient.CollectDataResultInternal.__Sealed? where __Sealed : SKC.CollectDataResultInternal
extension SKC.Skie.Jackrabbitclient.CollectDataResultInternal.Failure {
  @frozen public enum __Sealed : Swift.Hashable {
    case applicationError(SKC.CollectDataResultInternalFailureApplicationError)
    case unexpectedError(SKC.CollectDataResultInternalFailureUnexpectedError)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.Jackrabbitclient.CollectDataResultInternal.Failure.__Sealed, b: SKC.Skie.Jackrabbitclient.CollectDataResultInternal.Failure.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.Jackrabbitclient.CollectDataResultInternal.Failure.__Sealed where __Sealed : SKC.CollectDataResultInternalFailure
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.Jackrabbitclient.CollectDataResultInternal.Failure.__Sealed? where __Sealed : SKC.CollectDataResultInternalFailure
extension SKC.Skie.Jackrabbitclient.CollectInputsResultInternal {
  @frozen public enum __Sealed {
    case failure(any SKC.CollectInputsResultInternalFailure)
    case success(SKC.CollectInputsResultInternalSuccess)
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.Jackrabbitclient.CollectInputsResultInternal.__Sealed where __Sealed : SKC.CollectInputsResultInternal
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.Jackrabbitclient.CollectInputsResultInternal.__Sealed? where __Sealed : SKC.CollectInputsResultInternal
extension SKC.Skie.Jackrabbitclient.CollectInputsResultInternal.Failure {
  @frozen public enum __Sealed : Swift.Hashable {
    case applicationError(SKC.CollectInputsResultInternalFailureApplicationError)
    case communicationError(SKC.CollectInputsResultInternalFailureCommunicationError)
    case invalidParameter(SKC.CollectInputsResultInternalFailureInvalidParameter)
    case merchantCancelled(SKC.CollectInputsResultInternalFailureMerchantCancelled)
    case timeout(SKC.CollectInputsResultInternalFailureTimeout)
    case unsupported(SKC.CollectInputsResultInternalFailureUnsupported)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.Jackrabbitclient.CollectInputsResultInternal.Failure.__Sealed, b: SKC.Skie.Jackrabbitclient.CollectInputsResultInternal.Failure.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.Jackrabbitclient.CollectInputsResultInternal.Failure.__Sealed where __Sealed : SKC.CollectInputsResultInternalFailure
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.Jackrabbitclient.CollectInputsResultInternal.Failure.__Sealed? where __Sealed : SKC.CollectInputsResultInternalFailure
extension SKC.Skie.Jackrabbitclient.CrpcResponse {
  @frozen public enum __Sealed<M> : Swift.Hashable where M : AnyObject {
    case applicationError(SKC.CrpcResponseApplicationError<M>)
    case rpcError(SKC.CrpcResponseRpcError<M>)
    case success(SKC.CrpcResponseSuccess<M>)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.Jackrabbitclient.CrpcResponse.__Sealed<M>, b: SKC.Skie.Jackrabbitclient.CrpcResponse.__Sealed<M>) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<M, __Sealed>(of sealed: __Sealed) -> SKC.Skie.Jackrabbitclient.CrpcResponse.__Sealed<M> where M : AnyObject, __Sealed : SKC.CrpcResponse<M>
@_disfavoredOverload public func onEnum<M, __Sealed>(of sealed: __Sealed?) -> SKC.Skie.Jackrabbitclient.CrpcResponse.__Sealed<M>? where M : AnyObject, __Sealed : SKC.CrpcResponse<M>
extension SKC.Skie.Okio.BufferedSource {
  @frozen public enum __Sealed : Swift.Hashable {
    case buffer(SKC.OkioBuffer)
    case `else`
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.Okio.BufferedSource.__Sealed, b: SKC.Skie.Okio.BufferedSource.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.Okio.BufferedSource.__Sealed where __Sealed : SKC.OkioBufferedSource
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.Okio.BufferedSource.__Sealed? where __Sealed : SKC.OkioBufferedSource
extension SKC.Skie.Okio.BufferedSink {
  @frozen public enum __Sealed : Swift.Hashable {
    case buffer(SKC.OkioBuffer)
    case `else`
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.Okio.BufferedSink.__Sealed, b: SKC.Skie.Okio.BufferedSink.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.Okio.BufferedSink.__Sealed where __Sealed : SKC.OkioBufferedSink
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.Okio.BufferedSink.__Sealed? where __Sealed : SKC.OkioBufferedSink
extension SKC.Skie.android_kmpcore_jackrabbitclient_models__public.KmpCollectInputsResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case kmpCollectInputsResultFailure(SKC.SKCKmpCollectInputsResultFailure)
    case kmpCollectInputsResultSuccess(SKC.SKCKmpCollectInputsResultSuccess)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_jackrabbitclient_models__public.KmpCollectInputsResult.__Sealed, b: SKC.Skie.android_kmpcore_jackrabbitclient_models__public.KmpCollectInputsResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_jackrabbitclient_models__public.KmpCollectInputsResult.__Sealed where __Sealed : SKC.SKCKmpCollectInputsResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_jackrabbitclient_models__public.KmpCollectInputsResult.__Sealed? where __Sealed : SKC.SKCKmpCollectInputsResult
extension SKC.Skie.android_kmpcore_jackrabbitclient_models__public.Input {
  @frozen public enum __Sealed : Swift.Hashable {
    case emailInput(SKC.SKCKmpEmailInput)
    case numericInput(SKC.SKCKmpNumericInput)
    case phoneInput(SKC.SKCKmpPhoneInput)
    case selectionInput(SKC.SKCKmpSelectionInput)
    case signatureInput(SKC.SKCKmpSignatureInput)
    case textInput(SKC.SKCKmpTextInput)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_jackrabbitclient_models__public.Input.__Sealed, b: SKC.Skie.android_kmpcore_jackrabbitclient_models__public.Input.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_jackrabbitclient_models__public.Input.__Sealed where __Sealed : SKC.SKCKmpInput
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_jackrabbitclient_models__public.Input.__Sealed? where __Sealed : SKC.SKCKmpInput
extension SKC.Skie.android_kmpcore_jackrabbitclient_models__public.CollectInputsSingleResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case emailResult(SKC.SKCKmpEmailResult)
    case numericResult(SKC.SKCKmpNumericResult)
    case phoneResult(SKC.SKCKmpPhoneResult)
    case selectionResult(SKC.SKCKmpSelectionResult)
    case signatureResult(SKC.SKCKmpSignatureResult)
    case textResult(SKC.SKCKmpTextResult)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_jackrabbitclient_models__public.CollectInputsSingleResult.__Sealed, b: SKC.Skie.android_kmpcore_jackrabbitclient_models__public.CollectInputsSingleResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_jackrabbitclient_models__public.CollectInputsSingleResult.__Sealed where __Sealed : SKC.SKCKmpCollectInputsSingleResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_jackrabbitclient_models__public.CollectInputsSingleResult.__Sealed? where __Sealed : SKC.SKCKmpCollectInputsSingleResult
extension SKC.Skie.KtorHttp.OutgoingContent {
  @frozen public enum __Sealed : Swift.Hashable {
    case byteArrayContent(SKC.Ktor_httpOutgoingContent.ByteArrayContent)
    case noContent(SKC.Ktor_httpOutgoingContent.NoContent)
    case protocolUpgrade(SKC.Ktor_httpOutgoingContent.ProtocolUpgrade)
    case readChannelContent(SKC.Ktor_httpOutgoingContent.ReadChannelContent)
    case writeChannelContent(SKC.Ktor_httpOutgoingContent.WriteChannelContent)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.KtorHttp.OutgoingContent.__Sealed, b: SKC.Skie.KtorHttp.OutgoingContent.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KtorHttp.OutgoingContent.__Sealed where __Sealed : SKC.Ktor_httpOutgoingContent
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KtorHttp.OutgoingContent.__Sealed? where __Sealed : SKC.Ktor_httpOutgoingContent
extension SKC.Skie.KotlinxCoroutinesCore.SelectClause0 {
  @frozen public enum __Sealed : Swift.Hashable {
    case `else`
    public static func == (a: SKC.Skie.KotlinxCoroutinesCore.SelectClause0.__Sealed, b: SKC.Skie.KotlinxCoroutinesCore.SelectClause0.__Sealed) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KotlinxCoroutinesCore.SelectClause0.__Sealed where __Sealed : SKC.Kotlinx_coroutines_coreSelectClause0
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KotlinxCoroutinesCore.SelectClause0.__Sealed? where __Sealed : SKC.Kotlinx_coroutines_coreSelectClause0
extension SKC.Skie.KotlinxCoroutinesCore.SelectClause {
  @frozen public enum __Sealed {
    case selectClause0(any SKC.Kotlinx_coroutines_coreSelectClause0)
    case selectClause1(any SKC.Kotlinx_coroutines_coreSelectClause1)
    case selectClause2(any SKC.Kotlinx_coroutines_coreSelectClause2)
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KotlinxCoroutinesCore.SelectClause.__Sealed where __Sealed : SKC.Kotlinx_coroutines_coreSelectClause
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KotlinxCoroutinesCore.SelectClause.__Sealed? where __Sealed : SKC.Kotlinx_coroutines_coreSelectClause
extension SKC.Skie.KotlinxCoroutinesCore.SelectInstance {
  @frozen public enum __Sealed : Swift.Hashable {
    case `else`
    public static func == (a: SKC.Skie.KotlinxCoroutinesCore.SelectInstance.__Sealed, b: SKC.Skie.KotlinxCoroutinesCore.SelectInstance.__Sealed) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KotlinxCoroutinesCore.SelectInstance.__Sealed where __Sealed : SKC.Kotlinx_coroutines_coreSelectInstance
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KotlinxCoroutinesCore.SelectInstance.__Sealed? where __Sealed : SKC.Kotlinx_coroutines_coreSelectInstance
extension SKC.Skie.KotlinxCoroutinesCore.SelectClause1 {
  @frozen public enum __Sealed : Swift.Hashable {
    case `else`
    public static func == (a: SKC.Skie.KotlinxCoroutinesCore.SelectClause1.__Sealed, b: SKC.Skie.KotlinxCoroutinesCore.SelectClause1.__Sealed) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KotlinxCoroutinesCore.SelectClause1.__Sealed where __Sealed : SKC.Kotlinx_coroutines_coreSelectClause1
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KotlinxCoroutinesCore.SelectClause1.__Sealed? where __Sealed : SKC.Kotlinx_coroutines_coreSelectClause1
extension SKC.Skie.KotlinxCoroutinesCore.SelectClause2 {
  @frozen public enum __Sealed : Swift.Hashable {
    case `else`
    public static func == (a: SKC.Skie.KotlinxCoroutinesCore.SelectClause2.__Sealed, b: SKC.Skie.KotlinxCoroutinesCore.SelectClause2.__Sealed) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KotlinxCoroutinesCore.SelectClause2.__Sealed where __Sealed : SKC.Kotlinx_coroutines_coreSelectClause2
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KotlinxCoroutinesCore.SelectClause2.__Sealed? where __Sealed : SKC.Kotlinx_coroutines_coreSelectClause2
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.SetupAttemptUnion {
  @frozen public enum __Sealed : Swift.Hashable {
    case expanded(SKC.SetupAttemptUnion.Expanded)
    case reference(SKC.SetupAttemptUnion.Reference)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.SetupAttemptUnion.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.SetupAttemptUnion.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.SetupAttemptUnion.__Sealed where __Sealed : SKC.SetupAttemptUnion
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.SetupAttemptUnion.__Sealed? where __Sealed : SKC.SetupAttemptUnion
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.PaymentMethodUnion {
  @frozen public enum __Sealed : Swift.Hashable {
    case expanded(SKC.PaymentMethodUnionExpanded)
    case reference(SKC.PaymentMethodUnionReference)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.PaymentMethodUnion.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.PaymentMethodUnion.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.PaymentMethodUnion.__Sealed where __Sealed : SKC.PaymentMethodUnion
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.PaymentMethodUnion.__Sealed? where __Sealed : SKC.PaymentMethodUnion
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.CollectInputsResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case emailResult(SKC.EmailResult)
    case numericResult(SKC.NumericResult)
    case phoneResult(SKC.PhoneResult)
    case selectionResult(SKC.SelectionResult)
    case signatureResult(SKC.SignatureResult)
    case textResult(SKC.TextResult)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.CollectInputsResult.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.CollectInputsResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.CollectInputsResult.__Sealed where __Sealed : SKC.CollectInputsResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.CollectInputsResult.__Sealed? where __Sealed : SKC.CollectInputsResult
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ExpandableLocation {
  @frozen public enum __Sealed : Swift.Hashable {
    case expanded(SKC.ExpandableLocationExpanded)
    case reference(SKC.ExpandableLocationReference)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ExpandableLocation.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ExpandableLocation.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ExpandableLocation.__Sealed where __Sealed : SKC.ExpandableLocation
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ExpandableLocation.__Sealed? where __Sealed : SKC.ExpandableLocation
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderListenable {
  @frozen public enum __Sealed {
    case handoffReaderListener(any SKC.HandoffReaderListener)
    case mobileReaderListener(any SKC.MobileReaderListener)
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderListenable.__Sealed where __Sealed : SKC.ReaderListenable
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderListenable.__Sealed? where __Sealed : SKC.ReaderListenable
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderAccessibility {
  @frozen public enum __Sealed : Swift.Hashable {
    case accessibility(SKC.ReaderAccessibilityAccessibility)
    case error(SKC.ReaderAccessibilityError)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderAccessibility.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderAccessibility.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderAccessibility.__Sealed where __Sealed : SKC.ReaderAccessibility
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderAccessibility.__Sealed? where __Sealed : SKC.ReaderAccessibility
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.Input {
  @frozen public enum __Sealed : Swift.Hashable {
    case emailInput(SKC.EmailInput)
    case numericInput(SKC.NumericInput)
    case phoneInput(SKC.PhoneInput)
    case selectionInput(SKC.SelectionInput)
    case signatureInput(SKC.SignatureInput)
    case textInput(SKC.TextInput)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.Input.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.Input.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.Input.__Sealed where __Sealed : SKC.Input
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.Input.__Sealed? where __Sealed : SKC.Input
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ConnectionConfiguration {
  @frozen public enum __Sealed : Swift.Hashable {
    case internetConnectionConfiguration(SKC.ConnectionConfiguration.InternetConnectionConfiguration)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ConnectionConfiguration.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ConnectionConfiguration.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ConnectionConfiguration.__Sealed where __Sealed : SKC.ConnectionConfiguration
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ConnectionConfiguration.__Sealed? where __Sealed : SKC.ConnectionConfiguration
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.DiscoveryConfiguration {
  @frozen public enum __Sealed : Swift.Hashable {
    case internetDiscoveryConfiguration(SKC.DiscoveryConfigurationInternetDiscoveryConfiguration)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.DiscoveryConfiguration.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.DiscoveryConfiguration.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.DiscoveryConfiguration.__Sealed where __Sealed : SKC.DiscoveryConfiguration
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.DiscoveryConfiguration.__Sealed? where __Sealed : SKC.DiscoveryConfiguration
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderSettingsParameters {
  @frozen public enum __Sealed : Swift.Hashable {
    case accessibilityParameters(SKC.ReaderSettingsParametersAccessibilityParameters)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderSettingsParameters.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderSettingsParameters.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderSettingsParameters.__Sealed where __Sealed : SKC.ReaderSettingsParameters
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderSettingsParameters.__Sealed? where __Sealed : SKC.ReaderSettingsParameters
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderSupportResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case notSupported(SKC.ReaderSupportResultNotSupported)
    case supported(SKC.ReaderSupportResultSupported)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderSupportResult.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderSupportResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderSupportResult.__Sealed where __Sealed : SKC.ReaderSupportResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.ReaderSupportResult.__Sealed? where __Sealed : SKC.ReaderSupportResult
extension SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.RefundParameters.Id {
  @frozen public enum __Sealed : Swift.Hashable {
    case charge(SKC.RefundParametersIdCharge)
    case paymentIntent(SKC.RefundParametersIdPaymentIntent)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.RefundParameters.Id.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.RefundParameters.Id.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.RefundParameters.Id.__Sealed where __Sealed : SKC.RefundParametersId
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_external_models__public.RefundParameters.Id.__Sealed? where __Sealed : SKC.RefundParametersId
extension SKC.Skie.android_kmpcore_paymentcollection__public.DynamicCurrencyConversionSelectionStatus {
  @frozen public enum __Sealed : Swift.Hashable {
    case dynamicCurrencyConversionSelected(SKC.DynamicCurrencyConversionSelectionStatus.DynamicCurrencyConversionSelected)
    case notRequested(SKC.DynamicCurrencyConversionSelectionStatus.NotRequested)
    case requested(SKC.DynamicCurrencyConversionSelectionStatus.Requested)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.DynamicCurrencyConversionSelectionStatus.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.DynamicCurrencyConversionSelectionStatus.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.DynamicCurrencyConversionSelectionStatus.__Sealed where __Sealed : SKC.DynamicCurrencyConversionSelectionStatus
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.DynamicCurrencyConversionSelectionStatus.__Sealed? where __Sealed : SKC.DynamicCurrencyConversionSelectionStatus
extension SKC.Skie.android_kmpcore_paymentcollection__public.ManualEntryCollectionResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case failure(SKC.ManualEntryCollectionResult.Failure)
    case success(SKC.ManualEntryCollectionResult.Success)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.ManualEntryCollectionResult.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.ManualEntryCollectionResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.ManualEntryCollectionResult.__Sealed where __Sealed : SKC.ManualEntryCollectionResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.ManualEntryCollectionResult.__Sealed? where __Sealed : SKC.ManualEntryCollectionResult
extension SKC.Skie.android_kmpcore_paymentcollection__public.TippingState {
  @frozen public enum __Sealed : Swift.Hashable {
    case endState(SKC.TippingState.EndState)
    case intermediateState(SKC.TippingState.IntermediateState)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.__Sealed where __Sealed : SKC.TippingState
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.__Sealed? where __Sealed : SKC.TippingState
extension SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.EndState {
  @frozen public enum __Sealed : Swift.Hashable {
    case completed(SKC.TippingState.Completed)
    case ineligible(SKC.TippingState.Ineligible)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.EndState.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.EndState.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.EndState.__Sealed where __Sealed : SKC.TippingState.EndState
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.EndState.__Sealed? where __Sealed : SKC.TippingState.EndState
extension SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.IntermediateState {
  @frozen public enum __Sealed : Swift.Hashable {
    case selectionNeeded(SKC.TippingState.SelectionNeeded)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.IntermediateState.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.IntermediateState.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.IntermediateState.__Sealed where __Sealed : SKC.TippingState.IntermediateState
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.TippingState.IntermediateState.__Sealed? where __Sealed : SKC.TippingState.IntermediateState
extension SKC.Skie.android_kmpcore_paymentcollection__public.AccountSelectionStatus {
  @frozen public enum __Sealed : Swift.Hashable {
    case accountSelected(SKC.AccountSelectionStatus.AccountSelected)
    case notRequested(SKC.AccountSelectionStatus.NotRequested)
    case requested(SKC.AccountSelectionStatus.Requested)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.AccountSelectionStatus.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.AccountSelectionStatus.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.AccountSelectionStatus.__Sealed where __Sealed : SKC.AccountSelectionStatus
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.AccountSelectionStatus.__Sealed? where __Sealed : SKC.AccountSelectionStatus
extension SKC.Skie.android_kmpcore_paymentcollection__public.MagStripePinStatus {
  @frozen public enum __Sealed : Swift.Hashable {
    case bypassed(SKC.MagStripePinStatus.Bypassed)
    case collected(SKC.MagStripePinStatus.Collected)
    case failed(SKC.MagStripePinStatus.Failed)
    case notNeeded(SKC.MagStripePinStatus.NotNeeded)
    case toCollect(SKC.MagStripePinStatus.ToCollect)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.MagStripePinStatus.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.MagStripePinStatus.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.MagStripePinStatus.__Sealed where __Sealed : SKC.MagStripePinStatus
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.MagStripePinStatus.__Sealed? where __Sealed : SKC.MagStripePinStatus
extension SKC.Skie.android_kmpcore_paymentcollection__public.AutomationEvent {
  @frozen public enum __Sealed : Swift.Hashable {
    case acknowledgeInterfaceResetEvent(SKC.AcknowledgeInterfaceResetEvent)
    case autoSelectApplicationEvent(SKC.AutoSelectApplicationEvent)
    case autoSelectLanguageEvent(SKC.AutoSelectLanguageEvent)
    case clearMagStripeStateEvent(SKC.ClearMagStripeStateEvent)
    case manualEntryCollectionResultEvent(SKC.ManualEntryCollectionResultEvent)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.AutomationEvent.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.AutomationEvent.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.AutomationEvent.__Sealed where __Sealed : SKC.AutomationEvent
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.AutomationEvent.__Sealed? where __Sealed : SKC.AutomationEvent
extension SKC.Skie.android_kmpcore_paymentcollection__public.PaymentCollectionEvent {
  @frozen public enum __Sealed : Swift.Hashable {
    case automationEvent(SKC.AutomationEvent)
    case hardwareEvent(SKC.HardwareEvent)
    case hardwareListenerEvent(SKC.HardwareListenerEvent)
    case networkEvent(SKC.NetworkEvent)
    case userInteractionEvent(SKC.UserInteractionEvent)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.PaymentCollectionEvent.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.PaymentCollectionEvent.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.PaymentCollectionEvent.__Sealed where __Sealed : SKC.PaymentCollectionEvent
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.PaymentCollectionEvent.__Sealed? where __Sealed : SKC.PaymentCollectionEvent
extension SKC.Skie.android_kmpcore_paymentcollection__public.UserInteractionEvent {
  @frozen public enum __Sealed : Swift.Hashable {
    case cardStateUpdateEvent(SKC.CardStateUpdateEvent)
    case collectPaymentMethodApiErrorEvent(SKC.CollectPaymentMethodApiErrorEvent)
    case collectionCancelledEvent(SKC.CollectionCancelledEvent)
    case collectionCompleteEvent(SKC.CollectionCompleteEvent)
    case displayCartEvent(SKC.DisplayCartEvent)
    case displayRecoverableErrorEvent(SKC.DisplayRecoverableErrorEvent)
    case manualEntryEvent(SKC.ManualEntryEvent)
    case presentAccountTypeSelectionEvent(SKC.PresentAccountTypeSelectionEvent)
    case presentApplicationSelectionEvent(SKC.PresentApplicationSelectionEvent)
    case presentDynamicCurrencyConversionSelectionEvent(SKC.PresentDynamicCurrencyConversionSelectionEvent)
    case presentInterstitialEvent(SKC.PresentInterstitialEvent)
    case presentNonCardPaymentMethodActionRequiredEvent(SKC.PresentNonCardPaymentMethodActionRequiredEvent)
    case presentNonCardPaymentMethodLoadingEvent(SKC.PresentNonCardPaymentMethodLoadingEvent)
    case presentNonCardPaymentMethodsSelectionEvent(SKC.PresentNonCardPaymentMethodsSelectionEvent)
    case presentPaymentMethodEvent(SKC.PresentPaymentMethodEvent)
    case presentPinEntryEvent(SKC.PresentPinEntryEvent)
    case presentProcessingEvent(SKC.PresentProcessingEvent)
    case presentRemoveCardEvent(SKC.PresentRemoveCardEvent)
    case selectNonCardPaymentMethodEvent(SKC.SelectNonCardPaymentMethodEvent)
    case timeoutEvent(SKC.TimeoutEvent)
    case tippingSelectionEvent(SKC.TippingSelectionEvent)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.UserInteractionEvent.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.UserInteractionEvent.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.UserInteractionEvent.__Sealed where __Sealed : SKC.UserInteractionEvent
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.UserInteractionEvent.__Sealed? where __Sealed : SKC.UserInteractionEvent
extension SKC.Skie.android_kmpcore_paymentcollection__public.HardwareListenerEvent {
  @frozen public enum __Sealed : Swift.Hashable {
    case batteryCriticallyLowEvent(SKC.BatteryCriticallyLowEvent)
    case chipCardInitializationFailed(SKC.ChipCardInitializationFailed)
    case contactCardUpdateEvent(SKC.ContactCardUpdateEvent)
    case deviceMissingEncryptionKeyEvent(SKC.DeviceMissingEncryptionKeyEvent)
    case emptyCandidateListEncounteredEvent(SKC.EmptyCandidateListEncounteredEvent)
    case hardwareTippingCollectionResultEvent(SKC.HardwareTippingCollectionResultEvent)
    case hardwareTransactionCancelledEvent(SKC.HardwareTransactionCancelledEvent)
    case intermediateErrorEvent(SKC.IntermediateErrorEvent)
    case magStripeReadEvent(SKC.MagStripeReadEvent)
    case onAccessiblePinPadEvent(SKC.OnAccessiblePinPadEvent)
    case pinEntryStatusChangeEvent(SKC.PinEntryStatusChangeEvent)
    case readerFinalConfirmationTlvCollectedEvent(SKC.ReaderFinalConfirmationTlvCollectedEvent)
    case readerTypeChangedEvent(SKC.ReaderTypeChangedEvent)
    case readingCardEvent(SKC.ReadingCardEvent)
    case requestOnlineAuthorisationEvent(SKC.RequestOnlineAuthorisationEvent)
    case requestSelectAccountEvent(SKC.RequestSelectAccountEvent)
    case requestSelectApplicationEvent(SKC.RequestSelectApplicationEvent)
    case resetPaymentInterfacesEvent(SKC.ResetPaymentInterfacesEvent)
    case setPinEntryAsteriskCountEvent(SKC.SetPinEntryAsteriskCountEvent)
    case setPinPadResultEvent(SKC.SetPinPadResultEvent)
    case showThankYouEvent(SKC.ShowThankYouEvent)
    case transactionCompletedEvent(SKC.TransactionCompletedEvent)
    case waitForCardPresentEvent(SKC.WaitForCardPresentEvent)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.HardwareListenerEvent.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.HardwareListenerEvent.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.HardwareListenerEvent.__Sealed where __Sealed : SKC.HardwareListenerEvent
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.HardwareListenerEvent.__Sealed? where __Sealed : SKC.HardwareListenerEvent
extension SKC.Skie.android_kmpcore_paymentcollection__public.HardwareEvent {
  @frozen public enum __Sealed : Swift.Hashable {
    case authorizePaymentEvent(SKC.AuthorizePaymentEvent)
    case cancelHardwareTippingCollectionEvent(SKC.CancelHardwareTippingCollectionEvent)
    case configureReaderEvent(SKC.ConfigureReaderEvent)
    case hardwareTippingCollectionEvent(SKC.HardwareTippingCollectionEvent)
    case requestPinEntryEvent(SKC.RequestPinEntryEvent)
    case selectAccountTypeEvent(SKC.SelectAccountTypeEvent)
    case selectApplicationEvent(SKC.SelectApplicationEvent)
    case selectLanguageEvent(SKC.SelectLanguageEvent)
    case sendFinalConfirmEvent(SKC.SendFinalConfirmEvent)
    case startPinEntryEvent(SKC.StartPinEntryEvent)
    case startPollingForCardStatusEvent(SKC.StartPollingForCardStatusEvent)
    case stopReaderEvent(SKC.StopReaderEvent)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.HardwareEvent.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.HardwareEvent.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.HardwareEvent.__Sealed where __Sealed : SKC.HardwareEvent
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.HardwareEvent.__Sealed? where __Sealed : SKC.HardwareEvent
extension SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState {
  @frozen public enum __Sealed : Swift.Hashable {
    case cancelled(SKC.OnlineAuthState.Cancelled)
    case confirmationResponseReceived(SKC.OnlineAuthState.ConfirmationResponseReceived)
    case confirmationStarted(SKC.OnlineAuthState.ConfirmationStarted)
    case readyToStartConfirmation(SKC.OnlineAuthState.ReadyToStartConfirmation)
    case secondGenAcResponseReceived(SKC.OnlineAuthState.SecondGenAcResponseReceived)
    case secondGenAcStarted(SKC.OnlineAuthState.SecondGenAcStarted)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.__Sealed where __Sealed : SKC.OnlineAuthState
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.__Sealed? where __Sealed : SKC.OnlineAuthState
extension SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.ConfirmationResponseReceived {
  @frozen public enum __Sealed : Swift.Hashable {
    case failed(SKC.OnlineAuthState.ConfirmationResponseReceivedFailed)
    case needSecondGenAc(SKC.OnlineAuthState.ConfirmationResponseReceivedNeedSecondGenAc)
    case success(SKC.OnlineAuthState.ConfirmationResponseReceivedSuccess)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.ConfirmationResponseReceived.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.ConfirmationResponseReceived.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.ConfirmationResponseReceived.__Sealed where __Sealed : SKC.OnlineAuthState.ConfirmationResponseReceived
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.ConfirmationResponseReceived.__Sealed? where __Sealed : SKC.OnlineAuthState.ConfirmationResponseReceived
extension SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.SecondGenAcResponseReceived {
  @frozen public enum __Sealed : Swift.Hashable {
    case failed(SKC.OnlineAuthState.SecondGenAcResponseReceivedFailed)
    case success(SKC.OnlineAuthState.SecondGenAcResponseReceivedSuccess)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.SecondGenAcResponseReceived.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.SecondGenAcResponseReceived.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.SecondGenAcResponseReceived.__Sealed where __Sealed : SKC.OnlineAuthState.SecondGenAcResponseReceived
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.OnlineAuthState.SecondGenAcResponseReceived.__Sealed? where __Sealed : SKC.OnlineAuthState.SecondGenAcResponseReceived
extension SKC.Skie.android_kmpcore_paymentcollection__public.PaymentCollectionResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case batteryCriticallyLow(SKC.BatteryCriticallyLow)
    case cancelled(SKC.Cancelled)
    case deviceMissingEncryptionKey(SKC.DeviceMissingEncryptionKey)
    case emvResult(SKC.EmvResult)
    case failed(SKC.Failed)
    case manualEntryResult(SKC.ManualEntryResult_)
    case msrResult(SKC.MsrResult)
    case nonCardPaymentMethodConfirmationResult(SKC.NonCardPaymentMethodConfirmationResult)
    case passthroughResult(SKC.PassthroughResult)
    case timeout(SKC.Timeout)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.PaymentCollectionResult.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.PaymentCollectionResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.PaymentCollectionResult.__Sealed where __Sealed : SKC.PaymentCollectionResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.PaymentCollectionResult.__Sealed? where __Sealed : SKC.PaymentCollectionResult
extension SKC.Skie.android_kmpcore_paymentcollection__public.SecondGenACResponse {
  @frozen public enum __Sealed : Swift.Hashable {
    case emvSecondGenACResponse(SKC.EmvSecondGenACResponse)
    case magStripeSecondGenACResponse(SKC.MagStripeSecondGenACResponse)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.SecondGenACResponse.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.SecondGenACResponse.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.SecondGenACResponse.__Sealed where __Sealed : SKC.SecondGenACResponse
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.SecondGenACResponse.__Sealed? where __Sealed : SKC.SecondGenACResponse
extension SKC.Skie.android_kmpcore_paymentcollection__public.NetworkEvent {
  @frozen public enum __Sealed : Swift.Hashable {
    case magStripeAuthorizationRequestEvent(SKC.MagStripeAuthorizationRequestEvent)
    case manualEntryAuthorizationRequestEvent(SKC.ManualEntryAuthorizationRequestEvent)
    case nonCardPaymentMethodActionCompletionEvent(SKC.NonCardPaymentMethodActionCompletionEvent)
    case nonCardPaymentMethodConfirmationRequestEvent(SKC.NonCardPaymentMethodConfirmationRequestEvent)
    case onlineAuthorizationRequestEvent(SKC.OnlineAuthorizationRequestEvent)
    case passthroughConfirmationRequestEvent(SKC.PassthroughConfirmationRequestEvent)
    case secondGenACResponseEvent(SKC.SecondGenACResponseEvent)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_paymentcollection__public.NetworkEvent.__Sealed, b: SKC.Skie.android_kmpcore_paymentcollection__public.NetworkEvent.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_paymentcollection__public.NetworkEvent.__Sealed where __Sealed : SKC.NetworkEvent
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_paymentcollection__public.NetworkEvent.__Sealed? where __Sealed : SKC.NetworkEvent
extension SKC.Skie.android_kmpcore_transaction__public.ChargeAttempt {
  @frozen public enum __Sealed : Swift.Hashable {
    case completedAttempt(SKC.ChargeAttempt.CompletedAttempt)
    case extendedAttempt(SKC.ChargeAttempt.ExtendedAttempt)
    case pendingNextActionAttempt(SKC.ChargeAttempt.PendingNextActionAttempt)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_transaction__public.ChargeAttempt.__Sealed, b: SKC.Skie.android_kmpcore_transaction__public.ChargeAttempt.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_transaction__public.ChargeAttempt.__Sealed where __Sealed : SKC.ChargeAttempt
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_transaction__public.ChargeAttempt.__Sealed? where __Sealed : SKC.ChargeAttempt
extension SKC.Skie.android_kmpcore_transaction__public.ChargeAttempt.CompletedAttempt {
  @frozen public enum __Sealed : Swift.Hashable {
    case alreadyRefunded(SKC.ChargeAttempt.CompletedAttemptAlreadyRefunded)
    case declinedCharge(SKC.ChargeAttempt.CompletedAttemptDeclinedCharge)
    case declinedRefund(SKC.ChargeAttempt.CompletedAttemptDeclinedRefund)
    case invalidCollectedData(SKC.ChargeAttempt.CompletedAttemptInvalidCollectedData)
    case successfulCharge(SKC.ChargeAttempt.CompletedAttemptSuccessfulCharge)
    case successfulCollectedData(SKC.ChargeAttempt.CompletedAttemptSuccessfulCollectedData)
    case successfulNonCardCharge(SKC.ChargeAttempt.CompletedAttemptSuccessfulNonCardCharge)
    case successfulRefund(SKC.ChargeAttempt.CompletedAttemptSuccessfulRefund)
    case successfulReusableCard(SKC.ChargeAttempt.CompletedAttemptSuccessfulReusableCard)
    case successfulSetupIntent(SKC.ChargeAttempt.CompletedAttemptSuccessfulSetupIntent)
    case unknownChargeResult(SKC.ChargeAttempt.CompletedAttemptUnknownChargeResult)
    case unknownRefundResult(SKC.ChargeAttempt.CompletedAttemptUnknownRefundResult)
    case unknownReusableCardResult(SKC.ChargeAttempt.CompletedAttemptUnknownReusableCardResult)
    case incompleteAttempt(SKC.ChargeAttempt.IncompleteAttempt)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_transaction__public.ChargeAttempt.CompletedAttempt.__Sealed, b: SKC.Skie.android_kmpcore_transaction__public.ChargeAttempt.CompletedAttempt.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_transaction__public.ChargeAttempt.CompletedAttempt.__Sealed where __Sealed : SKC.ChargeAttempt.CompletedAttempt
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_transaction__public.ChargeAttempt.CompletedAttempt.__Sealed? where __Sealed : SKC.ChargeAttempt.CompletedAttempt
extension SKC.Skie.android_kmpcore_transaction__public.PaymentMethodCollectionType {
  @frozen public enum __Sealed : Swift.Hashable {
    case passthrough(SKC.PaymentMethodCollectionTypePassthrough)
    case refund(SKC.PaymentMethodCollectionTypeRefund)
    case sale(SKC.PaymentMethodCollectionTypeSale)
    case setupIntent(SKC.PaymentMethodCollectionTypeSetupIntent)
    case strongCustomerAuthentication(SKC.PaymentMethodCollectionTypeStrongCustomerAuthentication)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_transaction__public.PaymentMethodCollectionType.__Sealed, b: SKC.Skie.android_kmpcore_transaction__public.PaymentMethodCollectionType.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_transaction__public.PaymentMethodCollectionType.__Sealed where __Sealed : SKC.PaymentMethodCollectionType
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_transaction__public.PaymentMethodCollectionType.__Sealed? where __Sealed : SKC.PaymentMethodCollectionType
extension SKC.Skie.KotlinxSerializationCore.SerialKind {
  @frozen public enum __Sealed : Swift.Hashable {
    case polymorphicKind(SKC.Kotlinx_serialization_corePolymorphicKind)
    case primitiveKind(SKC.Kotlinx_serialization_corePrimitiveKind)
    case cONTEXTUAL(SKC.Kotlinx_serialization_coreSerialKind.CONTEXTUAL)
    case eNUM(SKC.Kotlinx_serialization_coreSerialKind.ENUM)
    case structureKind(SKC.Kotlinx_serialization_coreStructureKind)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.KotlinxSerializationCore.SerialKind.__Sealed, b: SKC.Skie.KotlinxSerializationCore.SerialKind.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KotlinxSerializationCore.SerialKind.__Sealed where __Sealed : SKC.Kotlinx_serialization_coreSerialKind
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KotlinxSerializationCore.SerialKind.__Sealed? where __Sealed : SKC.Kotlinx_serialization_coreSerialKind
extension SKC.Skie.KotlinxSerializationCore.SerializersModule {
  @frozen public enum __Sealed : Swift.Hashable {
    case `else`
    public static func == (a: SKC.Skie.KotlinxSerializationCore.SerializersModule.__Sealed, b: SKC.Skie.KotlinxSerializationCore.SerializersModule.__Sealed) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KotlinxSerializationCore.SerializersModule.__Sealed where __Sealed : SKC.Kotlinx_serialization_coreSerializersModule
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KotlinxSerializationCore.SerializersModule.__Sealed? where __Sealed : SKC.Kotlinx_serialization_coreSerializersModule
extension SKC.Skie.KotlinxSerializationCore.PolymorphicKind {
  @frozen public enum __Sealed : Swift.Hashable {
    case oPEN(SKC.Kotlinx_serialization_corePolymorphicKind.OPEN)
    case sEALED(SKC.Kotlinx_serialization_corePolymorphicKind.SEALED)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.KotlinxSerializationCore.PolymorphicKind.__Sealed, b: SKC.Skie.KotlinxSerializationCore.PolymorphicKind.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KotlinxSerializationCore.PolymorphicKind.__Sealed where __Sealed : SKC.Kotlinx_serialization_corePolymorphicKind
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KotlinxSerializationCore.PolymorphicKind.__Sealed? where __Sealed : SKC.Kotlinx_serialization_corePolymorphicKind
extension SKC.Skie.KotlinxSerializationCore.PrimitiveKind {
  @frozen public enum __Sealed : Swift.Hashable {
    case bOOLEAN(SKC.Kotlinx_serialization_corePrimitiveKind.BOOLEAN)
    case bYTE(SKC.Kotlinx_serialization_corePrimitiveKind.BYTE)
    case cHAR(SKC.Kotlinx_serialization_corePrimitiveKind.CHAR)
    case dOUBLE(SKC.Kotlinx_serialization_corePrimitiveKind.DOUBLE)
    case fLOAT(SKC.Kotlinx_serialization_corePrimitiveKind.FLOAT)
    case iNT(SKC.Kotlinx_serialization_corePrimitiveKind.INT)
    case lONG(SKC.Kotlinx_serialization_corePrimitiveKind.LONG)
    case sHORT(SKC.Kotlinx_serialization_corePrimitiveKind.SHORT)
    case sTRING(SKC.Kotlinx_serialization_corePrimitiveKind.STRING)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.KotlinxSerializationCore.PrimitiveKind.__Sealed, b: SKC.Skie.KotlinxSerializationCore.PrimitiveKind.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KotlinxSerializationCore.PrimitiveKind.__Sealed where __Sealed : SKC.Kotlinx_serialization_corePrimitiveKind
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KotlinxSerializationCore.PrimitiveKind.__Sealed? where __Sealed : SKC.Kotlinx_serialization_corePrimitiveKind
extension SKC.Skie.KotlinxSerializationCore.StructureKind {
  @frozen public enum __Sealed : Swift.Hashable {
    case cLASS(SKC.Kotlinx_serialization_coreStructureKind.CLASS)
    case lIST(SKC.Kotlinx_serialization_coreStructureKind.LIST)
    case mAP(SKC.Kotlinx_serialization_coreStructureKind.MAP)
    case oBJECT(SKC.Kotlinx_serialization_coreStructureKind.OBJECT)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.KotlinxSerializationCore.StructureKind.__Sealed, b: SKC.Skie.KotlinxSerializationCore.StructureKind.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.KotlinxSerializationCore.StructureKind.__Sealed where __Sealed : SKC.Kotlinx_serialization_coreStructureKind
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.KotlinxSerializationCore.StructureKind.__Sealed? where __Sealed : SKC.Kotlinx_serialization_coreStructureKind
extension SKC.Skie.android_kmpcore_hardware__public.TipConfigValidationResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case fixedAmountTips(SKC.FixedAmountTips)
    case invalidTipConfig(SKC.InvalidTipConfig)
    case percentageTips(SKC.PercentageTips)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_hardware__public.TipConfigValidationResult.__Sealed, b: SKC.Skie.android_kmpcore_hardware__public.TipConfigValidationResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_hardware__public.TipConfigValidationResult.__Sealed where __Sealed : SKC.TipConfigValidationResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_hardware__public.TipConfigValidationResult.__Sealed? where __Sealed : SKC.TipConfigValidationResult
extension SKC.Skie.android_kmpcore_hardware__public.ManualEntryResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case confirmPaymentFromManualEntryResult(SKC.ConfirmPaymentFromManualEntryResult)
    case zipCodeManualEntryResult(SKC.ZipCodeManualEntryResult)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_hardware__public.ManualEntryResult.__Sealed, b: SKC.Skie.android_kmpcore_hardware__public.ManualEntryResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_hardware__public.ManualEntryResult.__Sealed where __Sealed : SKC.ManualEntryResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_hardware__public.ManualEntryResult.__Sealed? where __Sealed : SKC.ManualEntryResult
extension SKC.Skie.android_kmpcore_hardware__public.TipSelectionResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case noTipSelected(SKC.NoTipSelected)
    case tipSelected(SKC.TipSelected)
    case tipSelectionFailure(SKC.TipSelectionFailure)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_hardware__public.TipSelectionResult.__Sealed, b: SKC.Skie.android_kmpcore_hardware__public.TipSelectionResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_hardware__public.TipSelectionResult.__Sealed where __Sealed : SKC.TipSelectionResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_hardware__public.TipSelectionResult.__Sealed? where __Sealed : SKC.TipSelectionResult
extension SKC.Skie.android_kmpcore_hardware__public.ManualEntryModel {
  @frozen public enum __Sealed : Swift.Hashable {
    case confirmDetailsModel(SKC.ConfirmDetailsModel)
    case cvvModel(SKC.CvvModel)
    case expiryDateModel(SKC.ExpiryDateModel)
    case manualEntryFailureModel(SKC.ManualEntryFailureModel)
    case panEntryModel(SKC.PanEntryModel)
    case zipCodeEntryModel(SKC.ZipCodeEntryModel)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_hardware__public.ManualEntryModel.__Sealed, b: SKC.Skie.android_kmpcore_hardware__public.ManualEntryModel.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_hardware__public.ManualEntryModel.__Sealed where __Sealed : SKC.ManualEntryModel
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_hardware__public.ManualEntryModel.__Sealed? where __Sealed : SKC.ManualEntryModel
extension SKC.Skie.android_kmpcore_hardware__public.Disposition {
  @frozen public enum __Sealed<ResultType> : Swift.Hashable where ResultType : AnyObject {
    case canceled(SKC.DispositionCanceled<ResultType>)
    case completed(SKC.DispositionCompleted<ResultType>)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_hardware__public.Disposition.__Sealed<ResultType>, b: SKC.Skie.android_kmpcore_hardware__public.Disposition.__Sealed<ResultType>) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<ResultType, __Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_hardware__public.Disposition.__Sealed<ResultType> where ResultType : AnyObject, __Sealed : SKC.Disposition<ResultType>
@_disfavoredOverload public func onEnum<ResultType, __Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_hardware__public.Disposition.__Sealed<ResultType>? where ResultType : AnyObject, __Sealed : SKC.Disposition<ResultType>
extension SKC.Skie.android_kmpcore_hardware__public.PaymentMethodCollectionResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case displayNonCardPaymentMethodsResult(SKC.DisplayNonCardPaymentMethodsResult)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_hardware__public.PaymentMethodCollectionResult.__Sealed, b: SKC.Skie.android_kmpcore_hardware__public.PaymentMethodCollectionResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_hardware__public.PaymentMethodCollectionResult.__Sealed where __Sealed : SKC.PaymentMethodCollectionResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_hardware__public.PaymentMethodCollectionResult.__Sealed? where __Sealed : SKC.PaymentMethodCollectionResult
extension SKC.Skie.android_kmpcore_hardware__public.Confirmation {
  @frozen public enum __Sealed : Swift.Hashable {
    case accountSelection(SKC.Confirmation.AccountSelection)
    case applicationSelection(SKC.Confirmation.ApplicationSelection)
    case languageSelection(SKC.Confirmation.LanguageSelection)
    case pin(SKC.Confirmation.Pin)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_hardware__public.Confirmation.__Sealed, b: SKC.Skie.android_kmpcore_hardware__public.Confirmation.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_hardware__public.Confirmation.__Sealed where __Sealed : SKC.Confirmation
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_hardware__public.Confirmation.__Sealed? where __Sealed : SKC.Confirmation
extension SKC.Skie.android_kmpcore_hardware__public.BbposSdkTipSelectionType {
  @frozen public enum __Sealed : Swift.Hashable {
    case custom(SKC.Custom)
    case fixedAmount(SKC.FixedAmount)
    case percentage(SKC.Percentage)
    case unknown(SKC.Unknown)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_hardware__public.BbposSdkTipSelectionType.__Sealed, b: SKC.Skie.android_kmpcore_hardware__public.BbposSdkTipSelectionType.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_hardware__public.BbposSdkTipSelectionType.__Sealed where __Sealed : SKC.BbposSdkTipSelectionType
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_hardware__public.BbposSdkTipSelectionType.__Sealed? where __Sealed : SKC.BbposSdkTipSelectionType
extension SKC.Skie.android_kmpcore_hardware_magstripe__public.MagStripeReadResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case magStripeReadFailure(SKC.MagStripeReadFailure)
    case magStripeReadSuccess(SKC.MagStripeReadSuccess)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_hardware_magstripe__public.MagStripeReadResult.__Sealed, b: SKC.Skie.android_kmpcore_hardware_magstripe__public.MagStripeReadResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_hardware_magstripe__public.MagStripeReadResult.__Sealed where __Sealed : SKC.MagStripeReadResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_hardware_magstripe__public.MagStripeReadResult.__Sealed? where __Sealed : SKC.MagStripeReadResult
extension SKC.Skie.android_kmpcore_logging_models__public.Outcome {
  @frozen public enum __Sealed {
    case failure(any SKC.PublicOutcomeFailure)
    case success(any SKC.PublicOutcomeSuccess)
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_logging_models__public.Outcome.__Sealed where __Sealed : SKC.PublicOutcome
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_logging_models__public.Outcome.__Sealed? where __Sealed : SKC.PublicOutcome
extension SKC.Skie.android_kmpcore_sdk_terminal_internal_models__public.LocationRegistration {
  @frozen public enum __Sealed : Swift.Hashable {
    case useId(SKC.PublicLocationRegistrationUseId)
    case usePreSet(SKC.PublicLocationRegistrationUsePreSet)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.android_kmpcore_sdk_terminal_internal_models__public.LocationRegistration.__Sealed, b: SKC.Skie.android_kmpcore_sdk_terminal_internal_models__public.LocationRegistration.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.android_kmpcore_sdk_terminal_internal_models__public.LocationRegistration.__Sealed where __Sealed : SKC.PublicLocationRegistration
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.android_kmpcore_sdk_terminal_internal_models__public.LocationRegistration.__Sealed? where __Sealed : SKC.PublicLocationRegistration
extension SKC.Skie.RuntimeKotlin.Skie_SuspendResult {
  @frozen public enum __Sealed : Swift.Hashable {
    case canceled(SKC.Skie_SuspendResult.Canceled)
    case error(SKC.Skie_SuspendResult.Error)
    case success(SKC.Skie_SuspendResult.Success)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SKC.Skie.RuntimeKotlin.Skie_SuspendResult.__Sealed, b: SKC.Skie.RuntimeKotlin.Skie_SuspendResult.__Sealed) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public func onEnum<__Sealed>(of sealed: __Sealed) -> SKC.Skie.RuntimeKotlin.Skie_SuspendResult.__Sealed where __Sealed : SKC.Skie_SuspendResult
@_disfavoredOverload public func onEnum<__Sealed>(of sealed: __Sealed?) -> SKC.Skie.RuntimeKotlin.Skie_SuspendResult.__Sealed? where __Sealed : SKC.Skie_SuspendResult
public func clientWithCustomDelegateForIpAndCert(session: Foundation.URLSession) -> SKC.Ktor_client_coreHttpClient
public func logError(source: any SKC.KotlinKClass, message: Swift.String)
public func logInfo(source: any SKC.KotlinKClass, message: Swift.String)
public func logWarn(source: any SKC.KotlinKClass, message: Swift.String)
public var TECHNICAL_FALLBACK_FAILED_INSERTION_THRESHOLD: Swift.Int32 {
  get
}
public func generateConfigureReaderEvent(readerType: Swift.Set<SKC.ReaderConfiguration.ReaderType>, amount: SKC.Amount, transactionType: SKC.TransactionType, emvTransactionType: SKC.EmvTransactionType, isOffline: Swift.Bool, isDeferredAuthorizationCountry: Swift.Bool, deviceType: SKC.DeviceType, domesticDebitPriority: SKC.ReaderConfiguration.DomesticDebitPriority?, domesticDebitAids: [Swift.String], forcePinEntry: Swift.Bool) -> SKC.ReaderConfiguration
extension SKC.PaymentCollectionLoggerFactory {
  public func create() -> any SKC.PaymentCollectionLogger
}
public var DEFAULT_PAYMENT_COLLECTION_CAPABILITY: SKC.PaymentCollectionDeviceCapability {
  get
}
public var PARSE_ERROR_CODE: Swift.String {
  get
}
public var PARSE_ERROR_MESSAGE: Swift.String {
  get
}
public var STRIPE_API_CONNECTION_ERROR_CODE: Swift.String {
  get
}
public var QUICK_EMV_AMOUNT: SKC.Amount {
  get
}
public func generateValidatedConfig(localizedTippingConfig: SKC.TerminalTippingConfigPb.LocalizedTippingConfig, amount: SKC.Amount) -> SKC.TipConfigValidationResult
public func getApplicationIdOrNull(id: Swift.String?) -> SKC.ApplicationId?
extension SKC.KotlinKVariance : Swift.Sendable {}
extension SKC.KotlinKVariance : Swift.BitwiseCopyable {}
extension SKC.LogLevel : Swift.Sendable {}
extension SKC.LogLevel : Swift.BitwiseCopyable {}
extension SKC.__Bridge__InternalPaymentMethodOptions_RoutingPriority : Swift.Sendable {}
extension SKC.__Bridge__InternalPaymentMethodOptions_RoutingPriority : Swift.BitwiseCopyable {}
extension SKC.__Bridge__InternalPaymentMethodOptions_CardOptionsRequest3dSecureType : Swift.Sendable {}
extension SKC.__Bridge__InternalPaymentMethodOptions_CardOptionsRequest3dSecureType : Swift.BitwiseCopyable {}
extension SKC.InternalMethod : Swift.Sendable {}
extension SKC.InternalMethod : Swift.BitwiseCopyable {}
extension SKC.InternalReaderErrorCode : Swift.Sendable {}
extension SKC.InternalReaderErrorCode : Swift.BitwiseCopyable {}
extension SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType : Swift.Sendable {}
extension SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputInputType : Swift.BitwiseCopyable {}
extension SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue : Swift.Sendable {}
extension SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputToggleValue : Swift.BitwiseCopyable {}
extension SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle : Swift.Sendable {}
extension SKC.InternalQueryCollectInputsResponseSuccessfullyCompletedInputSelectionChoiceStyle : Swift.BitwiseCopyable {}
extension SKC.__Bridge__InternalCollectDataRequest_CollectDataType : Swift.Sendable {}
extension SKC.__Bridge__InternalCollectDataRequest_CollectDataType : Swift.BitwiseCopyable {}
extension SKC.__Bridge__InternalCollectInputsRequest_InputInputType : Swift.Sendable {}
extension SKC.__Bridge__InternalCollectInputsRequest_InputInputType : Swift.BitwiseCopyable {}
extension SKC.__Bridge__InternalCollectInputsRequest_ToggleValue : Swift.Sendable {}
extension SKC.__Bridge__InternalCollectInputsRequest_ToggleValue : Swift.BitwiseCopyable {}
extension SKC.__Bridge__InternalCollectInputsRequest_ChoiceStyle : Swift.Sendable {}
extension SKC.__Bridge__InternalCollectInputsRequest_ChoiceStyle : Swift.BitwiseCopyable {}
extension SKC.__Bridge__InternalRequestedPaymentMethod_RequestedCardPresentSchemeType : Swift.Sendable {}
extension SKC.__Bridge__InternalRequestedPaymentMethod_RequestedCardPresentSchemeType : Swift.BitwiseCopyable {}
extension SKC.InternalCardEntryMethod : Swift.Sendable {}
extension SKC.InternalCardEntryMethod : Swift.BitwiseCopyable {}
extension SKC.InternalCreditCardBrand : Swift.Sendable {}
extension SKC.InternalCreditCardBrand : Swift.BitwiseCopyable {}
extension SKC.Wire_runtimeFieldEncoding : Swift.Sendable {}
extension SKC.Wire_runtimeFieldEncoding : Swift.BitwiseCopyable {}
extension SKC.Wire_runtimeSyntax : Swift.Sendable {}
extension SKC.Wire_runtimeSyntax : Swift.BitwiseCopyable {}
extension SKC.CommonApplicationEC : Swift.Sendable {}
extension SKC.CommonApplicationEC : Swift.BitwiseCopyable {}
extension SKC.CommonRpcEC : Swift.Sendable {}
extension SKC.CommonRpcEC : Swift.BitwiseCopyable {}
extension SKC.__Bridge__CommonDeviceInfo_DeviceClass : Swift.Sendable {}
extension SKC.__Bridge__CommonDeviceInfo_DeviceClass : Swift.BitwiseCopyable {}
extension SKC.CommonVerifoneHardware : Swift.Sendable {}
extension SKC.CommonVerifoneHardware : Swift.BitwiseCopyable {}
extension SKC.CommonSunmiHardware : Swift.Sendable {}
extension SKC.CommonSunmiHardware : Swift.BitwiseCopyable {}
extension SKC.CommonMobileOS : Swift.Sendable {}
extension SKC.CommonMobileOS : Swift.BitwiseCopyable {}
extension SKC.CommonBBPosHardware : Swift.Sendable {}
extension SKC.CommonBBPosHardware : Swift.BitwiseCopyable {}
extension SKC.CommonMorphHardware : Swift.Sendable {}
extension SKC.CommonMorphHardware : Swift.BitwiseCopyable {}
extension SKC.CommonInternetConnectionSource : Swift.Sendable {}
extension SKC.CommonInternetConnectionSource : Swift.BitwiseCopyable {}
extension SKC.__Bridge__CommonVersionInfoPb_ClientType : Swift.Sendable {}
extension SKC.__Bridge__CommonVersionInfoPb_ClientType : Swift.BitwiseCopyable {}
extension SKC.__Bridge__CommonClientUpgradeArgumentPb_UpgradeTimeArgument : Swift.Sendable {}
extension SKC.__Bridge__CommonClientUpgradeArgumentPb_UpgradeTimeArgument : Swift.BitwiseCopyable {}
extension SKC.__Bridge__CommonClientVersionSpecPb_InstallType : Swift.Sendable {}
extension SKC.__Bridge__CommonClientVersionSpecPb_InstallType : Swift.BitwiseCopyable {}
extension SKC.__Bridge__CommonSemanticVersionedAssetMetadata_BuildVariantType : Swift.Sendable {}
extension SKC.__Bridge__CommonSemanticVersionedAssetMetadata_BuildVariantType : Swift.BitwiseCopyable {}
extension SKC.__Bridge__CommonBbposKeyProfileMetadata_KeyProfileP2PEType : Swift.Sendable {}
extension SKC.__Bridge__CommonBbposKeyProfileMetadata_KeyProfileP2PEType : Swift.BitwiseCopyable {}
extension SKC.__Bridge__CommonDeviceAssetInfo_AssetType : Swift.Sendable {}
extension SKC.__Bridge__CommonDeviceAssetInfo_AssetType : Swift.BitwiseCopyable {}
extension SKC.SKCKmpToggleValue : Swift.Sendable {}
extension SKC.SKCKmpToggleValue : Swift.BitwiseCopyable {}
extension SKC.SKCKmpSelectionButtonStyle : Swift.Sendable {}
extension SKC.SKCKmpSelectionButtonStyle : Swift.BitwiseCopyable {}
extension SKC.SKCKmpFormType : Swift.Sendable {}
extension SKC.SKCKmpFormType : Swift.BitwiseCopyable {}
extension SKC.SKCKmpToggleResult : Swift.Sendable {}
extension SKC.SKCKmpToggleResult : Swift.BitwiseCopyable {}
extension SKC.Ktor_utilsMonth : Swift.Sendable {}
extension SKC.Ktor_utilsMonth : Swift.BitwiseCopyable {}
extension SKC.Ktor_utilsWeekDay : Swift.Sendable {}
extension SKC.Ktor_utilsWeekDay : Swift.BitwiseCopyable {}
extension SKC.SKCTerminalErrorCode : Swift.Sendable {}
extension SKC.SKCTerminalErrorCode : Swift.BitwiseCopyable {}
extension SKC.PaymentMethodType : Swift.Sendable {}
extension SKC.PaymentMethodType : Swift.BitwiseCopyable {}
extension SKC.DeviceType : Swift.Sendable {}
extension SKC.DeviceType : Swift.BitwiseCopyable {}
extension SKC.AllowRedisplay : Swift.Sendable {}
extension SKC.AllowRedisplay : Swift.BitwiseCopyable {}
extension SKC.OfflineBehavior : Swift.Sendable {}
extension SKC.OfflineBehavior : Swift.BitwiseCopyable {}
extension SKC.CardPresentRequestPartialAuthorization : Swift.Sendable {}
extension SKC.CardPresentRequestPartialAuthorization : Swift.BitwiseCopyable {}
extension SKC.RoutingPriority : Swift.Sendable {}
extension SKC.RoutingPriority : Swift.BitwiseCopyable {}
extension SKC.Request3dSecureType : Swift.Sendable {}
extension SKC.Request3dSecureType : Swift.BitwiseCopyable {}
extension SKC.SetupIntentCancellationReason : Swift.Sendable {}
extension SKC.SetupIntentCancellationReason : Swift.BitwiseCopyable {}
extension SKC.SetupIntentUsage : Swift.Sendable {}
extension SKC.SetupIntentUsage : Swift.BitwiseCopyable {}
extension SKC.SetupIntentStatus : Swift.Sendable {}
extension SKC.SetupIntentStatus : Swift.BitwiseCopyable {}
extension SKC.ApiErrorType : Swift.Sendable {}
extension SKC.ApiErrorType : Swift.BitwiseCopyable {}
extension SKC.IncrementalAuthorizationStatus : Swift.Sendable {}
extension SKC.IncrementalAuthorizationStatus : Swift.BitwiseCopyable {}
extension SKC.PaymentIntentStatus : Swift.Sendable {}
extension SKC.PaymentIntentStatus : Swift.BitwiseCopyable {}
extension SKC.SetupAttemptStatus : Swift.Sendable {}
extension SKC.SetupAttemptStatus : Swift.BitwiseCopyable {}
extension SKC.SetupErrorType : Swift.Sendable {}
extension SKC.SetupErrorType : Swift.BitwiseCopyable {}
extension SKC.__Bridge__Reader_NetworkStatus : Swift.Sendable {}
extension SKC.__Bridge__Reader_NetworkStatus : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ReaderSoftwareUpdate_UpdateDurationEstimate : Swift.Sendable {}
extension SKC.__Bridge__ReaderSoftwareUpdate_UpdateDurationEstimate : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ReaderSoftwareUpdate_UpdateComponent : Swift.Sendable {}
extension SKC.__Bridge__ReaderSoftwareUpdate_UpdateComponent : Swift.BitwiseCopyable {}
extension SKC.LocationStatus : Swift.Sendable {}
extension SKC.LocationStatus : Swift.BitwiseCopyable {}
extension SKC.DisconnectReason : Swift.Sendable {}
extension SKC.DisconnectReason : Swift.BitwiseCopyable {}
extension SKC.ReaderEvent_ : Swift.Sendable {}
extension SKC.ReaderEvent_ : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ReaderInputOptions__ReaderInputOption : Swift.Sendable {}
extension SKC.__Bridge__ReaderInputOptions__ReaderInputOption : Swift.BitwiseCopyable {}
extension SKC.ReaderDisplayMessage_ : Swift.Sendable {}
extension SKC.ReaderDisplayMessage_ : Swift.BitwiseCopyable {}
extension SKC.BatteryStatus : Swift.Sendable {}
extension SKC.BatteryStatus : Swift.BitwiseCopyable {}
extension SKC.NetworkStatus : Swift.Sendable {}
extension SKC.NetworkStatus : Swift.BitwiseCopyable {}
extension SKC.PaymentStatus : Swift.Sendable {}
extension SKC.PaymentStatus : Swift.BitwiseCopyable {}
extension SKC.ConnectionStatus : Swift.Sendable {}
extension SKC.ConnectionStatus : Swift.BitwiseCopyable {}
extension SKC.CollectDataType : Swift.Sendable {}
extension SKC.CollectDataType : Swift.BitwiseCopyable {}
extension SKC.CustomerAcceptanceType : Swift.Sendable {}
extension SKC.CustomerAcceptanceType : Swift.BitwiseCopyable {}
extension SKC.ToggleValue : Swift.Sendable {}
extension SKC.ToggleValue : Swift.BitwiseCopyable {}
extension SKC.ToggleResult : Swift.Sendable {}
extension SKC.ToggleResult : Swift.BitwiseCopyable {}
extension SKC.ReaderTextToSpeechStatus : Swift.Sendable {}
extension SKC.ReaderTextToSpeechStatus : Swift.BitwiseCopyable {}
extension SKC.SelectionButtonStyle : Swift.Sendable {}
extension SKC.SelectionButtonStyle : Swift.BitwiseCopyable {}
extension SKC.SimulateReaderUpdate : Swift.Sendable {}
extension SKC.SimulateReaderUpdate : Swift.BitwiseCopyable {}
extension SKC.SimulatedCardType : Swift.Sendable {}
extension SKC.SimulatedCardType : Swift.BitwiseCopyable {}
extension SKC.ObjectClass : Swift.Sendable {}
extension SKC.ObjectClass : Swift.BitwiseCopyable {}
extension SKC.Construction : Swift.Sendable {}
extension SKC.Construction : Swift.BitwiseCopyable {}
extension SKC.ElementOrigin : Swift.Sendable {}
extension SKC.ElementOrigin : Swift.BitwiseCopyable {}
extension SKC.TaggedDataElementSpec : Swift.Sendable {}
extension SKC.TaggedDataElementSpec : Swift.BitwiseCopyable {}
extension SKC.PaymentCollectionState : Swift.Sendable {}
extension SKC.PaymentCollectionState : Swift.BitwiseCopyable {}
extension SKC.SCARequirement : Swift.Sendable {}
extension SKC.SCARequirement : Swift.BitwiseCopyable {}
extension SKC.CancelReason : Swift.Sendable {}
extension SKC.CancelReason : Swift.BitwiseCopyable {}
extension SKC.EarlyTransactionAbortReason : Swift.Sendable {}
extension SKC.EarlyTransactionAbortReason : Swift.BitwiseCopyable {}
extension SKC.PendingPosCommand : Swift.Sendable {}
extension SKC.PendingPosCommand : Swift.BitwiseCopyable {}
extension SKC.OnlineAuthType : Swift.Sendable {}
extension SKC.OnlineAuthType : Swift.BitwiseCopyable {}
extension SKC.PinEntryFailureReason : Swift.Sendable {}
extension SKC.PinEntryFailureReason : Swift.BitwiseCopyable {}
extension SKC.Result : Swift.Sendable {}
extension SKC.Result : Swift.BitwiseCopyable {}
extension SKC.DisplayCartResult : Swift.Sendable {}
extension SKC.DisplayCartResult : Swift.BitwiseCopyable {}
extension SKC.LatencyCategory : Swift.Sendable {}
extension SKC.LatencyCategory : Swift.BitwiseCopyable {}
extension SKC.ManualEntryFailureReason : Swift.Sendable {}
extension SKC.ManualEntryFailureReason : Swift.BitwiseCopyable {}
extension SKC.ManualEntryState : Swift.Sendable {}
extension SKC.ManualEntryState : Swift.BitwiseCopyable {}
extension SKC.OnlineAuthFailureReason : Swift.Sendable {}
extension SKC.OnlineAuthFailureReason : Swift.BitwiseCopyable {}
extension SKC.OnlineAuthFailureReason_ : Swift.Sendable {}
extension SKC.OnlineAuthFailureReason_ : Swift.BitwiseCopyable {}
extension SKC.AccountSelectionFailureReason : Swift.Sendable {}
extension SKC.AccountSelectionFailureReason : Swift.BitwiseCopyable {}
extension SKC.ActionType : Swift.Sendable {}
extension SKC.ActionType : Swift.BitwiseCopyable {}
extension SKC.ApplicationSelectionFailureReason : Swift.Sendable {}
extension SKC.ApplicationSelectionFailureReason : Swift.BitwiseCopyable {}
extension SKC.CardPresentFailureReason : Swift.Sendable {}
extension SKC.CardPresentFailureReason : Swift.BitwiseCopyable {}
extension SKC.CollectionFailureReason : Swift.Sendable {}
extension SKC.CollectionFailureReason : Swift.BitwiseCopyable {}
extension SKC.DynamicCurrencyConversionSelectionFailureReason : Swift.Sendable {}
extension SKC.DynamicCurrencyConversionSelectionFailureReason : Swift.BitwiseCopyable {}
extension SKC.DynamicCurrencyConversionSelectionResult : Swift.Sendable {}
extension SKC.DynamicCurrencyConversionSelectionResult : Swift.BitwiseCopyable {}
extension SKC.KernelProcessingFailureReason : Swift.Sendable {}
extension SKC.KernelProcessingFailureReason : Swift.BitwiseCopyable {}
extension SKC.KernelProcessingStatus : Swift.Sendable {}
extension SKC.KernelProcessingStatus : Swift.BitwiseCopyable {}
extension SKC.NonCardPaymentMethodActionRequiredFailureReason : Swift.Sendable {}
extension SKC.NonCardPaymentMethodActionRequiredFailureReason : Swift.BitwiseCopyable {}
extension SKC.NonCardPaymentMethodSelectionFailureReason : Swift.Sendable {}
extension SKC.NonCardPaymentMethodSelectionFailureReason : Swift.BitwiseCopyable {}
extension SKC.OnlineConfirmationFailureReason : Swift.Sendable {}
extension SKC.OnlineConfirmationFailureReason : Swift.BitwiseCopyable {}
extension SKC.PaymentMethodType_ : Swift.Sendable {}
extension SKC.PaymentMethodType_ : Swift.BitwiseCopyable {}
extension SKC.WaitForPosCommandFailureReason : Swift.Sendable {}
extension SKC.WaitForPosCommandFailureReason : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ChargeAttempt_ExtendedAttemptRequirement : Swift.Sendable {}
extension SKC.__Bridge__ChargeAttempt_ExtendedAttemptRequirement : Swift.BitwiseCopyable {}
extension SKC.NonCardPaymentMethodCompletionMethod : Swift.Sendable {}
extension SKC.NonCardPaymentMethodCompletionMethod : Swift.BitwiseCopyable {}
extension SKC.__Bridge__PaymentMethodCollectionTypePassthrough_PassthroughType : Swift.Sendable {}
extension SKC.__Bridge__PaymentMethodCollectionTypePassthrough_PassthroughType : Swift.BitwiseCopyable {}
extension SKC.__Bridge__PaymentMethodCollectionTypeStrongCustomerAuthentication_Requirement : Swift.Sendable {}
extension SKC.__Bridge__PaymentMethodCollectionTypeStrongCustomerAuthentication_Requirement : Swift.BitwiseCopyable {}
extension SKC.__Bridge__MagstripePayment_FallbackReason : Swift.Sendable {}
extension SKC.__Bridge__MagstripePayment_FallbackReason : Swift.BitwiseCopyable {}
extension SKC.CountryCode : Swift.Sendable {}
extension SKC.CountryCode : Swift.BitwiseCopyable {}
extension SKC.__Bridge____CountryCode_Assignment : Swift.Sendable {}
extension SKC.__Bridge____CountryCode_Assignment : Swift.BitwiseCopyable {}
extension SKC.CurrencyCode : Swift.Sendable {}
extension SKC.CurrencyCode : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ReaderConfiguration_DomesticDebitPriority : Swift.Sendable {}
extension SKC.__Bridge__ReaderConfiguration_DomesticDebitPriority : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ReaderConfiguration_ReaderType : Swift.Sendable {}
extension SKC.__Bridge__ReaderConfiguration_ReaderType : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ReaderConfiguration_ContactlessOnlinePinOption : Swift.Sendable {}
extension SKC.__Bridge__ReaderConfiguration_ContactlessOnlinePinOption : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ReaderConfiguration_QuickChipOption : Swift.Sendable {}
extension SKC.__Bridge__ReaderConfiguration_QuickChipOption : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ReaderConfiguration_TransactionType : Swift.Sendable {}
extension SKC.__Bridge__ReaderConfiguration_TransactionType : Swift.BitwiseCopyable {}
extension SKC.CheckForCardBehavior : Swift.Sendable {}
extension SKC.CheckForCardBehavior : Swift.BitwiseCopyable {}
extension SKC.__Bridge__TransactionResult_Result : Swift.Sendable {}
extension SKC.__Bridge__TransactionResult_Result : Swift.BitwiseCopyable {}
extension SKC.IntermediateTransactionError : Swift.Sendable {}
extension SKC.IntermediateTransactionError : Swift.BitwiseCopyable {}
extension SKC.__Bridge__AccessiblePinPadTouchEvent_Type_ : Swift.Sendable {}
extension SKC.__Bridge__AccessiblePinPadTouchEvent_Type_ : Swift.BitwiseCopyable {}
extension SKC.PinEntryRetryReason : Swift.Sendable {}
extension SKC.PinEntryRetryReason : Swift.BitwiseCopyable {}
extension SKC.PinEntryStatus : Swift.Sendable {}
extension SKC.PinEntryStatus : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ApplicationSelectionModel_ApplicationSelectionRetryReason : Swift.Sendable {}
extension SKC.__Bridge__ApplicationSelectionModel_ApplicationSelectionRetryReason : Swift.BitwiseCopyable {}
extension SKC.ContactCardSlotState : Swift.Sendable {}
extension SKC.ContactCardSlotState : Swift.BitwiseCopyable {}
extension SKC.EmvTransactionType : Swift.Sendable {}
extension SKC.EmvTransactionType : Swift.BitwiseCopyable {}
extension SKC.TransactionType : Swift.Sendable {}
extension SKC.TransactionType : Swift.BitwiseCopyable {}
extension SKC.PaymentCollectionResultType : Swift.Sendable {}
extension SKC.PaymentCollectionResultType : Swift.BitwiseCopyable {}
extension SKC.TippingSelectionFailureReason : Swift.Sendable {}
extension SKC.TippingSelectionFailureReason : Swift.BitwiseCopyable {}
extension SKC.TippingSelectionType : Swift.Sendable {}
extension SKC.TippingSelectionType : Swift.BitwiseCopyable {}
extension SKC.ManualEntryType : Swift.Sendable {}
extension SKC.ManualEntryType : Swift.BitwiseCopyable {}
extension SKC.PaymentCollectionTimeoutResultDetails : Swift.Sendable {}
extension SKC.PaymentCollectionTimeoutResultDetails : Swift.BitwiseCopyable {}
extension SKC.RecoverableError : Swift.Sendable {}
extension SKC.RecoverableError : Swift.BitwiseCopyable {}
extension SKC.AudioAlertType : Swift.Sendable {}
extension SKC.AudioAlertType : Swift.BitwiseCopyable {}
extension SKC.ReaderDisplayMessage : Swift.Sendable {}
extension SKC.ReaderDisplayMessage : Swift.BitwiseCopyable {}
extension SKC.DispositionCanceledReason : Swift.Sendable {}
extension SKC.DispositionCanceledReason : Swift.BitwiseCopyable {}
extension SKC.DisclosureMode : Swift.Sendable {}
extension SKC.DisclosureMode : Swift.BitwiseCopyable {}
extension SKC.CancellationPhase : Swift.Sendable {}
extension SKC.CancellationPhase : Swift.BitwiseCopyable {}
extension SKC.__Bridge__Confirmation_PinError : Swift.Sendable {}
extension SKC.__Bridge__Confirmation_PinError : Swift.BitwiseCopyable {}
extension SKC.CardStatus : Swift.Sendable {}
extension SKC.CardStatus : Swift.BitwiseCopyable {}
extension SKC.Phase : Swift.Sendable {}
extension SKC.Phase : Swift.BitwiseCopyable {}
extension SKC.BbposErrorMode : Swift.Sendable {}
extension SKC.BbposErrorMode : Swift.BitwiseCopyable {}
extension SKC.TamperType : Swift.Sendable {}
extension SKC.TamperType : Swift.BitwiseCopyable {}
extension SKC.CancellationType : Swift.Sendable {}
extension SKC.CancellationType : Swift.BitwiseCopyable {}
extension SKC.DisconnectCause : Swift.Sendable {}
extension SKC.DisconnectCause : Swift.BitwiseCopyable {}
extension SKC.ReaderBatteryStatus : Swift.Sendable {}
extension SKC.ReaderBatteryStatus : Swift.BitwiseCopyable {}
extension SKC.ReaderEvent : Swift.Sendable {}
extension SKC.ReaderEvent : Swift.BitwiseCopyable {}
extension SKC.__Bridge__ReaderInputOptions_ReaderInputOption : Swift.Sendable {}
extension SKC.__Bridge__ReaderInputOptions_ReaderInputOption : Swift.BitwiseCopyable {}
extension SKC.ReaderPowerEvent : Swift.Sendable {}
extension SKC.ReaderPowerEvent : Swift.BitwiseCopyable {}
extension SKC.RebootCause : Swift.Sendable {}
extension SKC.RebootCause : Swift.BitwiseCopyable {}
extension SKC.__Bridge__InvalidTipConfig_Reason : Swift.Sendable {}
extension SKC.__Bridge__InvalidTipConfig_Reason : Swift.BitwiseCopyable {}
extension SKC.IntegrationType : Swift.Sendable {}
extension SKC.IntegrationType : Swift.BitwiseCopyable {}
extension SKC.TransactionOpType : Swift.Sendable {}
extension SKC.TransactionOpType : Swift.BitwiseCopyable {}
extension SKC.MagStripePaymentCollectionAuthority : Swift.Sendable {}
extension SKC.MagStripePaymentCollectionAuthority : Swift.BitwiseCopyable {}
extension SKC.__Bridge__MagStripeReadFailure_FailureType : Swift.Sendable {}
extension SKC.__Bridge__MagStripeReadFailure_FailureType : Swift.BitwiseCopyable {}
extension SKC.AccountType : Swift.Sendable {}
extension SKC.AccountType : Swift.BitwiseCopyable {}
extension SKC.InterfaceType : Swift.Sendable {}
extension SKC.InterfaceType : Swift.BitwiseCopyable {}
extension SKC.SourceType : Swift.Sendable {}
extension SKC.SourceType : Swift.BitwiseCopyable {}
extension SKC.ApplicationId : Swift.Sendable {}
extension SKC.ApplicationId : Swift.BitwiseCopyable {}
extension SKC.ApplicationPreferredName : Swift.Sendable {}
extension SKC.ApplicationPreferredName : Swift.BitwiseCopyable {}
extension SKC.CvmStatus : Swift.Sendable {}
extension SKC.CvmStatus : Swift.BitwiseCopyable {}
extension SKC.CvmType : Swift.Sendable {}
extension SKC.CvmType : Swift.BitwiseCopyable {}
extension SKC.TerminalApplicationSelectionIndicator : Swift.Sendable {}
extension SKC.TerminalApplicationSelectionIndicator : Swift.BitwiseCopyable {}
extension SKC.TerminalEmvKernelVersionVectorConfiguration : Swift.Sendable {}
extension SKC.TerminalEmvKernelVersionVectorConfiguration : Swift.BitwiseCopyable {}
extension SKC.TerminalEmvApplicationId : Swift.Sendable {}
extension SKC.TerminalEmvApplicationId : Swift.BitwiseCopyable {}
extension SKC.__Bridge__TerminalDeviceTraceLevel_TraceLevel : Swift.Sendable {}
extension SKC.__Bridge__TerminalDeviceTraceLevel_TraceLevel : Swift.BitwiseCopyable {}
extension SKC.TerminalLocale : Swift.Sendable {}
extension SKC.TerminalLocale : Swift.BitwiseCopyable {}
extension SKC.__Bridge__TerminalImageRef_ImageFormat : Swift.Sendable {}
extension SKC.__Bridge__TerminalImageRef_ImageFormat : Swift.BitwiseCopyable {}
extension SKC.PublicSwipeReason : Swift.Sendable {}
extension SKC.PublicSwipeReason : Swift.BitwiseCopyable {}
extension SKC.PublicReadMethod : Swift.Sendable {}
extension SKC.PublicReadMethod : Swift.BitwiseCopyable {}
extension SKC.PublicCardBrand : Swift.Sendable {}
extension SKC.PublicCardBrand : Swift.BitwiseCopyable {}
extension SKC.Skie.KotlinxCoroutinesCore.SelectClause0.__Sealed : Swift.Sendable {}
extension SKC.Skie.KotlinxCoroutinesCore.SelectClause0.__Sealed : Swift.BitwiseCopyable {}
extension SKC.Skie.KotlinxCoroutinesCore.SelectInstance.__Sealed : Swift.Sendable {}
extension SKC.Skie.KotlinxCoroutinesCore.SelectInstance.__Sealed : Swift.BitwiseCopyable {}
extension SKC.Skie.KotlinxCoroutinesCore.SelectClause1.__Sealed : Swift.Sendable {}
extension SKC.Skie.KotlinxCoroutinesCore.SelectClause1.__Sealed : Swift.BitwiseCopyable {}
extension SKC.Skie.KotlinxCoroutinesCore.SelectClause2.__Sealed : Swift.Sendable {}
extension SKC.Skie.KotlinxCoroutinesCore.SelectClause2.__Sealed : Swift.BitwiseCopyable {}
extension SKC.Skie.KotlinxSerializationCore.SerializersModule.__Sealed : Swift.Sendable {}
extension SKC.Skie.KotlinxSerializationCore.SerializersModule.__Sealed : Swift.BitwiseCopyable {}
